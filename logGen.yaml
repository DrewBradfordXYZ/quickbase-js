project: quickbase-js
date: 3/9/2025
root: /home/drew/Projects/quickbase-js
goals:
  - Implement a QuickBase API client in TypeScript.
  - Generate client methods from the QuickBase RESTful API spec.
  - Provide a simple and intuitive interface for interacting with QuickBase.
  - Support both Node.js and browser environments.
  - 'Use case: JS frameworks like React, Vue, and Angular hosted in QuickBase code pages.'
  - Node.js is supported using User Tokens
  - Use OpenAPI to generate the TypeScript types and methods.
  - Use the latest ES6+ features and TypeScript features.
  - '#'
  - No manual updating methods when the QuickBase API changes.
  - The proxy magic dynamically maps generated methods.
  - No manual endpoint definitions—endpoints come from the generated apis (e.g., AppsApi.getApp).
  - '#'
  - 'Per-Instance Store: tokenCache is defined per quickbaseClient call, so each instance has its own isolated TokenCache.'
  - 'No Singleton: No shared state—tokens are fetched and cached within the current instance.'
tree:
  name: .
  type: directory
  children:
    - name: .env
      type: file
    - name: .gitignore
      type: file
    - name: LICENSE
      type: file
    - name: README.md
      type: file
    - name: build.js
      type: file
    - name: dist
      type: directory
      children:
        - name: quickbaseClient.js
          type: file
        - name: quickbaseClient.js.map
          type: file
    - name: examples
      type: directory
      children:
        - name: react.js
          type: file
        - name: vanillajs.html
          type: file
    - name: logGen.yaml
      type: file
    - name: openapitools.json
      type: file
    - name: package-lock.json
      type: file
    - name: package.json
      type: file
      contents: |
        {
          "name": "quickbase-js",
          "main": "dist/quickbaseClient.js",
          "types": "dist/quickbaseClient.d.ts",
          "version": "1.0.0",
          "description": "QuickBase JavaScript client for frameworks and vanilla JS",
          "module": "dist/quickbaseClient.js",
          "type": "module",
          "exports": {
            ".": {
              "import": "./dist/quickbaseClient.js",
              "types": "./dist/quickbaseClient.d.ts"
            }
          },
          "scripts": {
            "fix-spec": "node --loader ts-node/esm src/code-generation/fix-spec-main.ts",
            "regenerate": "node --loader ts-node/esm src/code-generation/regenerate-client.ts",
            "generate-unified": "node --loader ts-node/esm src/code-generation/generate-unified-interface.ts",
            "log-gen": "node --loader ts-node/esm src/log-gen.ts",
            "build": "rimraf dist && rollup -c",
            "build:prod": "rm -rf dist/* && NODE_ENV=production rollup -c",
            "test": "vitest run tests/vitest/**/**/*.test.ts",
            "test:pw:qb:all": "playwright test tests/playwright/qb --config playwright.config.ts",
            "test:vitest:qb": "vitest run tests/vitest/qb/**/*.test.ts",
            "test:vitest:qb:apps": "vitest run tests/vitest/qb/apps/**/*.test.ts",
            "test:vitest:qb:auth": "vitest run tests/vitest/qb/auth/**/*.test.ts",
            "test:vitest:qb:fields": "vitest run tests/vitest/qb/fields/**/*.test.ts",
            "test:vitest:qb:tables": "vitest run tests/vitest/qb/tables/**/*.test.ts",
            "test:pw:qb:auth": "playwright test tests/playwright/qb/auth",
            "test::pw:qb:auth:temptoken": "playwright test tests/playwright/qb/auth/getTempToken.test.ts",
            "test:pw:qb:auth:renewal": "playwright test tests/playwright/qb/auth/tokenRenewal.test.ts",
            "test:pw:qb:auth:cache": "playwright test tests/playwright/qb/auth/cacheSwitching.test.ts",
            "test:pw:qb:auth:temp401": "playwright test tests/playwright/qb/auth/fetchTempToken401.test.ts",
            "test:pw:qb:auth:prefetch": "playwright test tests/playwright/qb/auth/tokenPrefetch.test.ts",
            "test:pw:qb:auth:debug": "playwright test tests/playwright/qb/auth --headed --debug",
            "test:pw:qb:auth:temp:debug": "playwright test tests/playwright/qb/auth/getTempToken.test.ts --headed --debug",
            "test:pw:qb:auth:renewal:debug": "playwright test tests/playwright/qb/auth/tokenRenewal.test.ts --headed --debug --config=playwright.config.ts",
            "test:pw:qb:auth:cache:debug": "playwright test tests/playwright/qb/auth/cacheSwitching.test.ts --headed --debug"
          },
          "dependencies": {
            "typescript": "^5.8.2"
          },
          "devDependencies": {
            "@openapitools/openapi-generator-cli": "^2.17.0",
            "@playwright/test": "^1.51.0",
            "@rollup/plugin-commonjs": "^28.0.3",
            "@rollup/plugin-node-resolve": "^16.0.0",
            "@rollup/plugin-terser": "^0.4.4",
            "@rollup/plugin-typescript": "^12.1.2",
            "@types/node": "^20.17.24",
            "dotenv": "^16.4.7",
            "glob": "^11.0.1",
            "js-yaml": "^4.1.0",
            "jsdom": "^24.1.3",
            "node-fetch": "^3.3.2",
            "openapi-types": "^12.1.3",
            "rimraf": "^5.0.10",
            "rollup": "^4.34.9",
            "rollup-plugin-dts": "^6.1.1",
            "ts-morph": "^23.0.0",
            "ts-node": "^10.9.2",
            "tslib": "^2.8.1",
            "vitest": "^1.6.0"
          }
        }
    - name: playwright.config.ts
      type: file
    - name: rollup.config.js
      type: file
      contents: |
        import typescript from "@rollup/plugin-typescript";
        import terser from "@rollup/plugin-terser";
        import nodeResolve from "@rollup/plugin-node-resolve";
        import commonjs from "@rollup/plugin-commonjs";
        import dts from "rollup-plugin-dts";

        const isProd = process.env.NODE_ENV === "production";

        export default [
          {
            input: "src/quickbaseClient.ts",
            output: {
              dir: "dist",
              format: "esm",
              sourcemap: true,
              compact: isProd,
              entryFileNames: "quickbaseClient.js",
            },
            external: [
              "node:http",
              "node:https",
              "node:zlib",
              "node:stream",
              "node:buffer",
              "node:util",
              "node:url",
              "node:net",
              "node:fs",
              "node:path",
              "node-fetch",
            ],
            plugins: [
              nodeResolve({ preferBuiltins: true }),
              commonjs(),
              typescript({
                tsconfig: "./tsconfig.json", // Updated to single tsconfig
                declaration: false, // Rollup handles this separately
              }),
              isProd && terser(),
            ],
          },
          {
            input: "src/quickbaseClient.ts",
            output: {
              file: "dist/quickbaseClient.d.ts",
              format: "esm",
            },
            plugins: [
              dts({
                tsconfig: "./tsconfig.json", // Updated to single tsconfig
              }),
            ],
          },
        ].map((config) => ({
          ...config,
          onwarn(warning, warn) {
            if (
              warning.code === "PLUGIN_WARNING" &&
              warning.plugin === "typescript" &&
              warning.message.includes("TS5096")
            ) {
              return;
            }
            warn(warning);
          },
        }));
    - name: src
      type: directory
      children:
        - name: code-generation
          type: directory
          children:
            - name: fix-spec-definitions.ts
              type: file
              contents: |
                export const definitions = {
                  App: {
                    type: "object",
                    properties: {
                      id: { type: "string" },
                      name: { type: "string" },
                      created: { type: "string", format: "date-time" },
                      updated: { type: "string", format: "date-time" },
                      description: { type: "string" },
                      timeZone: { type: "string" },
                      dateFormat: { type: "string" },
                      hasEveryoneOnTheInternet: { type: "boolean" },
                      memoryInfo: {
                        type: "object",
                        properties: {
                          estMemory: { type: "number" },
                          estMemoryInclDependentApps: { type: "number" },
                        },
                      },
                      securityProperties: {
                        type: "object",
                        properties: {
                          allowClone: { type: "boolean" },
                          allowExport: { type: "boolean" },
                          enableAppTokens: { type: "boolean" },
                          hideFromPublic: { type: "boolean" },
                          mustBeRealmApproved: { type: "boolean" },
                          useIPFilter: { type: "boolean" },
                        },
                      },
                    },
                    required: ["id", "name"],
                  },
                  Field: {
                    type: "object",
                    properties: {
                      id: { type: "number" },
                      label: { type: "string" },
                      fieldType: { type: "string" },
                      noWrap: { type: "boolean" },
                      bold: { type: "boolean" },
                      required: { type: "boolean" },
                      appearsByDefault: { type: "boolean" },
                      findEnabled: { type: "boolean" },
                      unique: { type: "boolean" },
                      doesDataCopy: { type: "boolean" },
                      fieldHelp: { type: "string" },
                      audited: { type: "boolean" },
                      properties: {
                        type: "object",
                        properties: {
                          primaryKey: { type: "boolean" },
                          foreignKey: { type: "boolean" },
                          numLines: { type: "number" },
                          maxLength: { type: "number" },
                          appendOnly: { type: "boolean" },
                          allowHTML: { type: "boolean" },
                          allowMentions: { type: "boolean" },
                          sortAsGiven: { type: "boolean" },
                          carryChoices: { type: "boolean" },
                          allowNewChoices: { type: "boolean" },
                          formula: { type: "string" },
                          defaultValue: { type: "string" },
                        },
                      },
                      permissions: {
                        type: "array",
                        items: {
                          type: "object",
                          properties: {
                            permissionType: { type: "string" },
                            role: { type: "string" },
                            roleId: { type: "number" },
                          },
                        },
                      },
                    },
                    required: ["id", "label", "fieldType"],
                  },
                  Table: {
                    type: "object",
                    properties: {
                      id: { type: "string" },
                      name: { type: "string" },
                      alias: { type: "string" },
                      created: { type: "string", format: "date-time" },
                      defaultSortFieldId: { type: "number" },
                      defaultSortOrder: { type: "string" },
                      description: { type: "string" },
                      keyFieldId: { type: "number" },
                      nextFieldId: { type: "number" },
                      nextRecordId: { type: "number" },
                      pluralRecordName: { type: "string" },
                      singleRecordName: { type: "string" },
                      sizeLimit: { type: "string" },
                      spaceRemaining: { type: "string" },
                      spaceUsed: { type: "string" },
                      updated: { type: "string", format: "date-time" },
                    },
                    required: ["id", "name"],
                  },
                  Record: {
                    type: "object",
                    properties: {
                      id: { type: "number" },
                      fields: {
                        type: "object",
                        additionalProperties: { type: "string" },
                      },
                    },
                    required: ["id"],
                  },
                  Upsert200Response: {
                    type: "object",
                    properties: {
                      id: { type: "number" },
                      status: { type: "string" },
                    },
                    required: ["id"],
                  },
                  ReportRunResponse: {
                    type: "object",
                    properties: {
                      id: { type: "string" },
                      data: { type: "object" }, // Placeholder
                    },
                    required: ["id"],
                  },
                  GetTempTokenDBID200Response: {
                    type: "object",
                    properties: {
                      temporaryAuthorization: { type: "string" },
                    },
                    required: ["temporaryAuthorization"],
                  },
                };
            - name: fix-spec-main.ts
              type: file
              contents: |
                #!/usr/bin/env node
                import { promises as fs } from "fs";
                import path from "path";
                import { fileURLToPath } from "url";
                import * as glob from "glob";
                import { paths } from "./fix-spec-paths.ts";
                import { definitions } from "./fix-spec-definitions.ts";

                interface Parameter {
                  name: string;
                  in: string;
                  required?: boolean;
                  type?: string;
                  schema?: { type?: string; items?: any; $ref?: string; properties?: any };
                  example?: any;
                }

                interface Operation {
                  parameters?: Parameter[];
                  responses?: Record<string, { description: string; schema?: any }>;
                  operationId?: string;
                  summary?: string;
                  tags?: string[];
                }

                interface Spec {
                  paths: Record<string, Record<string, Operation>>;
                  definitions?: Record<string, any>;
                  operations?: any;
                  groups?: any;
                  components?: any;
                }

                function toCamelCase(str: string): string {
                  return str
                    .replace(/[-_](.)/g, (_, char) => char.toUpperCase())
                    .replace(/^./, (str) => str.toLowerCase());
                }

                function fixArraySchemas(spec: Spec) {
                  for (const pathKey in spec.paths) {
                    for (const method in spec.paths[pathKey]) {
                      const operation = spec.paths[pathKey][method];
                      if (operation.parameters) {
                        operation.parameters.forEach((param: Parameter) => {
                          if (param.schema) {
                            if (param.schema.type === "array" && !param.schema.items) {
                              console.log(
                                `Fixing missing items in ${pathKey}(${method}).${param.name}`
                              );
                              param.schema.items =
                                pathKey === "/records" && param.name === "generated"
                                  ? { $ref: "#/definitions/Record" }
                                  : { type: "string" };
                            }
                            if (param.schema.properties) {
                              for (const propKey in param.schema.properties) {
                                const prop = param.schema.properties[propKey];
                                if (prop.type === "array" && !prop.items) {
                                  console.log(
                                    `Fixing nested array in ${pathKey}(${method}).${param.name}.${propKey}`
                                  );
                                  prop.items =
                                    propKey === "data" && pathKey === "/records"
                                      ? { $ref: "#/definitions/Record" }
                                      : { type: "string" };
                                }
                              }
                            }
                          }
                        });
                      }
                      if (operation.responses) {
                        for (const status in operation.responses) {
                          const response = operation.responses[status];
                          if (response.schema) {
                            if (response.schema.type === "array" && !response.schema.items) {
                              console.log(
                                `Fixing missing items in ${pathKey}(${method}).responses.${status}`
                              );
                              response.schema.items =
                                pathKey === "/records"
                                  ? { $ref: "#/definitions/Upsert200Response" }
                                  : { type: "string" };
                            }
                            if (response.schema.properties) {
                              for (const propKey in response.schema.properties) {
                                const prop = response.schema.properties[propKey];
                                if (prop.type === "array" && !prop.items) {
                                  console.log(
                                    `Fixing nested array in ${pathKey}(${method}).responses.${status}.${propKey}`
                                  );
                                  prop.items =
                                    propKey === "data" && pathKey === "/records"
                                      ? { $ref: "#/definitions/Upsert200Response" }
                                      : { type: "string" };
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                async function fixQuickBaseSpec(): Promise<void> {
                  try {
                    const CODEGEN_DIR = path.dirname(fileURLToPath(import.meta.url));
                    const SPECS_DIR = path.join(CODEGEN_DIR, "..", "specs");
                    const OUTPUT_DIR = path.join(CODEGEN_DIR, "output");
                    console.log("Finding latest QuickBase RESTful API spec...");
                    const specFiles = glob.sync(
                      path.join(SPECS_DIR, "QuickBase_RESTful_*.json")
                    );
                    if (specFiles.length === 0) {
                      console.error(
                        "No QuickBase_RESTful_*.json files found in specs/ folder."
                      );
                      process.exit(1);
                    }
                    const inputFile = specFiles.sort().pop() as string;
                    const outputFile = path.join(OUTPUT_DIR, "quickbase-fixed.json");

                    console.log(`Reading ${path.basename(inputFile)} from specs/...`);
                    const specContent = await fs.readFile(inputFile, "utf8");
                    const spec: Spec = JSON.parse(specContent);

                    console.log("Fixing parameters...");
                    for (const pathKey in spec.paths) {
                      for (const method in spec.paths[pathKey]) {
                        const operation = spec.paths[pathKey][method];
                        if (operation.parameters) {
                          operation.parameters = operation.parameters
                            .filter(
                              (param) =>
                                !["QB-Realm-Hostname", "Authorization", "User-Agent"].includes(
                                  param.name
                                )
                            )
                            .map((param: Parameter) => {
                              param.name = toCamelCase(param.name);
                              if ("example" in param) delete param.example;
                              if ("schema" in param && param.in !== "body") delete param.schema;
                              if (!param.type && param.in !== "body") param.type = "string";
                              return param;
                            });
                        }
                      }
                    }

                    console.log("Applying endpoint fixes...");
                    spec.paths = { ...spec.paths, ...paths }; // Merge original and custom paths

                    console.log("Fixing array schemas...");
                    fixArraySchemas(spec);

                    console.log("Applying definitions...");
                    spec.definitions = { ...spec.definitions, ...definitions }; // Merge definitions

                    console.log("Removing unexpected top-level attributes...");
                    delete spec.operations;
                    delete spec.groups;
                    delete spec.components;

                    console.log(`Writing fixed spec to ${path.basename(outputFile)}...`);
                    await fs.mkdir(OUTPUT_DIR, { recursive: true });
                    await fs.writeFile(outputFile, JSON.stringify(spec, null, 2), "utf8");
                    console.log("Spec fixed successfully!");
                  } catch (error) {
                    console.error("Failed to fix spec:", error);
                    process.exit(1);
                  }
                }

                fixQuickBaseSpec();
            - name: fix-spec-paths.ts
              type: file
              contents: |
                export const paths = {
                  "/apps/{appId}": {
                    get: {
                      operationId: "getApp",
                      summary: "Get an app by ID",
                      tags: ["Apps"],
                      parameters: [
                        {
                          name: "appId",
                          in: "path",
                          required: true,
                          type: "string",
                        },
                      ],
                      responses: {
                        200: {
                          description: "Success",
                          schema: { $ref: "#/definitions/App" },
                        },
                      },
                    },
                  },
                  "/fields": {
                    get: {
                      operationId: "getFields",
                      summary: "Get all fields for a table",
                      tags: ["Fields"],
                      parameters: [
                        {
                          name: "tableId",
                          in: "query",
                          required: true,
                          type: "string",
                        },
                        {
                          name: "includeFieldPerms",
                          in: "query",
                          required: false,
                          type: "boolean",
                        },
                      ],
                      responses: {
                        200: {
                          description: "Success",
                          schema: {
                            type: "array",
                            items: { $ref: "#/definitions/Field" },
                          },
                        },
                      },
                    },
                  },
                  "/tables": {
                    get: {
                      operationId: "getAppTables",
                      summary: "Get all tables for an app",
                      tags: ["Tables"],
                      parameters: [
                        {
                          name: "appId",
                          in: "query",
                          required: true,
                          type: "string",
                        },
                      ],
                      responses: {
                        200: {
                          description: "Success",
                          schema: {
                            type: "array",
                            items: { $ref: "#/definitions/Table" },
                          },
                        },
                      },
                    },
                  },
                  "/records/query": {
                    post: {
                      operationId: "upsertRecords",
                      summary: "Upsert records",
                      tags: ["Records"],
                      parameters: [
                        {
                          name: "generated",
                          in: "body",
                          required: true,
                          schema: {
                            type: "array",
                            items: { $ref: "#/definitions/Record" },
                          },
                        },
                      ],
                      responses: {
                        200: {
                          description: "Success",
                          schema: {
                            type: "array",
                            items: { $ref: "#/definitions/Upsert200Response" },
                          },
                        },
                        207: {
                          description: "Multi-Status (partial success)",
                          schema: {
                            type: "array",
                            items: { $ref: "#/definitions/Upsert200Response" },
                          },
                        },
                      },
                    },
                  },
                  "/reports/{reportId}/run": {
                    post: {
                      operationId: "runReport",
                      summary: "Run a report",
                      tags: ["Reports"],
                      parameters: [
                        {
                          name: "reportId",
                          in: "path",
                          required: true,
                          type: "string",
                        },
                        {
                          name: "generated",
                          in: "body",
                          required: true,
                          schema: { type: "object" },
                        },
                      ],
                      responses: {
                        200: {
                          description: "Success",
                          schema: {
                            type: "array",
                            items: { $ref: "#/definitions/ReportRunResponse" },
                          },
                        },
                      },
                    },
                  },
                  "/auth/temporary/{dbid}": {
                    get: {
                      operationId: "getTempTokenDBID",
                      summary: "Get a temporary authorization token for a specific dbid",
                      tags: ["Auth"],
                      parameters: [
                        {
                          name: "dbid",
                          in: "path",
                          required: true,
                          type: "string",
                        },
                      ],
                      responses: {
                        200: {
                          description: "Success",
                          schema: { $ref: "#/definitions/GetTempTokenDBID200Response" },
                        },
                      },
                    },
                  },
                };
            - name: generate-unified-interface.ts
              type: file
              contents: |
                // src/code-generation/generate-unified-interface.ts
                import { readFileSync, writeFileSync, mkdirSync, existsSync } from "fs";
                import { join, dirname } from "path";
                import { fileURLToPath } from "url";
                import { simplifyName } from "../utils.ts";
                import { OpenAPIV2 } from "openapi-types";

                const __dirname = dirname(fileURLToPath(import.meta.url));
                const SPEC_FILE = join(__dirname, "output", "quickbase-fixed.json");
                const OUTPUT_DIR = join(__dirname, "..", "generated-unified");
                const OUTPUT_FILE = join(OUTPUT_DIR, "QuickbaseClient.ts");

                function generateInterface() {
                  if (!existsSync(SPEC_FILE)) {
                    console.error(
                      `Spec file ${SPEC_FILE} not found. Run 'npm run fix-spec' first.`
                    );
                    process.exit(1);
                  }

                  console.log("Generating unified QuickbaseClient interface...");
                  const spec = JSON.parse(
                    readFileSync(SPEC_FILE, "utf8")
                  ) as OpenAPIV2.Document;
                  const { paths } = spec;

                  const modelImports = new Set<string>();
                  const methods: string[] = [];

                  for (const [path, methodsObj] of Object.entries(
                    paths as OpenAPIV2.PathsObject
                  )) {
                    if (!methodsObj) continue;

                    for (const [method, operation] of Object.entries(
                      methodsObj as OpenAPIV2.PathItemObject
                    )) {
                      const op = operation as OpenAPIV2.OperationObject | undefined;
                      if (!op || !op.operationId) continue;

                      const opId = op.operationId; // Use operationId directly, no simplification
                      const params = (op.parameters || [])
                        .filter((p) => {
                          const param = p as OpenAPIV2.ParameterObject;
                          return !["QB-Realm-Hostname", "Authorization", "User-Agent"].includes(
                            param.name
                          );
                        })
                        .map((p) => {
                          const param = p as OpenAPIV2.ParameterObject;
                          const type = param.type
                            ? mapOpenApiTypeToTs(param.type)
                            : param.schema
                            ? mapRefToType(param.schema, modelImports)
                            : "any";
                          return `${param.name}${param.required ? "" : "?"}: ${type}`;
                        })
                        .join("; ");
                      const response = op.responses?.["200"] as
                        | OpenAPIV2.ResponseObject
                        | undefined;
                      const returnType = response?.schema
                        ? mapRefToType(response.schema, modelImports)
                        : "void";
                      methods.push(
                        `  ${opId}: (params: { ${params} }) => Promise<${returnType}>;`
                      );
                    }
                  }

                  // Generate import and export statements for all model types
                  const importExportLines = Array.from(modelImports)
                    .map((m) => `export { ${m} } from "../generated/models/${m}.ts";`)
                    .join("\n");

                  const interfaceContent = `// Generated on ${new Date().toISOString()}\n${importExportLines}\n\nexport interface QuickbaseClient {\n${methods.join(
                    "\n"
                  )}\n}\n`;

                  if (!existsSync(OUTPUT_DIR)) {
                    mkdirSync(OUTPUT_DIR, { recursive: true });
                  }
                  writeFileSync(OUTPUT_FILE, interfaceContent, "utf8");
                  console.log(`Generated ${OUTPUT_FILE}`);
                }

                function mapOpenApiTypeToTs(openApiType: string): string {
                  switch (openApiType.toLowerCase()) {
                    case "integer":
                    case "int":
                      return "number";
                    case "string":
                      return "string";
                    case "boolean":
                      return "boolean";
                    default:
                      return "any";
                  }
                }

                function mapRefToType(
                  schema: OpenAPIV2.SchemaObject | OpenAPIV2.ReferenceObject,
                  modelImports: Set<string>
                ): string {
                  if ("$ref" in schema) {
                    const model = schema.$ref.split("/").pop()!;
                    modelImports.add(model);
                    return model;
                  }
                  if (schema.type === "array" && schema.items) {
                    const itemType =
                      "$ref" in schema.items
                        ? schema.items.$ref.split("/").pop()!
                        : mapOpenApiTypeToTs(schema.items.type || "any");
                    if ("$ref" in schema.items) modelImports.add(itemType);
                    return `${itemType}[]`;
                  }
                  return mapOpenApiTypeToTs(schema.type || "any");
                }

                try {
                  generateInterface();
                } catch (error) {
                  console.error("Generation failed:", error);
                  process.exit(1);
                }
            - name: output
              type: directory
              children:
                - name: quickbase-fixed.json
                  type: file
            - name: regenerate-client.ts
              type: file
              contents: |
                #!/usr/bin/env node
                import { execSync } from "child_process";
                import { existsSync } from "fs";
                import { join } from "path";
                import { fileURLToPath } from "url";
                import fetch from "node-fetch";
                import readline from "readline";

                const CURRENT_JAR_VERSION = "7.12.0";
                const MAVEN_METADATA_URL =
                  "https://repo1.maven.org/maven2/org/openapitools/openapi-generator-cli/maven-metadata.xml";
                const CODEGEN_DIR = join(fileURLToPath(import.meta.url), "..");
                const JARS_DIR = join(CODEGEN_DIR, "..", "openapi-jars");
                const SPEC_INPUT = join(CODEGEN_DIR, "output", "quickbase-fixed.json"); // Updated path
                const OUTPUT_DIR = join(CODEGEN_DIR, "..", "generated");

                async function getLatestVersion(): Promise<string> {
                  const response = await fetch(MAVEN_METADATA_URL);
                  if (!response.ok)
                    throw new Error(`Failed to fetch Maven metadata: ${response.statusText}`);
                  const text = await response.text();
                  const match = text.match(/<latest>(.*?)<\/latest>/);
                  if (!match)
                    throw new Error("Couldn’t parse latest version from Maven metadata");
                  return match[1];
                }

                async function checkAndPromptForUpdate(messages: string[]): Promise<string> {
                  const latestVersion = await getLatestVersion();
                  if (latestVersion === CURRENT_JAR_VERSION) {
                    messages.push(`Current version (${CURRENT_JAR_VERSION}) is the latest.`);
                    return CURRENT_JAR_VERSION;
                  }

                  messages.push(
                    `Newer version available: ${latestVersion} (current: ${CURRENT_JAR_VERSION})`
                  );
                  const rl = readline.createInterface({
                    input: process.stdin,
                    output: process.stdout,
                  });

                  return new Promise((resolve) => {
                    const prompt = "Do you want to update to the latest version? (y/n): ";
                    messages.push(prompt);
                    rl.question(prompt, (answer) => {
                      rl.close();
                      if (answer.toLowerCase() === "y" || answer.toLowerCase() === "yes") {
                        messages.push(`Switching to version ${latestVersion}...`);
                        resolve(latestVersion);
                      } else {
                        messages.push(`Sticking with version ${CURRENT_JAR_VERSION}.`);
                        resolve(CURRENT_JAR_VERSION);
                      }
                    });
                  });
                }

                async function ensureJarExists(
                  version: string,
                  messages: string[]
                ): Promise<string> {
                  const jarPath = join(JARS_DIR, `openapi-generator-cli-${version}.jar`);
                  const jarUrl = `https://repo1.maven.org/maven2/org/openapitools/openapi-generator-cli/${version}/openapi-generator-cli-${version}.jar`;

                  if (!existsSync(jarPath)) {
                    messages.push(`Downloading OpenAPI Generator CLI v${version}...`);
                    try {
                      execSync(`curl -L -o ${jarPath} ${jarUrl}`, { stdio: "inherit" });
                      messages.push(`Downloaded ${jarPath}`);
                    } catch (error) {
                      messages.push("Failed to download JAR.");
                      throw error;
                    }
                  } else {
                    messages.push(`Using existing ${jarPath}`);
                  }
                  return jarPath;
                }

                function regenerateClient(jarPath: string, messages: string[]) {
                  messages.push("Regenerating client from spec...");
                  const command = `java -jar ${jarPath} generate -i ${SPEC_INPUT} -g typescript-fetch -o ${OUTPUT_DIR}`;
                  try {
                    execSync(command, { stdio: "inherit" });
                    messages.push("Client regeneration complete.");
                  } catch (error) {
                    messages.push("Regeneration failed.");
                    throw error;
                  }
                }

                async function main() {
                  const messages: string[] = [];
                  try {
                    const versionToUse = await checkAndPromptForUpdate(messages);
                    const jarPath = await ensureJarExists(versionToUse, messages);
                    regenerateClient(jarPath, messages);
                  } catch (error) {
                    console.error("Error occurred during process:", error);
                  } finally {
                    console.log("\n--- Key Messages ---");
                    messages.forEach((msg) => console.log(msg));
                  }
                }

                main().catch((error) => {
                  console.error("Error in regeneration process:", error);
                  process.exit(1);
                });
        - name: generated
          type: directory
          children:
            - name: .openapi-generator
              type: directory
              children:
                - name: FILES
                  type: file
                - name: VERSION
                  type: file
            - name: .openapi-generator-ignore
              type: file
            - name: apis
              type: directory
              children:
                - name: AppsApi.ts
                  type: file
                - name: AuditApi.ts
                  type: file
                - name: AuthApi.ts
                  type: file
                - name: DocumentTemplatesApi.ts
                  type: file
                - name: FieldsApi.ts
                  type: file
                - name: FilesApi.ts
                  type: file
                - name: FormulasApi.ts
                  type: file
                - name: PlatformAnalyticsApi.ts
                  type: file
                - name: RecordsApi.ts
                  type: file
                - name: ReportsApi.ts
                  type: file
                - name: SolutionsApi.ts
                  type: file
                - name: TablesApi.ts
                  type: file
                - name: UserTokenApi.ts
                  type: file
                - name: UsersApi.ts
                  type: file
                - name: index.ts
                  type: file
            - name: index.ts
              type: file
            - name: models
              type: directory
              children:
                - name: AddMembersToGroup200Response.ts
                  type: file
                - name: AddSubgroupsToGroup200Response.ts
                  type: file
                - name: App.ts
                  type: file
                - name: AppMemoryInfo.ts
                  type: file
                - name: AppSecurityProperties.ts
                  type: file
                - name: Audit200Response.ts
                  type: file
                - name: Audit202Response.ts
                  type: file
                - name: AuditRequest.ts
                  type: file
                - name: CloneUserToken200Response.ts
                  type: file
                - name: CloneUserTokenRequest.ts
                  type: file
                - name: CopyApp200Response.ts
                  type: file
                - name: CopyAppRequest.ts
                  type: file
                - name: CreateApp200Response.ts
                  type: file
                - name: CreateAppRequest.ts
                  type: file
                - name: CreateRelationship200Response.ts
                  type: file
                - name: CreateRelationshipRequest.ts
                  type: file
                - name: DeactivateUserToken200Response.ts
                  type: file
                - name: DeleteFile200Response.ts
                  type: file
                - name: DeleteRecords200Response.ts
                  type: file
                - name: DeleteRecordsRequest.ts
                  type: file
                - name: DeleteRelationship200Response.ts
                  type: file
                - name: DeleteTable200Response.ts
                  type: file
                - name: DenyUsers200Response.ts
                  type: file
                - name: ExchangeSsoToken200Response.ts
                  type: file
                - name: ExchangeSsoTokenRequest.ts
                  type: file
                - name: Field.ts
                  type: file
                - name: FieldPermissionsInner.ts
                  type: file
                - name: FieldProperties.ts
                  type: file
                - name: GenerateDocument200Response.ts
                  type: file
                - name: GetField200Response.ts
                  type: file
                - name: GetRelationships200Response.ts
                  type: file
                - name: GetReport200Response.ts
                  type: file
                - name: GetTable200Response.ts
                  type: file
                - name: GetTempTokenDBID200Response.ts
                  type: file
                - name: GetUsers200Response.ts
                  type: file
                - name: GetUsersRequest.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200Response.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseMetadata.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseResultsInner.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseTotals.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseWhereInner.ts
                  type: file
                - name: PlatformAnalyticEventSummariesRequest.ts
                  type: file
                - name: PlatformAnalyticEventSummariesRequestWhereInner.ts
                  type: file
                - name: PlatformAnalyticReads200Response.ts
                  type: file
                - name: Record.ts
                  type: file
                - name: RemoveMembersFromGroup200Response.ts
                  type: file
                - name: RemoveSubgroupsFromGroup200Response.ts
                  type: file
                - name: ReportRunResponse.ts
                  type: file
                - name: RunFormula200Response.ts
                  type: file
                - name: RunFormulaRequest.ts
                  type: file
                - name: Table.ts
                  type: file
                - name: TransferUserToken200Response.ts
                  type: file
                - name: TransferUserTokenRequest.ts
                  type: file
                - name: UndenyUsers200Response.ts
                  type: file
                - name: UpdateFieldRequest.ts
                  type: file
                - name: UpdateRelationshipRequest.ts
                  type: file
                - name: UpdateTableRequest.ts
                  type: file
                - name: Upsert200Response.ts
                  type: file
                - name: Upsert207Response.ts
                  type: file
                - name: Upsert400Response.ts
                  type: file
                - name: UpsertRequest.ts
                  type: file
                - name: index.ts
                  type: file
            - name: runtime.ts
              type: file
        - name: generated-old
          type: directory
          children:
            - name: .openapi-generator
              type: directory
              children:
                - name: FILES
                  type: file
                - name: VERSION
                  type: file
            - name: .openapi-generator-ignore
              type: file
            - name: apis
              type: directory
              children:
                - name: AppsApi.ts
                  type: file
                - name: AuditApi.ts
                  type: file
                - name: AuthApi.ts
                  type: file
                - name: DocumentTemplatesApi.ts
                  type: file
                - name: FieldsApi.ts
                  type: file
                - name: FilesApi.ts
                  type: file
                - name: FormulasApi.ts
                  type: file
                - name: PlatformAnalyticsApi.ts
                  type: file
                - name: RecordsApi.ts
                  type: file
                - name: ReportsApi.ts
                  type: file
                - name: SolutionsApi.ts
                  type: file
                - name: TablesApi.ts
                  type: file
                - name: UserTokenApi.ts
                  type: file
                - name: UsersApi.ts
                  type: file
                - name: index.ts
                  type: file
            - name: index.ts
              type: file
            - name: models
              type: directory
              children:
                - name: AddMembersToGroup200Response.ts
                  type: file
                - name: AddSubgroupsToGroup200Response.ts
                  type: file
                - name: App.ts
                  type: file
                - name: AppMemoryInfo.ts
                  type: file
                - name: AppSecurityProperties.ts
                  type: file
                - name: Audit200Response.ts
                  type: file
                - name: Audit202Response.ts
                  type: file
                - name: AuditRequest.ts
                  type: file
                - name: CloneUserToken200Response.ts
                  type: file
                - name: CloneUserTokenRequest.ts
                  type: file
                - name: CopyApp200Response.ts
                  type: file
                - name: CopyAppRequest.ts
                  type: file
                - name: CreateApp200Response.ts
                  type: file
                - name: CreateAppRequest.ts
                  type: file
                - name: CreateField200Response.ts
                  type: file
                - name: CreateRelationship200Response.ts
                  type: file
                - name: CreateRelationshipRequest.ts
                  type: file
                - name: DeactivateUserToken200Response.ts
                  type: file
                - name: DeleteApp200Response.ts
                  type: file
                - name: DeleteAppRequest.ts
                  type: file
                - name: DeleteFields200Response.ts
                  type: file
                - name: DeleteFile200Response.ts
                  type: file
                - name: DeleteRelationship200Response.ts
                  type: file
                - name: DenyUsers200Response.ts
                  type: file
                - name: ExchangeSsoToken200Response.ts
                  type: file
                - name: ExchangeSsoTokenRequest.ts
                  type: file
                - name: Field.ts
                  type: file
                - name: FieldPermissionsInner.ts
                  type: file
                - name: FieldProperties.ts
                  type: file
                - name: GenerateDocument200Response.ts
                  type: file
                - name: GetField200Response.ts
                  type: file
                - name: GetRelationships200Response.ts
                  type: file
                - name: GetReport200Response.ts
                  type: file
                - name: GetTempTokenDBID200Response.ts
                  type: file
                - name: GetUsers200Response.ts
                  type: file
                - name: GetUsersRequest.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200Response.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseMetadata.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseResultsInner.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseTotals.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseWhereInner.ts
                  type: file
                - name: PlatformAnalyticEventSummariesRequest.ts
                  type: file
                - name: PlatformAnalyticEventSummariesRequestWhereInner.ts
                  type: file
                - name: PlatformAnalyticReads200Response.ts
                  type: file
                - name: RemoveMembersFromGroup200Response.ts
                  type: file
                - name: RemoveSubgroupsFromGroup200Response.ts
                  type: file
                - name: RunFormula200Response.ts
                  type: file
                - name: RunFormulaRequest.ts
                  type: file
                - name: RunQuery200Response.ts
                  type: file
                - name: RunQueryRequest.ts
                  type: file
                - name: RunReport200Response.ts
                  type: file
                - name: Table.ts
                  type: file
                - name: TransferUserToken200Response.ts
                  type: file
                - name: TransferUserTokenRequest.ts
                  type: file
                - name: UndenyUsers200Response.ts
                  type: file
                - name: UpdateApp200Response.ts
                  type: file
                - name: UpdateAppRequest.ts
                  type: file
                - name: UpdateFieldRequest.ts
                  type: file
                - name: UpdateRelationshipRequest.ts
                  type: file
                - name: Upsert200Response.ts
                  type: file
                - name: index.ts
                  type: file
            - name: runtime.ts
              type: file
        - name: generated-unified
          type: directory
          children:
            - name: QuickbaseClient.ts
              type: file
        - name: index.ts
          type: file
        - name: log-gen.ts
          type: file
        - name: openapi-jars
          type: directory
          children:
            - name: openapi-generator-cli-7.12.0.jar
              type: file
        - name: quickbaseClient.ts
          type: file
          contents: |
            // src/quickbaseClient.ts
            import { QuickbaseClient } from "./generated-unified/QuickbaseClient.ts";
            import {
              Configuration,
              HTTPHeaders,
              ResponseError,
            } from "./generated/runtime.ts";
            import * as apis from "./generated/apis/index.ts";
            import { simplifyName } from "./utils.ts";
            import { TokenCache } from "./tokenCache.ts";

            export interface QuickbaseConfig {
              realm: string;
              userToken?: string;
              tempToken?: string;
              useTempTokens?: boolean;
              debug?: boolean;
              fetchApi?: typeof fetch;
            }

            export interface TempTokenParams {
              appId?: string;
              tableId?: string;
              dbid?: string;
            }

            type ApiMethod<K extends keyof QuickbaseClient> = (
              requestParameters: Parameters<QuickbaseClient[K]>[0],
              initOverrides?: RequestInit
            ) => Promise<ReturnType<QuickbaseClient[K]>>;

            interface MethodInfo<K extends keyof QuickbaseClient> {
              api: any;
              method: ApiMethod<K>;
              paramMap: string[];
            }

            type MethodMap = { [K in keyof QuickbaseClient]: MethodInfo<K> };

            const getParamNames = (fn: (...args: any[]) => any): string[] =>
              fn
                .toString()
                .slice(fn.toString().indexOf("(") + 1, fn.toString().indexOf(")"))
                .split(",")
                .map((p) => p.trim().split("=")[0].trim())
                .filter((p) => p && !p.match(/^\{/) && p !== "options");

            // New utility function to extract dbid
            const extractDbid = (
              params: Partial<TempTokenParams>,
              errorMessage: string
            ): string => {
              const dbid = params.appId || params.tableId || params.dbid;
              if (!dbid) {
                throw new Error(errorMessage);
              }
              return dbid;
            };

            export function quickbaseClient(config: QuickbaseConfig): QuickbaseClient {
              const {
                realm,
                userToken,
                tempToken: initialTempToken,
                useTempTokens,
                fetchApi,
                debug,
              } = config;
              const baseUrl = `https://api.quickbase.com/v1`;

              const tokenCache = new TokenCache();

              const headers: HTTPHeaders = {
                "QB-Realm-Hostname": `${realm}.quickbase.com`,
                "Content-Type": "application/json",
              };

              if (initialTempToken) {
                headers["Authorization"] = `QB-TEMP-TOKEN ${initialTempToken}`;
              } else if (userToken && !useTempTokens) {
                headers["Authorization"] = `QB-USER-TOKEN ${userToken}`;
              }

              const defaultFetch =
                typeof window !== "undefined" ? window.fetch.bind(window) : undefined;
              const configuration = new Configuration({
                basePath: baseUrl,
                headers: { ...headers },
                fetchApi: fetchApi || defaultFetch,
                credentials: useTempTokens ? "include" : "omit",
              });

              if (!configuration.fetchApi && typeof window === "undefined") {
                throw new Error(
                  "fetchApi must be provided in non-browser environments (e.g., Node.js)"
                );
              }

              const apiInstances = Object.fromEntries(
                Object.entries(apis)
                  .filter(([name]) => name.endsWith("Api"))
                  .map(([name, ApiClass]) => [
                    name.replace("Api", "").toLowerCase(),
                    new ApiClass(configuration),
                  ])
              );

              const methodMap = buildMethodMap();

              function buildMethodMap(): MethodMap {
                const methodMap: Partial<MethodMap> = {};
                const isValidMethod = (name: string) =>
                  !name.startsWith("_") &&
                  name !== "constructor" &&
                  !["Middleware", "Pre", "Post", "Raw"].some((s) => name.includes(s));

                for (const [apiName, api] of Object.entries(apiInstances)) {
                  Object.getOwnPropertyNames(Object.getPrototypeOf(api))
                    .filter(
                      (name) =>
                        isValidMethod(name) &&
                        typeof api[name as keyof typeof api] === "function"
                    )
                    .forEach((rawMethodName) => {
                      const simplifiedName = simplifyName(
                        rawMethodName
                      ) as keyof QuickbaseClient;
                      const method = api[rawMethodName as keyof typeof api];
                      const boundMethod = method.bind(api) as unknown;
                      if (typeof boundMethod === "function" && boundMethod.length <= 2) {
                        methodMap[simplifiedName] = {
                          api,
                          method: boundMethod as ApiMethod<typeof simplifiedName>,
                          paramMap: getParamNames(method),
                        };
                        if (debug)
                          console.log(`Mapped ${rawMethodName} to ${simplifiedName}`);
                      }
                    });
                }
                return methodMap as MethodMap;
              }

              const fetchTempToken = async (dbid: string): Promise<string> => {
                const effectiveFetch = fetchApi || defaultFetch;
                if (!effectiveFetch) {
                  throw new Error(
                    "No fetch implementation available for fetching temp token"
                  );
                }

                const response = await effectiveFetch(
                  `https://api.quickbase.com/v1/auth/temporary/${dbid}`,
                  {
                    method: "GET",
                    headers: { ...headers },
                    credentials: "include",
                  }
                );

                if (!response.ok) {
                  const errorBody = await response.text();
                  throw new Error(`API Error: ${errorBody} (Status: ${response.status})`);
                }

                const tokenResult = await response.json();
                const token = tokenResult.temporaryAuthorization;
                if (!token) {
                  throw new Error("No temporary token returned from API");
                }
                tokenCache.set(dbid, token);
                if (debug) {
                  console.log(
                    `Fetched and cached new token for dbid: ${dbid}`,
                    token,
                    `Expires at: ${new Date(
                      Date.now() + (4 * 60 + 50) * 1000
                    ).toISOString()}`
                  );
                }
                return token;
              };

              const invokeMethod = async <K extends keyof QuickbaseClient>(
                methodName: K,
                params: Parameters<QuickbaseClient[K]>[0] & Partial<TempTokenParams>,
                retryCount: number = 0
              ): Promise<ReturnType<QuickbaseClient[K]>> => {
                const methodInfo = methodMap[methodName];
                if (!methodInfo) {
                  console.error(`Method ${methodName} not found in methodMap`, methodMap);
                  throw new Error(`Method ${methodName} not found`);
                }

                let token =
                  initialTempToken || (userToken && !useTempTokens ? userToken : undefined);
                let initOverrides: RequestInit = {};

                // Early return for getTempTokenDBID if cached token exists
                if (methodName === "getTempTokenDBID" && useTempTokens) {
                  const dbid = extractDbid(params, "No dbid provided for getTempTokenDBID");
                  const cachedToken = tokenCache.get(dbid);
                  if (cachedToken) {
                    return { temporaryAuthorization: cachedToken } as ReturnType<
                      QuickbaseClient[K]
                    >;
                  }
                }

                if (useTempTokens && !token) {
                  const dbid = extractDbid(
                    params,
                    `No dbid found in params for ${methodName} to fetch temp token`
                  );
                  if (debug)
                    console.log(`Cache state before fetch for ${dbid}:`, tokenCache.dump());
                  const cachedToken = tokenCache.get(dbid);
                  if (cachedToken) {
                    token = cachedToken;
                    if (debug) console.log(`Reusing cached token for dbid: ${dbid}`, token);
                  } else {
                    if (typeof window === "undefined" && !fetchApi) {
                      throw new Error(
                        "Temporary tokens require a browser environment or a custom fetchApi with browser-like session support"
                      );
                    }
                    token = await fetchTempToken(dbid);
                    // Return immediately for getTempTokenDBID after fetching
                    if (methodName === "getTempTokenDBID") {
                      return { temporaryAuthorization: token } as ReturnType<
                        QuickbaseClient[K]
                      >;
                    }
                  }
                  initOverrides.headers = {
                    ...headers,
                    Authorization: `QB-TEMP-TOKEN ${token}`,
                  };
                }

                if (debug) console.log(`Invoking ${methodName} with params:`, params);
                if (debug)
                  console.log(`Calling method with args:`, [params, initOverrides]);
                const args: [any, RequestInit | undefined] =
                  methodInfo.paramMap.length === 1 &&
                  methodInfo.paramMap[0] === "requestParameters"
                    ? [params, initOverrides]
                    : [params, initOverrides];

                try {
                  const response = await methodInfo.method(...args);
                  if (debug) console.log(`Response from ${methodName}:`, response);
                  return response;
                } catch (error) {
                  if (
                    error instanceof ResponseError &&
                    error.response.status === 401 &&
                    retryCount < 1
                  ) {
                    if (debug)
                      console.log(
                        `Authorization error for ${methodName}, refreshing token:`,
                        error.message
                      );
                    const dbid = extractDbid(
                      params,
                      `No dbid to refresh token after authorization error`
                    );
                    token = await fetchTempToken(dbid);
                    initOverrides.headers = {
                      ...headers,
                      Authorization: `QB-TEMP-TOKEN ${token}`,
                    };
                    if (debug) console.log(`Retrying ${methodName} with new token`);
                    return invokeMethod(methodName, params, retryCount + 1); // Retry once
                  }
                  if (error instanceof ResponseError) {
                    let errorMessage = error.message;
                    try {
                      const errorBody = await error.response.json();
                      console.log(`Error response body for ${methodName}:`, errorBody);
                      errorMessage = errorBody.message || errorMessage;
                    } catch (e) {
                      console.log(
                        `Failed to parse error response for ${methodName}:`,
                        error.message
                      );
                    }
                    throw new Error(
                      `API Error: ${errorMessage} (Status: ${error.response.status})`
                    );
                  }
                  throw error;
                }
              };

              return new Proxy<QuickbaseClient>({} as QuickbaseClient, {
                get: (_, prop: string): ((params: any) => Promise<any>) | undefined => {
                  if (prop in methodMap) {
                    const methodName = prop as keyof QuickbaseClient;
                    return (params: Parameters<QuickbaseClient[typeof methodName]>[0]) => {
                      if (debug) console.log(`Proxy called ${methodName} with:`, params);
                      return invokeMethod(methodName, params);
                    };
                  }
                  console.warn(`Method ${prop} not found in methodMap`);
                  return undefined;
                },
              });
            }
        - name: specs
          type: directory
          children:
            - name: QuickBase_RESTful_API_2025-03-04T06_22_39.725Z.json
              type: file
        - name: tokenCache.ts
          type: file
          contents: |
            interface CachedToken {
              token: string;
              expiresAt: number; // Timestamp in milliseconds
            }

            export class TokenCache {
              private cache: Map<string, CachedToken>;
              private readonly lifespan: number; // Token lifespan in milliseconds

              constructor(lifespan: number = 4 * 60 * 1000 + 50 * 1000) {
                // Default 4:50
                this.cache = new Map<string, CachedToken>();
                this.lifespan = lifespan;
              }

              get(dbid: string): string | undefined {
                const entry = this.cache.get(dbid);
                const now = Date.now();
                if (entry && entry.expiresAt > now) {
                  return entry.token;
                }
                return undefined; // Expired or not found
              }

              // New method to get full entry
              getEntry(dbid: string): CachedToken | undefined {
                const entry = this.cache.get(dbid);
                const now = Date.now();
                if (entry && entry.expiresAt > now) {
                  return entry;
                }
                return undefined; // Expired or not found
              }

              set(dbid: string, token: string): void {
                const now = Date.now();
                this.cache.set(dbid, {
                  token,
                  expiresAt: now + this.lifespan,
                });
              }

              dump(): [string, CachedToken][] {
                return Array.from(this.cache.entries());
              }

              // New method to clear the cache
              clear(): void {
                this.cache.clear();
              }
            }
        - name: utils.ts
          type: file
    - name: test-artifacts
      type: directory
      children:
        - name: .last-run.json
          type: file
        - name: test-results.json
          type: file
    - name: test-results.json
      type: file
    - name: tests
      type: directory
      children:
        - name: playwright
          type: directory
          children:
            - name: qb
              type: directory
              children:
                - name: auth
                  type: directory
                  children:
                    - name: cacheSwitching.test.ts
                      type: file
                    - name: fetchTempToken401.test.ts
                      type: file
                    - name: getAppWithUserToken.test.ts
                      type: file
                    - name: getTempToken.test.ts
                      type: file
                    - name: tokenPrefetch.test.ts
                      type: file
                    - name: tokenRenewal.test.ts
                      type: file
        - name: setup.ts
          type: file
        - name: vitest
          type: directory
          children:
            - name: qb
              type: directory
              children:
                - name: apps
                  type: directory
                  children:
                    - name: getApp.test.ts
                      type: file
                - name: fields
                  type: directory
                  children:
                    - name: getFields.test.ts
                      type: file
                - name: index.ts
                  type: file
                - name: tables
                  type: directory
                  children:
                    - name: getAppTables.test.ts
                      type: file
            - name: unit
              type: directory
              children:
                - name: apps
                  type: directory
                  children:
                    - name: getApp.test.ts
                      type: file
                - name: auth
                  type: directory
                  children:
                    - name: fetchTempToken401.test.ts
                      type: file
                    - name: getTempToken.test.ts
                      type: file
                    - name: retryOn401.test.ts
                      type: file
                    - name: two401s.test.ts
                      type: file
                - name: fields
                  type: directory
                  children:
                    - name: getFields.test.ts
                      type: file
                - name: index.ts
                  type: file
                - name: tables
                  type: directory
                  children:
                    - name: getAppTables.test.ts
                      type: file
    - name: text.txt
      type: file
    - name: tsconfig.json
      type: file
      contents: |-
        {
          "compilerOptions": {
            "target": "ESNext",
            "module": "ESNext", // Changed from NodeNext to match bundler
            "moduleResolution": "bundler",
            "strict": true,
            "lib": ["ESNext", "DOM"],
            "types": ["node", "playwright/test"],
            "esModuleInterop": true,
            "resolveJsonModule": true,
            "allowImportingTsExtensions": true,
            "noEmit": true,
            "outDir": "dist",
            "rootDir": ".", // Includes src/ and tests/
            "declaration": true,
            "sourceMap": true,
            "baseUrl": ".", // Added to set the root for path resolution
            "paths": {
              "@/*": ["./*"] // Maps '@/*' to root directory
            }
          },
          "include": ["src/**/*", "tests/**/*"],
          "exclude": ["node_modules", "dist", "src/generated-old"],
          "ts-node": {
            "esm": true,
            "transpileOnly": true
          }
        }
    - name: vitest.config.ts
      type: file
      contents: |
        import { defineConfig } from "vitest/config";
        import path from "path";

        export default defineConfig({
          test: {
            environment: "jsdom",
            include: ["tests/vitest/**/**/*.test.ts"],
            setupFiles: ["tests/setup.ts"],
            pool: "forks",
            poolOptions: {
              forks: {
                singleFork: true, // Run tests sequentially
              },
            },
          },
          resolve: {
            alias: {
              "@": path.resolve(__dirname, "./"),
            },
          },
        });

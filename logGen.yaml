project: quickbase-js
date: 3/9/2025
root: /home/drew/Projects/quickbase-js
goals:
  - Implement a QuickBase API client in TypeScript.
  - Generate client methods from the QuickBase RESTful API spec.
  - Provide a simple and intuitive interface for interacting with QuickBase.
  - Support both Node.js and browser environments.
  - 'Use case: JS frameworks like React, Vue, and Angular hosted in QuickBase code pages.'
  - Node.js is supported using User Tokens
  - Use OpenAPI to generate the TypeScript types and methods.
  - Use the latest ES6+ features and TypeScript features.
  - '#'
  - No manual updating methods when the QuickBase API changes.
  - The proxy magic dynamically maps generated methods.
  - No manual endpoint definitions—endpoints come from the generated apis (e.g., AppsApi.getApp).
  - '#'
  - 'Per-Instance Store: tokenCache is defined per quickbaseClient call, so each instance has its own isolated TokenCache.'
  - 'No Singleton: No shared state—tokens are fetched and cached within the current instance.'
tree:
  name: .
  type: directory
  children:
    - name: .env
      type: file
    - name: .gitignore
      type: file
    - name: LICENSE
      type: file
    - name: README.md
      type: file
    - name: build.js
      type: file
    - name: dist
      type: directory
      children:
        - name: code-generation
          type: directory
          children:
            - name: generate-unified-interface.js
              type: file
        - name: quickbaseClient.d.ts
          type: file
        - name: quickbaseClient.js
          type: file
        - name: quickbaseClient.js.map
          type: file
        - name: utils.js
          type: file
    - name: examples
      type: directory
      children:
        - name: react.js
          type: file
        - name: vanillajs.html
          type: file
    - name: logGen.yaml
      type: file
    - name: openapitools.json
      type: file
    - name: package-lock.json
      type: file
    - name: package.json
      type: file
      contents: |
        {
          "name": "quickbase-js",
          "version": "1.0.0",
          "description": "QuickBase JavaScript client for frameworks and vanilla JS",
          "module": "dist/quickbaseClient.js",
          "types": "dist/quickbaseClient.d.ts",
          "type": "module",
          "exports": {
            ".": {
              "import": "./dist/quickbaseClient.js",
              "types": "./dist/quickbaseClient.d.ts"
            }
          },
          "scripts": {
            "fix-spec": "node --loader ts-node/esm src/code-generation/fix-spec-main.ts",
            "fix-spec-old": "node --loader ts-node/esm src/code-generation/fix-spec.ts",
            "regenerate": "node --loader ts-node/esm src/code-generation/regenerate-client.ts",
            "generate-unified": "node --loader ts-node/esm src/code-generation/generate-unified-interface.ts",
            "log-gen": "node --loader ts-node/esm src/log-gen.ts",
            "build": "rollup -c",
            "build:prod": "rm -rf dist/* && NODE_ENV=production rollup -c",
            "test": "vitest run tests/vitest/**/**/*.test.ts",
            "test:qb:browser:all": "playwright test tests/playwright/qb --config playwright.config.ts",
            "test:vitest:qb": "vitest run tests/vitest/qb/**/*.test.ts",
            "test:vitest:qb:apps": "vitest run tests/vitest/qb/apps/**/*.test.ts",
            "test:vitest:qb:fields": "vitest run tests/vitest/qb/fields/**/*.test.ts",
            "test:vitest:qb:tables": "vitest run tests/vitest/qb/tables/**/*.test.ts",
            "test:pw:qb:auth": "playwright test tests/playwright/qb/auth",
            "test::pw:qb:auth:temptoken": "playwright test tests/playwright/qb/auth/getTempToken.test.ts",
            "test:pw:qb:auth:renewal": "playwright test tests/playwright/qb/auth/tokenRenewal.test.ts",
            "test:pw:qb:auth:cache": "playwright test tests/playwright/qb/auth/cacheSwitching.test.ts",
            "test:pw:qb:auth:invalidation": "playwright test tests/playwright/qb/auth/tokenInvalidation.test.ts",
            "test:pw:qb:auth:prefetch": "playwright test tests/playwright/qb/auth/tokenPrefetch.test.ts",
            "test:pw:qb:auth:debug": "playwright test tests/playwright/qb/auth --headed --debug",
            "test:pw:qb:auth:temp:debug": "playwright test tests/playwright/qb/auth/getTempToken.test.ts --headed --debug",
            "test:pw:qb:auth:renewal:debug": "playwright test tests/playwright/qb/auth/tokenRenewal.test.ts --headed --debug --config=playwright.config.ts",
            "test:pw:qb:auth:cache:debug": "playwright test tests/playwright/qb/auth/cacheSwitching.test.ts --headed --debug",
            "test:pw:qb:parallel": "playwright test tests/playwright/qb --workers 50%"
          },
          "dependencies": {
            "typescript": "^5.8.2"
          },
          "devDependencies": {
            "@openapitools/openapi-generator-cli": "^2.17.0",
            "@playwright/test": "^1.51.0",
            "@rollup/plugin-commonjs": "^28.0.3",
            "@rollup/plugin-node-resolve": "^16.0.0",
            "@rollup/plugin-terser": "^0.4.4",
            "@rollup/plugin-typescript": "^12.1.2",
            "@types/node": "^20.17.24",
            "dotenv": "^16.4.7",
            "glob": "^11.0.1",
            "js-yaml": "^4.1.0",
            "jsdom": "^24.1.3",
            "node-fetch": "^3.3.2",
            "openapi-types": "^12.1.3",
            "rollup": "^4.34.9",
            "rollup-plugin-dts": "^6.1.1",
            "ts-morph": "^23.0.0",
            "ts-node": "^10.9.2",
            "tslib": "^2.8.1",
            "vitest": "^1.6.0"
          }
        }
    - name: playwright.config.ts
      type: file
    - name: rollup.config.js
      type: file
      contents: |
        // /home/drew/Projects/quickbase-js/playwright.config.ts
        import { defineConfig, devices } from "@playwright/test";

        console.log("Loading Playwright config with timeout: 310000ms, workers: 1");

        export default defineConfig({
          fullyParallel: false, // Disable parallelism for now
          workers: 1,
          testDir: "./tests/playwright",
          timeout: 310000, // 5 minutes 10 seconds
          retries: 1, // Reduced from 2
          reporter: [["list"], ["json", { outputFile: "test-results.json" }]],
          use: {
            baseURL: "https://api.quickbase.com",
            headless: true,
            viewport: { width: 1280, height: 720 },
            actionTimeout: 10000,
          },
          projects: [
            {
              name: "chromium",
              use: { ...devices["Desktop Chrome"] },
            },
          ],
        });
    - name: src
      type: directory
      children:
        - name: code-generation
          type: directory
          children:
            - name: fix-spec-definitions.ts
              type: file
            - name: fix-spec-main.ts
              type: file
            - name: fix-spec-paths.ts
              type: file
            - name: generate-unified-interface.ts
              type: file
            - name: output
              type: directory
              children:
                - name: quickbase-fixed.json
                  type: file
            - name: regenerate-client.ts
              type: file
        - name: generated
          type: directory
          children:
            - name: .openapi-generator
              type: directory
              children:
                - name: FILES
                  type: file
                - name: VERSION
                  type: file
            - name: .openapi-generator-ignore
              type: file
            - name: apis
              type: directory
              children:
                - name: AppsApi.ts
                  type: file
                - name: AuditApi.ts
                  type: file
                - name: AuthApi.ts
                  type: file
                - name: DocumentTemplatesApi.ts
                  type: file
                - name: FieldsApi.ts
                  type: file
                - name: FilesApi.ts
                  type: file
                - name: FormulasApi.ts
                  type: file
                - name: PlatformAnalyticsApi.ts
                  type: file
                - name: RecordsApi.ts
                  type: file
                - name: ReportsApi.ts
                  type: file
                - name: SolutionsApi.ts
                  type: file
                - name: TablesApi.ts
                  type: file
                - name: UserTokenApi.ts
                  type: file
                - name: UsersApi.ts
                  type: file
                - name: index.ts
                  type: file
            - name: index.ts
              type: file
            - name: models
              type: directory
              children:
                - name: AddMembersToGroup200Response.ts
                  type: file
                - name: AddSubgroupsToGroup200Response.ts
                  type: file
                - name: App.ts
                  type: file
                - name: AppMemoryInfo.ts
                  type: file
                - name: AppSecurityProperties.ts
                  type: file
                - name: Audit200Response.ts
                  type: file
                - name: Audit202Response.ts
                  type: file
                - name: AuditRequest.ts
                  type: file
                - name: CloneUserToken200Response.ts
                  type: file
                - name: CloneUserTokenRequest.ts
                  type: file
                - name: CopyApp200Response.ts
                  type: file
                - name: CopyAppRequest.ts
                  type: file
                - name: CreateApp200Response.ts
                  type: file
                - name: CreateAppRequest.ts
                  type: file
                - name: CreateRelationship200Response.ts
                  type: file
                - name: CreateRelationshipRequest.ts
                  type: file
                - name: DeactivateUserToken200Response.ts
                  type: file
                - name: DeleteFile200Response.ts
                  type: file
                - name: DeleteRecords200Response.ts
                  type: file
                - name: DeleteRecordsRequest.ts
                  type: file
                - name: DeleteRelationship200Response.ts
                  type: file
                - name: DeleteTable200Response.ts
                  type: file
                - name: DenyUsers200Response.ts
                  type: file
                - name: ExchangeSsoToken200Response.ts
                  type: file
                - name: ExchangeSsoTokenRequest.ts
                  type: file
                - name: Field.ts
                  type: file
                - name: FieldPermissionsInner.ts
                  type: file
                - name: FieldProperties.ts
                  type: file
                - name: GenerateDocument200Response.ts
                  type: file
                - name: GetField200Response.ts
                  type: file
                - name: GetRelationships200Response.ts
                  type: file
                - name: GetReport200Response.ts
                  type: file
                - name: GetTable200Response.ts
                  type: file
                - name: GetTempTokenDBID200Response.ts
                  type: file
                - name: GetUsers200Response.ts
                  type: file
                - name: GetUsersRequest.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200Response.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseMetadata.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseResultsInner.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseTotals.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseWhereInner.ts
                  type: file
                - name: PlatformAnalyticEventSummariesRequest.ts
                  type: file
                - name: PlatformAnalyticEventSummariesRequestWhereInner.ts
                  type: file
                - name: PlatformAnalyticReads200Response.ts
                  type: file
                - name: Record.ts
                  type: file
                - name: RemoveMembersFromGroup200Response.ts
                  type: file
                - name: RemoveSubgroupsFromGroup200Response.ts
                  type: file
                - name: ReportRunResponse.ts
                  type: file
                - name: RunFormula200Response.ts
                  type: file
                - name: RunFormulaRequest.ts
                  type: file
                - name: Table.ts
                  type: file
                - name: TransferUserToken200Response.ts
                  type: file
                - name: TransferUserTokenRequest.ts
                  type: file
                - name: UndenyUsers200Response.ts
                  type: file
                - name: UpdateFieldRequest.ts
                  type: file
                - name: UpdateRelationshipRequest.ts
                  type: file
                - name: UpdateTableRequest.ts
                  type: file
                - name: Upsert200Response.ts
                  type: file
                - name: Upsert207Response.ts
                  type: file
                - name: Upsert400Response.ts
                  type: file
                - name: UpsertRequest.ts
                  type: file
                - name: index.ts
                  type: file
            - name: runtime.ts
              type: file
        - name: generated-old
          type: directory
          children:
            - name: .openapi-generator
              type: directory
              children:
                - name: FILES
                  type: file
                - name: VERSION
                  type: file
            - name: .openapi-generator-ignore
              type: file
            - name: apis
              type: directory
              children:
                - name: AppsApi.ts
                  type: file
                - name: AuditApi.ts
                  type: file
                - name: AuthApi.ts
                  type: file
                - name: DocumentTemplatesApi.ts
                  type: file
                - name: FieldsApi.ts
                  type: file
                - name: FilesApi.ts
                  type: file
                - name: FormulasApi.ts
                  type: file
                - name: PlatformAnalyticsApi.ts
                  type: file
                - name: RecordsApi.ts
                  type: file
                - name: ReportsApi.ts
                  type: file
                - name: SolutionsApi.ts
                  type: file
                - name: TablesApi.ts
                  type: file
                - name: UserTokenApi.ts
                  type: file
                - name: UsersApi.ts
                  type: file
                - name: index.ts
                  type: file
            - name: index.ts
              type: file
            - name: models
              type: directory
              children:
                - name: AddMembersToGroup200Response.ts
                  type: file
                - name: AddSubgroupsToGroup200Response.ts
                  type: file
                - name: App.ts
                  type: file
                - name: AppMemoryInfo.ts
                  type: file
                - name: AppSecurityProperties.ts
                  type: file
                - name: Audit200Response.ts
                  type: file
                - name: Audit202Response.ts
                  type: file
                - name: AuditRequest.ts
                  type: file
                - name: CloneUserToken200Response.ts
                  type: file
                - name: CloneUserTokenRequest.ts
                  type: file
                - name: CopyApp200Response.ts
                  type: file
                - name: CopyAppRequest.ts
                  type: file
                - name: CreateApp200Response.ts
                  type: file
                - name: CreateAppRequest.ts
                  type: file
                - name: CreateField200Response.ts
                  type: file
                - name: CreateRelationship200Response.ts
                  type: file
                - name: CreateRelationshipRequest.ts
                  type: file
                - name: DeactivateUserToken200Response.ts
                  type: file
                - name: DeleteApp200Response.ts
                  type: file
                - name: DeleteAppRequest.ts
                  type: file
                - name: DeleteFields200Response.ts
                  type: file
                - name: DeleteFile200Response.ts
                  type: file
                - name: DeleteRelationship200Response.ts
                  type: file
                - name: DenyUsers200Response.ts
                  type: file
                - name: ExchangeSsoToken200Response.ts
                  type: file
                - name: ExchangeSsoTokenRequest.ts
                  type: file
                - name: Field.ts
                  type: file
                - name: FieldPermissionsInner.ts
                  type: file
                - name: FieldProperties.ts
                  type: file
                - name: GenerateDocument200Response.ts
                  type: file
                - name: GetField200Response.ts
                  type: file
                - name: GetRelationships200Response.ts
                  type: file
                - name: GetReport200Response.ts
                  type: file
                - name: GetTempTokenDBID200Response.ts
                  type: file
                - name: GetUsers200Response.ts
                  type: file
                - name: GetUsersRequest.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200Response.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseMetadata.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseResultsInner.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseTotals.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseWhereInner.ts
                  type: file
                - name: PlatformAnalyticEventSummariesRequest.ts
                  type: file
                - name: PlatformAnalyticEventSummariesRequestWhereInner.ts
                  type: file
                - name: PlatformAnalyticReads200Response.ts
                  type: file
                - name: RemoveMembersFromGroup200Response.ts
                  type: file
                - name: RemoveSubgroupsFromGroup200Response.ts
                  type: file
                - name: RunFormula200Response.ts
                  type: file
                - name: RunFormulaRequest.ts
                  type: file
                - name: RunQuery200Response.ts
                  type: file
                - name: RunQueryRequest.ts
                  type: file
                - name: RunReport200Response.ts
                  type: file
                - name: Table.ts
                  type: file
                - name: TransferUserToken200Response.ts
                  type: file
                - name: TransferUserTokenRequest.ts
                  type: file
                - name: UndenyUsers200Response.ts
                  type: file
                - name: UpdateApp200Response.ts
                  type: file
                - name: UpdateAppRequest.ts
                  type: file
                - name: UpdateFieldRequest.ts
                  type: file
                - name: UpdateRelationshipRequest.ts
                  type: file
                - name: Upsert200Response.ts
                  type: file
                - name: index.ts
                  type: file
            - name: runtime.ts
              type: file
        - name: generated-unified
          type: directory
          children:
            - name: QuickbaseClient.ts
              type: file
        - name: index.ts
          type: file
        - name: log-gen.ts
          type: file
        - name: openapi-jars
          type: directory
          children:
            - name: openapi-generator-cli-7.12.0.jar
              type: file
        - name: quickbaseClient.ts
          type: file
          contents: |
            // src/quickbaseClient.ts
            import { QuickbaseClient } from "./generated-unified/QuickbaseClient.ts";
            import {
              Configuration,
              HTTPHeaders,
              ResponseError,
            } from "./generated/runtime.ts";
            import * as apis from "./generated/apis/index.ts";
            import { simplifyName } from "./utils.ts";
            import { TokenCache } from "./tokenCache.ts";

            export interface QuickbaseConfig {
              realm: string;
              userToken?: string;
              tempToken?: string;
              useTempTokens?: boolean;
              debug?: boolean;
              fetchApi?: typeof fetch;
            }

            interface TempTokenParams {
              appId?: string;
              tableId?: string;
              dbid?: string;
            }

            type ApiMethod<K extends keyof QuickbaseClient> = (
              requestParameters: Parameters<QuickbaseClient[K]>[0],
              initOverrides?: RequestInit
            ) => Promise<ReturnType<QuickbaseClient[K]>>;

            interface MethodInfo<K extends keyof QuickbaseClient> {
              api: any;
              method: ApiMethod<K>;
              paramMap: string[];
            }

            type MethodMap = { [K in keyof QuickbaseClient]: MethodInfo<K> };

            const getParamNames = (fn: (...args: any[]) => any): string[] =>
              fn
                .toString()
                .slice(fn.toString().indexOf("(") + 1, fn.toString().indexOf(")"))
                .split(",")
                .map((p) => p.trim().split("=")[0].trim())
                .filter((p) => p && !p.match(/^\{/) && p !== "options");

            export function quickbaseClient(config: QuickbaseConfig): QuickbaseClient {
              const {
                realm,
                userToken,
                tempToken: initialTempToken,
                useTempTokens,
                fetchApi,
                debug,
              } = config;
              const baseUrl = `https://api.quickbase.com/v1`;

              const tokenCache = new TokenCache();

              const headers: HTTPHeaders = {
                "QB-Realm-Hostname": `${realm}.quickbase.com`,
                "Content-Type": "application/json",
              };

              if (initialTempToken) {
                headers["Authorization"] = `QB-TEMP-TOKEN ${initialTempToken}`;
              } else if (userToken) {
                headers["Authorization"] = `QB-USER-TOKEN ${userToken}`;
              }

              const defaultFetch =
                typeof window !== "undefined" ? window.fetch.bind(window) : undefined;
              const configuration = new Configuration({
                basePath: baseUrl,
                headers: { ...headers },
                fetchApi: fetchApi || defaultFetch,
                credentials: "omit",
              });

              if (!configuration.fetchApi && typeof window === "undefined") {
                throw new Error(
                  "fetchApi must be provided in non-browser environments (e.g., Node.js)"
                );
              }

              const apiInstances = Object.fromEntries(
                Object.entries(apis)
                  .filter(([name]) => name.endsWith("Api"))
                  .map(([name, ApiClass]) => [
                    name.replace("Api", "").toLowerCase(),
                    new ApiClass(configuration),
                  ])
              );

              const methodMap = buildMethodMap();

              function buildMethodMap(): MethodMap {
                const methodMap: Partial<MethodMap> = {};
                const isValidMethod = (name: string) =>
                  !name.startsWith("_") &&
                  name !== "constructor" &&
                  !["Middleware", "Pre", "Post", "Raw"].some((s) => name.includes(s));

                for (const [apiName, api] of Object.entries(apiInstances)) {
                  Object.getOwnPropertyNames(Object.getPrototypeOf(api))
                    .filter(
                      (name) =>
                        isValidMethod(name) &&
                        typeof api[name as keyof typeof api] === "function"
                    )
                    .forEach((rawMethodName) => {
                      const simplifiedName = simplifyName(
                        rawMethodName
                      ) as keyof QuickbaseClient;
                      const method = api[rawMethodName as keyof typeof api];
                      const boundMethod = method.bind(api) as unknown;
                      if (typeof boundMethod === "function" && boundMethod.length <= 2) {
                        methodMap[simplifiedName] = {
                          api,
                          method: boundMethod as ApiMethod<typeof simplifiedName>,
                          paramMap: getParamNames(method),
                        };
                        if (debug) {
                          console.log(`Mapped ${rawMethodName} to ${simplifiedName}`);
                        }
                      }
                    });
                }
                return methodMap as MethodMap;
              }

              const fetchTempToken = async (dbid: string): Promise<string> => {
                const tokenClient = quickbaseClient({
                  realm,
                  fetchApi,
                  debug,
                  useTempTokens: false,
                });
                const tokenResult = await tokenClient.getTempTokenDBID({ dbid });
                const token = tokenResult.temporaryAuthorization;
                tokenCache.set(dbid, token);
                if (debug) {
                  console.log(
                    `Fetched and cached new token for dbid: ${dbid}`,
                    token,
                    `Expires at: ${new Date(
                      Date.now() + (4 * 60 + 50) * 1000
                    ).toISOString()}`
                  );
                }
                return token;
              };

              const invokeMethod = async <K extends keyof QuickbaseClient>(
                methodName: K,
                params: Parameters<QuickbaseClient[K]>[0] & Partial<TempTokenParams>,
                retryCount: number = 0
              ): Promise<ReturnType<QuickbaseClient[K]>> => {
                const methodInfo = methodMap[methodName];
                if (!methodInfo) {
                  console.error(`Method ${methodName} not found in methodMap`, methodMap);
                  throw new Error(`Method ${methodName} not found`);
                }

                let token = initialTempToken || userToken;
                let initOverrides: RequestInit = {};

                if (useTempTokens && !token) {
                  const dbid = params.appId || params.tableId || params.dbid;
                  if (!dbid) {
                    throw new Error(
                      `No dbid found in params for ${methodName} to fetch temp token`
                    );
                  }
                  if (debug) {
                    console.log(`Cache state before fetch for ${dbid}:`, tokenCache.dump());
                  }
                  const cachedToken = tokenCache.get(dbid);
                  if (cachedToken) {
                    token = cachedToken;
                    if (debug) {
                      console.log(`Reusing cached token for dbid: ${dbid}`, token);
                    }
                  } else {
                    if (typeof window === "undefined" && !fetchApi) {
                      throw new Error(
                        "Temporary tokens require a browser environment or a custom fetchApi with browser-like session support"
                      );
                    }
                    token = await fetchTempToken(dbid);
                    // Early return for getTempTokenDBID to avoid redundant fetch
                    if (methodName === "getTempTokenDBID") {
                      return { temporaryAuthorization: token } as ReturnType<
                        QuickbaseClient[K]
                      >;
                    }
                  }
                  initOverrides.headers = {
                    ...headers,
                    Authorization: `QB-TEMP-TOKEN ${token}`,
                  };
                }

                if (debug) {
                  console.log(`Invoking ${methodName} with params:`, params);
                  console.log(`Calling method with args:`, [params, initOverrides]);
                }
                const args: [any, RequestInit | undefined] =
                  methodInfo.paramMap.length === 1 &&
                  methodInfo.paramMap[0] === "requestParameters"
                    ? [params, initOverrides]
                    : [params, initOverrides];

                try {
                  const response = await methodInfo.method(...args);
                  if (debug) {
                    console.log(`Response from ${methodName}:`, response);
                  }
                  return response;
                } catch (error) {
                  if (
                    error instanceof ResponseError &&
                    error.response.status === 401 &&
                    retryCount < 1
                  ) {
                    if (debug) {
                      console.log(
                        `Authorization error for ${methodName}, refreshing token:`,
                        error.message
                      );
                    }
                    const dbid = params.appId || params.tableId || params.dbid;
                    if (!dbid) {
                      throw new Error(`No dbid to refresh token after authorization error`);
                    }
                    token = await fetchTempToken(dbid);
                    initOverrides.headers = {
                      ...headers,
                      Authorization: `QB-TEMP-TOKEN ${token}`,
                    };
                    if (debug) {
                      console.log(`Retrying ${methodName} with new token`);
                    }
                    return invokeMethod(methodName, params, retryCount + 1); // Retry once
                  }
                  if (error instanceof ResponseError) {
                    let errorMessage = error.message;
                    try {
                      const errorBody = await error.response.json();
                      console.log(`Error response body for ${methodName}:`, errorBody);
                      errorMessage = errorBody.message || errorMessage;
                    } catch (e) {
                      console.log(
                        `Failed to parse error response for ${methodName}:`,
                        error.message
                      );
                    }
                    throw new Error(
                      `API Error: ${errorMessage} (Status: ${error.response.status})`
                    );
                  }
                  throw error;
                }
              };

              return new Proxy<QuickbaseClient>({} as QuickbaseClient, {
                get: (_, prop: string): ((params: any) => Promise<any>) | undefined => {
                  if (prop in methodMap) {
                    const methodName = prop as keyof QuickbaseClient;
                    return (params: Parameters<QuickbaseClient[typeof methodName]>[0]) => {
                      if (debug) {
                        console.log(`Proxy called ${methodName} with:`, params);
                      }
                      return invokeMethod(methodName, params);
                    };
                  }
                  console.warn(`Method ${prop} not found in methodMap`);
                  return undefined;
                },
              });
            }
        - name: quickbaseClient_maybe.ts.bak
          type: file
        - name: specs
          type: directory
          children:
            - name: QuickBase_RESTful_API_2025-03-04T06_22_39.725Z.json
              type: file
        - name: tokenCache.ts
          type: file
          contents: |
            interface CachedToken {
              token: string;
              expiresAt: number; // Timestamp in milliseconds
            }

            export class TokenCache {
              private cache: Map<string, CachedToken>;
              private readonly lifespan: number; // Token lifespan in milliseconds

              constructor(lifespan: number = 4 * 60 * 1000 + 50 * 1000) {
                // Default 4:50
                this.cache = new Map<string, CachedToken>();
                this.lifespan = lifespan;
              }

              get(dbid: string): string | undefined {
                const entry = this.cache.get(dbid);
                const now = Date.now();
                if (entry && entry.expiresAt > now) {
                  return entry.token;
                }
                return undefined; // Expired or not found
              }

              // New method to get full entry
              getEntry(dbid: string): CachedToken | undefined {
                const entry = this.cache.get(dbid);
                const now = Date.now();
                if (entry && entry.expiresAt > now) {
                  return entry;
                }
                return undefined; // Expired or not found
              }

              set(dbid: string, token: string): void {
                const now = Date.now();
                this.cache.set(dbid, {
                  token,
                  expiresAt: now + this.lifespan,
                });
              }

              dump(): [string, CachedToken][] {
                return Array.from(this.cache.entries());
              }
            }
        - name: utils.ts
          type: file
    - name: test-artifacts
      type: directory
      children:
        - name: .last-run.json
          type: file
        - name: test-results.json
          type: file
    - name: test-results.json
      type: file
    - name: tests
      type: directory
      children:
        - name: playwright
          type: directory
          children:
            - name: qb
              type: directory
              children:
                - name: auth
                  type: directory
                  children:
                    - name: cacheSwitching.test.ts
                      type: file
                      contents: |
                        // tests/playwright/qb/auth/cacheSwitching.test.ts
                        import { test, expect } from "@playwright/test";
                        import { quickbaseClient } from "../../../../src/quickbaseClient.ts";
                        import fetch from "node-fetch";
                        import dotenv from "dotenv";

                        dotenv.config();

                        const loginToQuickbase = async (
                          page: import("@playwright/test").Page,
                          quickbaseUrl: string,
                          username: string,
                          password: string
                        ): Promise<boolean> => {
                          console.log("Logging in to QuickBase");
                          let loginSuccess = false;
                          const maxLoginAttempts = 3;
                          let loginAttempt = 0;

                          while (!loginSuccess && loginAttempt < maxLoginAttempts) {
                            try {
                              loginAttempt++;
                              if (loginAttempt > 1) console.log(`Login attempt ${loginAttempt}`);

                              console.log("Navigating to login page");
                              await page.goto(quickbaseUrl, { timeout: 30000 });
                              console.log("Waiting for loginid selector");
                              await page.waitForSelector("input[name='loginid']", { timeout: 30000 });
                              await page.fill("input[name='loginid']", username);
                              await page.fill("input[name='password']", password);
                              console.log("Clicking signin");
                              await page.click("#signin");
                              console.log("Waiting for navigation");
                              await page.waitForURL(`https://*.quickbase.com/**`, {
                                waitUntil: "networkidle",
                                timeout: 30000,
                              });

                              const loginError = await page.$(".login-error");
                              if (loginError) {
                                throw new Error("Login failed. Please check your credentials.");
                              }

                              console.log("Signed In to QuickBase.");
                              loginSuccess = true;
                            } catch (error) {
                              console.error(
                                `Login attempt ${loginAttempt} failed: ${(error as Error).message}`
                              );
                              if (loginAttempt >= maxLoginAttempts) {
                                console.error("Max login attempts reached. Exiting.");
                                await page.context().browser()!.close();
                                return false;
                              }
                              await new Promise((resolve) => setTimeout(resolve, 5000));
                            }
                          }
                          return loginSuccess;
                        };

                        test.describe("QuickbaseClient Integration - Cache Switching with Temp Tokens", () => {
                          // Removed test.use({ context: ... })

                          test("caches and switches tokens for different DBIDs with getApp → getFields → getApp sequence", async ({
                            page,
                          }) => {
                            console.log("Starting cacheSwitching test");
                            const realm = process.env.QB_REALM;
                            const appId = process.env.QB_APP_ID;
                            const tableId = process.env.QB_TABLE_ID;
                            const username = process.env.QB_USERNAME;
                            const password = process.env.QB_PASSWORD;

                            if (!realm) throw new Error("QB_REALM is not defined in .env");
                            if (!appId) throw new Error("QB_APP_ID is not defined in .env");
                            if (!tableId) throw new Error("QB_TABLE_ID is not defined in .env");
                            if (!username) throw new Error("QB_USERNAME is not defined in .env");
                            if (!password) throw new Error("QB_PASSWORD is not defined in .env");

                            const quickbaseUrl = `https://${realm}.quickbase.com/db/main?a=SignIn`;
                            const loginSuccess = await loginToQuickbase(
                              page,
                              quickbaseUrl,
                              username,
                              password
                            );
                            if (!loginSuccess) {
                              throw new Error("Failed to log in to QuickBase after max attempts.");
                            }

                            await page.goto(`https://${realm}.quickbase.com/db/${appId}`, {
                              waitUntil: "networkidle",
                              timeout: 30000,
                            });
                            console.log("Post-login URL after app navigation:", page.url());

                            const browserFetch = async (url: string, init?: RequestInit) => {
                              const response = await page.evaluate(
                                async ([fetchUrl, fetchInit]) => {
                                  const res = await fetch(fetchUrl, {
                                    ...fetchInit,
                                    credentials: "include",
                                  });
                                  const body = await res.text();
                                  return {
                                    ok: res.ok,
                                    status: res.status,
                                    statusText: res.statusText,
                                    headers: Object.fromEntries(res.headers.entries()),
                                    body,
                                  };
                                },
                                [url, init] as [string, RequestInit]
                              );

                              console.log(`Raw response from ${url}:`, {
                                status: response.status,
                                statusText: response.statusText,
                                body: response.body,
                              });

                              const fetchResponse = new Response(response.body || null, {
                                status: response.status,
                                statusText: response.statusText,
                                headers: response.headers,
                              });

                              fetchResponse.json = async () => {
                                if (!response.body) throw new Error("Empty response body from API");
                                try {
                                  return JSON.parse(response.body);
                                } catch (e) {
                                  throw new SyntaxError(`Invalid JSON response: ${response.body}`);
                                }
                              };

                              return fetchResponse;
                            };

                            const client = quickbaseClient({
                              realm,
                              useTempTokens: true,
                              debug: true,
                              fetchApi: async (url, init) => {
                                if (url.includes("/auth/temporary/")) {
                                  return browserFetch(url, init);
                                }
                                console.log(`Fetching ${url} with init:`, init);
                                const response = await fetch(url, init as RequestInit);
                                const body = await response.text();

                                console.log(`Raw response from ${url}:`, {
                                  status: response.status,
                                  statusText: response.statusText,
                                  body,
                                });

                                const fetchResponse = new Response(body || null, {
                                  status: response.status,
                                  statusText: response.statusText,
                                  headers: Object.fromEntries(response.headers.entries()),
                                });

                                fetchResponse.json = async () => {
                                  if (!body) throw new Error("Empty response body from API");
                                  try {
                                    return JSON.parse(body);
                                  } catch (e) {
                                    throw new SyntaxError(`Invalid JSON response: ${body}`);
                                  }
                                };

                                return fetchResponse;
                              },
                            });

                            const appResult1 = await client.getApp({ appId });
                            console.log("First getApp response:", appResult1);
                            expect(appResult1.id).toBe(appId);

                            const fieldsResult = await client.getFields({ tableId });
                            console.log("getFields response:", fieldsResult);
                            expect(fieldsResult.length).toBeGreaterThan(0);

                            const appResult2 = await client.getApp({ appId });
                            console.log("Second getApp response:", appResult2);
                            expect(appResult2.id).toBe(appId);
                          });
                        });
                    - name: getAppWithUserToken.test.ts
                      type: file
                      contents: |
                        // tests/integration/auth/getAppWithUserToken.test.ts
                        import { test, expect } from "@playwright/test";
                        import { quickbaseClient } from "../../../../src/quickbaseClient.ts";
                        import dotenv from "dotenv";

                        dotenv.config();

                        const loginToQuickbase = async (
                          page: import("@playwright/test").Page,
                          quickbaseUrl: string,
                          username: string,
                          password: string
                        ): Promise<boolean> => {
                          console.log("Logging in to QuickBase");
                          let loginSuccess = false;
                          const maxLoginAttempts = 3;
                          let loginAttempt = 0;

                          while (!loginSuccess && loginAttempt < maxLoginAttempts) {
                            try {
                              loginAttempt++;
                              if (loginAttempt > 1) console.log(`Login attempt ${loginAttempt}`);

                              await page.goto(quickbaseUrl, { timeout: 60000 });
                              await page.waitForSelector("input[name='loginid']", { timeout: 60000 });
                              await page.fill("input[name='loginid']", username);
                              await page.fill("input[name='password']", password);
                              await page.click("#signin");
                              await page.waitForURL(`https://*.quickbase.com/**`, {
                                waitUntil: "networkidle",
                                timeout: 60000,
                              });

                              const loginError = await page.$(".login-error");
                              if (loginError) {
                                throw new Error("Login failed. Please check your credentials.");
                              }

                              console.log("Signed In to QuickBase.");
                              loginSuccess = true;
                            } catch (error) {
                              console.error(
                                `Login attempt ${loginAttempt} failed: ${(error as Error).message}`
                              );
                              if (loginAttempt >= maxLoginAttempts) {
                                console.error("Max login attempts reached. Exiting.");
                                await page.context().browser()!.close();
                                return false;
                              }
                              await new Promise((resolve) => setTimeout(resolve, 5000));
                            }
                          }
                          return loginSuccess;
                        };

                        test.describe("QuickbaseClient Integration - getApp with User Token", () => {
                          test("uses user token for getApp in browser", async ({ page }) => {
                            const realm = process.env.QB_REALM;
                            const appId = process.env.QB_APP_ID;
                            const username = process.env.QB_USERNAME;
                            const password = process.env.QB_PASSWORD;
                            const userToken = process.env.QB_USER_TOKEN;

                            if (!realm) throw new Error("QB_REALM is not defined in .env");
                            if (!appId) throw new Error("QB_APP_ID is not defined in .env");
                            if (!username) throw new Error("QB_USERNAME is not defined in .env");
                            if (!password) throw new Error("QB_PASSWORD is not defined in .env");
                            if (!userToken) throw new Error("QB_USER_TOKEN is not defined in .env");

                            // Login to Quickbase (optional, to mimic code page context)
                            const quickbaseUrl = `https://${realm}.quickbase.com/db/main?a=SignIn`;
                            const loginSuccess = await loginToQuickbase(
                              page,
                              quickbaseUrl,
                              username,
                              password
                            );
                            if (!loginSuccess) {
                              throw new Error("Failed to log in to QuickBase after max attempts.");
                            }

                            // Navigate to the app page to ensure session context (optional)
                            await page.goto(`https://${realm}.quickbase.com/db/${appId}`, {
                              waitUntil: "networkidle",
                              timeout: 60000,
                            });

                            const currentUrl = page.url();
                            console.log("Post-login URL after app navigation:", currentUrl);

                            // Create Quickbase client with user token
                            const client = quickbaseClient({
                              realm,
                              userToken, // Use user token instead of temp tokens
                              debug: true,
                              fetchApi: async (url, init) => {
                                console.log(`Fetching ${url} with init:`, init);
                                const response = await page.evaluate(
                                  async ([fetchUrl, fetchInit]) => {
                                    const res = await fetch(fetchUrl, {
                                      ...fetchInit,
                                      credentials: "omit", // No cookies needed with user token
                                    });
                                    const body = await res.text();
                                    return {
                                      ok: res.ok,
                                      status: res.status,
                                      statusText: res.statusText,
                                      headers: Object.fromEntries(res.headers.entries()),
                                      body,
                                    };
                                  },
                                  [url, init] as [string, RequestInit]
                                );

                                console.log(`Raw response from ${url}:`, {
                                  status: response.status,
                                  statusText: response.statusText,
                                  body: response.body,
                                });

                                const fetchResponse = new Response(response.body || null, {
                                  status: response.status,
                                  statusText: response.statusText,
                                  headers: response.headers,
                                });

                                fetchResponse.json = async () => {
                                  if (!response.body) {
                                    throw new Error("Empty response body from API");
                                  }
                                  try {
                                    return JSON.parse(response.body);
                                  } catch (e) {
                                    throw new SyntaxError(`Invalid JSON response: ${response.body}`);
                                  }
                                };

                                return fetchResponse;
                              },
                            });

                            // Call getApp directly
                            const appResult = await client.getApp({ appId });
                            console.log("App response using user token:", appResult);

                            // Validate the app response
                            expect(appResult).toHaveProperty("id", appId);
                            expect(appResult).toHaveProperty("name");
                          });
                        });
                    - name: getTempToken.test.ts
                      type: file
                      contents: |
                        // tests/integration/auth/getTempToken.test.ts
                        import { test, expect } from "@playwright/test";
                        import { quickbaseClient } from "../../../../src/quickbaseClient.ts";
                        import fetch from "node-fetch";
                        import dotenv from "dotenv";

                        dotenv.config();

                        const loginToQuickbase = async (
                          page: import("@playwright/test").Page,
                          quickbaseUrl: string,
                          username: string,
                          password: string
                        ): Promise<boolean> => {
                          console.log("Logging in to QuickBase");
                          let loginSuccess = false;
                          const maxLoginAttempts = 3;
                          let loginAttempt = 0;

                          while (!loginSuccess && loginAttempt < maxLoginAttempts) {
                            try {
                              loginAttempt++;
                              if (loginAttempt > 1) console.log(`Login attempt ${loginAttempt}`);

                              await page.goto(quickbaseUrl, { timeout: 60000 });
                              await page.waitForSelector("input[name='loginid']", { timeout: 60000 });
                              await page.fill("input[name='loginid']", username);
                              await page.fill("input[name='password']", password);
                              await page.click("#signin");
                              await page.waitForURL(`https://*.quickbase.com/**`, {
                                waitUntil: "networkidle",
                                timeout: 60000,
                              });

                              const loginError = await page.$(".login-error");
                              if (loginError) {
                                throw new Error("Login failed. Please check your credentials.");
                              }

                              console.log("Signed In to QuickBase.");
                              loginSuccess = true;
                            } catch (error) {
                              console.error(
                                `Login attempt ${loginAttempt} failed: ${(error as Error).message}`
                              );
                              if (loginAttempt >= maxLoginAttempts) {
                                console.error("Max login attempts reached. Exiting.");
                                await page.context().browser()!.close();
                                return false;
                              }
                              await new Promise((resolve) => setTimeout(resolve, 5000));
                            }
                          }
                          return loginSuccess;
                        };

                        test.describe("QuickbaseClient Integration - getApp with Temp Tokens", () => {
                          test("uses temp tokens automatically for getApp in browser", async ({
                            page,
                          }) => {
                            const realm = process.env.QB_REALM;
                            const appId = process.env.QB_APP_ID;
                            const username = process.env.QB_USERNAME;
                            const password = process.env.QB_PASSWORD;

                            if (!realm) throw new Error("QB_REALM is not defined in .env");
                            if (!appId) throw new Error("QB_APP_ID is not defined in .env");
                            if (!username) throw new Error("QB_USERNAME is not defined in .env");
                            if (!password) throw new Error("QB_PASSWORD is not defined in .env");

                            // Login to QuickBase
                            const quickbaseUrl = `https://${realm}.quickbase.com/db/main?a=SignIn`;
                            const loginSuccess = await loginToQuickbase(
                              page,
                              quickbaseUrl,
                              username,
                              password
                            );
                            if (!loginSuccess) {
                              throw new Error("Failed to log in to QuickBase after max attempts.");
                            }

                            // Navigate to the app page to ensure session context
                            await page.goto(`https://${realm}.quickbase.com/db/${appId}`, {
                              waitUntil: "networkidle",
                              timeout: 60000,
                            });
                            console.log("Post-login URL after app navigation:", page.url());

                            // Define browser fetch function
                            const browserFetch = async (url: string, init?: RequestInit) => {
                              const response = await page.evaluate(
                                async ([fetchUrl, fetchInit]) => {
                                  const res = await fetch(fetchUrl, {
                                    ...fetchInit,
                                    credentials: "include",
                                  });
                                  const body = await res.text();
                                  return {
                                    ok: res.ok,
                                    status: res.status,
                                    statusText: res.statusText,
                                    headers: Object.fromEntries(res.headers.entries()),
                                    body,
                                  };
                                },
                                [url, init] as [string, RequestInit]
                              );

                              console.log(`Raw response from ${url}:`, {
                                status: response.status,
                                statusText: response.statusText,
                                body: response.body,
                              });

                              const fetchResponse = new Response(response.body || null, {
                                status: response.status,
                                statusText: response.statusText,
                                headers: response.headers,
                              });

                              fetchResponse.json = async () => {
                                if (!response.body) throw new Error("Empty response body from API");
                                try {
                                  return JSON.parse(response.body);
                                } catch (e) {
                                  throw new SyntaxError(`Invalid JSON response: ${response.body}`);
                                }
                              };

                              return fetchResponse;
                            };

                            // Single client with conditional fetch
                            const client = quickbaseClient({
                              realm,
                              useTempTokens: true,
                              debug: true,
                              fetchApi: async (url, init) => {
                                if (url.includes("/auth/temporary/")) {
                                  return browserFetch(url, init); // Use browser context for temp token
                                }
                                console.log(`Fetching ${url} with init:`, init);
                                const response = await fetch(url, init as RequestInit); // Node-fetch for API calls
                                const body = await response.text();

                                console.log(`Raw response from ${url}:`, {
                                  status: response.status,
                                  statusText: response.statusText,
                                  body,
                                });

                                const fetchResponse = new Response(body || null, {
                                  status: response.status,
                                  statusText: response.statusText,
                                  headers: Object.fromEntries(response.headers.entries()),
                                });

                                fetchResponse.json = async () => {
                                  if (!body) throw new Error("Empty response body from API");
                                  try {
                                    return JSON.parse(body);
                                  } catch (e) {
                                    throw new SyntaxError(`Invalid JSON response: ${body}`);
                                  }
                                };

                                return fetchResponse;
                              },
                            });

                            // Call getApp directly, letting the library handle temp token logic
                            const appResult = await client.getApp({ appId });
                            console.log("App response using auto-fetched temp token:", appResult);

                            // Validate the app response
                            expect(appResult).toHaveProperty("id", appId);
                            expect(appResult).toHaveProperty("name");
                          });
                        });
                    - name: tokenInvalidation.test.ts
                      type: file
                      contents: |
                        // tests/playwright/qb/auth/tokenInvalidation.test.ts
                        import { test, expect } from "@playwright/test";
                        import { quickbaseClient } from "../../../../src/quickbaseClient.ts";
                        import fetch from "node-fetch";
                        import dotenv from "dotenv";

                        dotenv.config();

                        const loginToQuickbase = async (
                          page: import("@playwright/test").Page,
                          quickbaseUrl: string,
                          username: string,
                          password: string
                        ): Promise<boolean> => {
                          console.log("Logging in to QuickBase");
                          let loginSuccess = false;
                          const maxLoginAttempts = 3;
                          let loginAttempt = 0;

                          while (!loginSuccess && loginAttempt < maxLoginAttempts) {
                            try {
                              loginAttempt++;
                              if (loginAttempt > 1) console.log(`Login attempt ${loginAttempt}`);

                              await page.goto(quickbaseUrl, { timeout: 60000 });
                              await page.waitForSelector("input[name='loginid']", { timeout: 60000 });
                              await page.fill("input[name='loginid']", username);
                              await page.fill("input[name='password']", password);
                              await page.click("#signin");
                              await page.waitForURL(`https://*.quickbase.com/**`, {
                                waitUntil: "networkidle",
                                timeout: 60000,
                              });

                              const loginError = await page.$(".login-error");
                              if (loginError) {
                                throw new Error("Login failed. Please check your credentials.");
                              }

                              console.log("Signed In to QuickBase.");
                              loginSuccess = true;
                            } catch (error) {
                              console.error(
                                `Login attempt ${loginAttempt} failed: ${(error as Error).message}`
                              );
                              if (loginAttempt >= maxLoginAttempts) {
                                console.error("Max login attempts reached. Exiting.");
                                await page.context().browser()!.close();
                                return false;
                              }
                              await new Promise((resolve) => setTimeout(resolve, 5000));
                            }
                          }
                          return loginSuccess;
                        };

                        test.describe("QuickbaseClient Integration - Token Invalidation with Cached Token", () => {
                          test("retries with new token when cached token is unexpectedly invalidated", async ({
                            page,
                          }) => {
                            const realm = process.env.QB_REALM;
                            const appId = process.env.QB_APP_ID;
                            const username = process.env.QB_USERNAME;
                            const password = process.env.QB_PASSWORD;

                            if (!realm) throw new Error("QB_REALM is not defined in .env");
                            if (!appId) throw new Error("QB_APP_ID is not defined in .env");
                            if (!username) throw new Error("QB_USERNAME is not defined in .env");
                            if (!password) throw new Error("QB_PASSWORD is not defined in .env");

                            // Login to QuickBase
                            const quickbaseUrl = `https://${realm}.quickbase.com/db/main?a=SignIn`;
                            const loginSuccess = await loginToQuickbase(
                              page,
                              quickbaseUrl,
                              username,
                              password
                            );
                            if (!loginSuccess) {
                              throw new Error("Failed to log in to QuickBase after max attempts.");
                            }

                            // Navigate to the app page to ensure session context
                            await page.goto(`https://${realm}.quickbase.com/db/${appId}`, {
                              waitUntil: "networkidle",
                              timeout: 60000,
                            });
                            console.log("Post-login URL after app navigation:", page.url());

                            // Track tokens and call counts
                            let callCount = 0;
                            let getAppCallCount = 0;
                            let initialToken: string | null = null;
                            let retryToken: string | null = null;

                            const browserFetch = async (url: string, init?: RequestInit) => {
                              console.log(`browserFetch called for ${url}, callCount: ${callCount}`);
                              const response = await page.evaluate(
                                async ([fetchUrl, fetchInit]) => {
                                  const res = await fetch(fetchUrl, {
                                    ...fetchInit,
                                    credentials: "include",
                                  });
                                  const body = await res.text();
                                  return {
                                    ok: res.ok,
                                    status: res.status,
                                    statusText: res.statusText,
                                    headers: Object.fromEntries(res.headers.entries()),
                                    body,
                                  };
                                },
                                [url, init] as [string, RequestInit]
                              );

                              console.log(`Raw response from ${url}:`, {
                                status: response.status,
                                statusText: response.statusText,
                                body: response.body,
                              });

                              const fetchResponse = new Response(response.body || null, {
                                status: response.status,
                                statusText: response.statusText,
                                headers: response.headers,
                              });

                              // Capture token from response
                              if (url.includes("/auth/temporary/")) {
                                const json = await fetchResponse.clone().json();
                                const token = json.temporaryAuthorization;
                                if (!initialToken) {
                                  initialToken = token;
                                  console.log(`Captured initial token: ${initialToken}`);
                                } else if (!retryToken) {
                                  retryToken = token;
                                  console.log(`Captured retry token: ${retryToken}`);
                                }
                              }

                              return fetchResponse;
                            };

                            const client = quickbaseClient({
                              realm,
                              useTempTokens: true,
                              debug: true,
                              fetchApi: async (url, init) => {
                                callCount++;
                                console.log(`fetchApi called for ${url}, callCount: ${callCount}`);

                                if (url.includes("/auth/temporary/")) {
                                  return browserFetch(url, init); // Use browser fetch for temp tokens
                                }

                                if (url.includes(`/apps/${appId}`)) {
                                  getAppCallCount++;
                                  console.log(`getApp call count: ${getAppCallCount}`);
                                  // Simulate 401 on the first getApp call to trigger retry
                                  if (getAppCallCount === 1) {
                                    console.log("Simulating 401 Unauthorized for first getApp call");
                                    return new Response(JSON.stringify({ message: "Unauthorized" }), {
                                      status: 401,
                                      statusText: "Unauthorized",
                                      headers: { "Content-Type": "application/json" },
                                    });
                                  }
                                }

                                // Use node-fetch for subsequent calls (including retries)
                                console.log(`Fetching ${url} with init:`, init);
                                const response = await fetch(url, init as RequestInit);
                                const body = await response.text();

                                console.log(`Raw response from ${url}:`, {
                                  status: response.status,
                                  statusText: response.statusText,
                                  body,
                                });

                                return new Response(body || null, {
                                  status: response.status,
                                  statusText: response.statusText,
                                  headers: Object.fromEntries(response.headers.entries()),
                                });
                              },
                            });

                            // Pre-fetch token to simulate cached token
                            console.log("Pre-fetching initial token...");
                            const preFetchResult = await client.getTempTokenDBID({ dbid: appId });
                            console.log("Initial token pre-fetched and cached:", preFetchResult);

                            // Call getApp, expecting a 401 followed by a retry with a new token
                            const appResult = await client.getApp({ appId });
                            console.log("App response after token invalidation and retry:", appResult);

                            // Validate the app response
                            expect(appResult).toHaveProperty("id", appId);
                            expect(appResult).toHaveProperty("name");

                            // Verify call counts and token behavior
                            console.log(
                              `Final callCount: ${callCount}, Final getAppCallCount: ${getAppCallCount}`
                            );
                            expect(callCount).toBe(4); // Pre-fetch, 401, token retry, getApp success
                            expect(getAppCallCount).toBe(2); // Initial 401, retry success

                            // Validate pre-fetch and retry tokens
                            console.log(`Initial token: ${initialToken}`);
                            console.log(`Retry token: ${retryToken}`);
                            expect(initialToken).toBeDefined();
                            expect(initialToken).toBe(preFetchResult.temporaryAuthorization); // Confirm pre-fetch token was used
                            expect(retryToken).toBeDefined();
                            expect(initialToken).not.toBe(retryToken); // Confirm retry used a new token
                          });
                        });
                    - name: tokenPrefetch.test.ts
                      type: file
                      contents: |
                        // tests/playwright/qb/auth/tokenPrefetch.test.ts
                        import { test, expect } from "@playwright/test";
                        import { quickbaseClient } from "../../../../src/quickbaseClient.ts";
                        import fetch from "node-fetch";
                        import dotenv from "dotenv";

                        dotenv.config();

                        const loginToQuickbase = async (
                          page: import("@playwright/test").Page,
                          quickbaseUrl: string,
                          username: string,
                          password: string
                        ): Promise<boolean> => {
                          console.log("Logging in to QuickBase");
                          let loginSuccess = false;
                          const maxLoginAttempts = 3;
                          let loginAttempt = 0;

                          while (!loginSuccess && loginAttempt < maxLoginAttempts) {
                            try {
                              loginAttempt++;
                              if (loginAttempt > 1) console.log(`Login attempt ${loginAttempt}`);

                              await page.goto(quickbaseUrl, { timeout: 60000 });
                              await page.waitForSelector("input[name='loginid']", { timeout: 60000 });
                              await page.fill("input[name='loginid']", username);
                              await page.fill("input[name='password']", password);
                              await page.click("#signin");
                              await page.waitForURL(`https://*.quickbase.com/**`, {
                                waitUntil: "networkidle",
                                timeout: 60000,
                              });

                              const loginError = await page.$(".login-error");
                              if (loginError) {
                                throw new Error("Login failed. Please check your credentials.");
                              }

                              console.log("Signed In to QuickBase.");
                              loginSuccess = true;
                            } catch (error) {
                              console.error(
                                `Login attempt ${loginAttempt} failed: ${(error as Error).message}`
                              );
                              if (loginAttempt >= maxLoginAttempts) {
                                console.error("Max login attempts reached. Exiting.");
                                await page.context().browser()!.close();
                                return false;
                              }
                              await new Promise((resolve) => setTimeout(resolve, 5000));
                            }
                          }
                          return loginSuccess;
                        };

                        test.describe("QuickbaseClient Integration - Token Pre-Fetch and Cache Reuse", () => {
                          test("pre-fetches token and reuses it for subsequent API calls", async ({
                            page,
                          }) => {
                            const realm = process.env.QB_REALM;
                            const appId = process.env.QB_APP_ID;
                            const username = process.env.QB_USERNAME;
                            const password = process.env.QB_PASSWORD;

                            if (!realm) throw new Error("QB_REALM is not defined in .env");
                            if (!appId) throw new Error("QB_APP_ID is not defined in .env");
                            if (!username) throw new Error("QB_USERNAME is not defined in .env");
                            if (!password) throw new Error("QB_PASSWORD is not defined in .env");

                            // Login to QuickBase
                            const quickbaseUrl = `https://${realm}.quickbase.com/db/main?a=SignIn`;
                            const loginSuccess = await loginToQuickbase(
                              page,
                              quickbaseUrl,
                              username,
                              password
                            );
                            if (!loginSuccess) {
                              throw new Error("Failed to log in to QuickBase after max attempts.");
                            }

                            // Navigate to the app page to ensure session context
                            await page.goto(`https://${realm}.quickbase.com/db/${appId}`, {
                              waitUntil: "networkidle",
                              timeout: 60000,
                            });
                            console.log("Post-login URL after app navigation:", page.url());

                            // Track tokens and call counts
                            let callCount = 0;
                            let cachedToken: string | null = null;

                            const browserFetch = async (url: string, init?: RequestInit) => {
                              console.log(`browserFetch called for ${url}, callCount: ${callCount}`);
                              const response = await page.evaluate(
                                async ([fetchUrl, fetchInit]) => {
                                  const res = await fetch(fetchUrl, {
                                    ...fetchInit,
                                    credentials: "include",
                                  });
                                  const body = await res.text();
                                  return {
                                    ok: res.ok,
                                    status: res.status,
                                    statusText: res.statusText,
                                    headers: Object.fromEntries(res.headers.entries()),
                                    body,
                                  };
                                },
                                [url, init] as [string, RequestInit]
                              );

                              console.log(`Raw response from ${url}:`, {
                                status: response.status,
                                statusText: response.statusText,
                                body: response.body,
                              });

                              const fetchResponse = new Response(response.body || null, {
                                status: response.status,
                                statusText: response.statusText,
                                headers: response.headers,
                              });

                              // Capture token from response
                              if (url.includes("/auth/temporary/")) {
                                const json = await fetchResponse.clone().json();
                                const token = json.temporaryAuthorization;
                                cachedToken = token; // Store the pre-fetched token
                                console.log(`Captured pre-fetched token: ${cachedToken}`);
                              }

                              return fetchResponse;
                            };

                            const client = quickbaseClient({
                              realm,
                              useTempTokens: true,
                              debug: true,
                              fetchApi: async (url, init) => {
                                callCount++;
                                console.log(`fetchApi called for ${url}, callCount: ${callCount}`);

                                if (url.includes("/auth/temporary/")) {
                                  return browserFetch(url, init); // Use browser fetch for temp tokens
                                }

                                // Use node-fetch for app calls, ensuring we track reuse
                                console.log(`Fetching ${url} with init:`, init);
                                const response = await fetch(url, init as RequestInit);
                                const body = await response.text();

                                console.log(`Raw response from ${url}:`, {
                                  status: response.status,
                                  statusText: response.statusText,
                                  body,
                                });

                                return new Response(body || null, {
                                  status: response.status,
                                  statusText: response.statusText,
                                  headers: Object.fromEntries(response.headers.entries()),
                                });
                              },
                            });

                            // Step 1: Pre-fetch token
                            console.log("Pre-fetching token...");
                            const tokenResult = await client.getTempTokenDBID({ dbid: appId });
                            console.log("Pre-fetched token result:", tokenResult);
                            expect(tokenResult).toHaveProperty("temporaryAuthorization");
                            expect(cachedToken).toBe(tokenResult.temporaryAuthorization);

                            // Step 2: Call getApp, expecting it to reuse the cached token
                            console.log("Calling getApp with pre-fetched token...");
                            const appResult = await client.getApp({ appId });
                            console.log("App response:", appResult);

                            // Validate the app response
                            expect(appResult).toHaveProperty("id", appId);
                            expect(appResult).toHaveProperty("name");

                            // Verify call count and token reuse
                            console.log(`Final callCount: ${callCount}`);
                            expect(callCount).toBe(2); // One for pre-fetch, one for getApp
                            expect(cachedToken).toBeDefined();

                            // Check that getApp reused the token by inspecting logs manually or adding a header check if needed
                            console.log(`Pre-fetched token: ${cachedToken}`);
                          });
                        });
                    - name: tokenRenewal.test.ts
                      type: file
                      contents: |
                        // tests/playwright/qb/auth/tokenRenewal.test.ts
                        import { test, expect } from "@playwright/test";
                        import { quickbaseClient } from "../../../../src/quickbaseClient.ts";
                        import dotenv from "dotenv";

                        dotenv.config();

                        const loginToQuickbase = async (
                          page,
                          quickbaseUrl,
                          username,
                          password,
                          appUrl
                        ) => {
                          console.log("Logging in to QuickBase");
                          await page.goto(quickbaseUrl, { timeout: 60000 });
                          await page.waitForSelector("input[name='loginid']", { timeout: 60000 });
                          await page.fill("input[name='loginid']", username);
                          await page.fill("input[name='password']", password);
                          await page.click("#signin");
                          await page.waitForURL(`https://*.quickbase.com/**`, {
                            waitUntil: "networkidle",
                            timeout: 60000,
                          });
                          console.log("Signed In to QuickBase.");
                          await page.goto(appUrl, { waitUntil: "networkidle", timeout: 60000 });
                          console.log("Navigated to app URL:", page.url());
                        };

                        test.describe("QuickbaseClient Integration - Temp Token Renewal", () => {
                          test("renews temp token after 5 minutes with getApp → wait → getApp sequence", async ({
                            page,
                          }) => {
                            const realm = process.env.QB_REALM!;
                            const appId = process.env.QB_APP_ID!;
                            const username = process.env.QB_USERNAME!;
                            const password = process.env.QB_PASSWORD!;
                            const quickbaseUrl = `https://${realm}.quickbase.com/db/main?a=SignIn`;
                            const appUrl = `https://${realm}.quickbase.com/db/${appId}`;

                            await loginToQuickbase(page, quickbaseUrl, username, password, appUrl);

                            const browserFetch = async (
                              url: string,
                              init: RequestInit
                            ): Promise<Response> => {
                              const response = await page.request.fetch(url, {
                                method: init.method || "GET",
                                headers: {
                                  ...init.headers,
                                  Referer: `https://${realm}.quickbase.com/db/${appId}`,
                                  Origin: `https://${realm}.quickbase.com`,
                                },
                                data: init.body,
                                credentials: "include",
                              });
                              const body = await response.text();
                              console.log(
                                "Response from:",
                                url,
                                "status:",
                                response.status(),
                                "body:",
                                body
                              );
                              return new Response(body, {
                                status: response.status(),
                                statusText: response.statusText(),
                                headers: response.headers(),
                              });
                            };

                            const client = quickbaseClient({
                              realm,
                              useTempTokens: true,
                              debug: true,
                              fetchApi: browserFetch,
                            });

                            console.log("Checking session state before getApp...");
                            const cookies = await page.context().cookies();
                            const sessionCookie = cookies.find(
                              (c) => c.name === "TICKET" || c.name.startsWith("TICKET_")
                            );
                            console.log(
                              "Session cookie present:",
                              !!sessionCookie,
                              "Cookies:",
                              cookies
                            );
                            if (!sessionCookie) throw new Error("TICKET session cookie not found");

                            await page.waitForTimeout(5000); // Debug delay
                            console.log("Cookies after delay:", await page.context().cookies());

                            const appResult1 = await client.getApp({ appId });
                            console.log("First getApp response:", appResult1);
                            expect(appResult1.id).toBe(appId);

                            console.log("Waiting 5 minutes to test token expiration...");
                            await new Promise((resolve) => setTimeout(resolve, 5 * 60 * 1000));

                            await page.reload({ waitUntil: "load", timeout: 60000 });
                            console.log("Refreshed page after 5 minutes, URL:", page.url());

                            const appResult2 = await client.getApp({ appId });
                            console.log("Second getApp response:", appResult2);
                            expect(appResult2.id).toBe(appId);
                          });
                        });
        - name: setup.ts
          type: file
          contents: |
            import { quickbaseClient } from "../src/quickbaseClient.ts";
            import dotenv from "dotenv";
            import { vi } from "vitest";

            dotenv.config();

            export const createClient = (fetchApi?: any) =>
              quickbaseClient({
                realm: process.env.QB_REALM || "default-realm",
                userToken: process.env.QB_USER_TOKEN || "default-token",
                debug: true,
                fetchApi,
              });

            export const mockFetch = vi.fn();
        - name: vitest
          type: directory
          children:
            - name: qb
              type: directory
              children:
                - name: apps
                  type: directory
                  children:
                    - name: getApp.test.ts
                      type: file
                      contents: |
                        import { describe, it, expect } from "vitest";
                        import { createClient } from "../../../setup.ts";

                        describe("QuickbaseClient Integration - getApp", () => {
                          const client = createClient();

                          it(
                            "fetches real app data from QuickBase",
                            async () => {
                              const getAppId = process.env.QB_APP_ID;
                              if (!getAppId) throw new Error("QB_APP_ID is not defined in .env");
                              if (!process.env.QB_REALM)
                                throw new Error("QB_REALM is not defined in .env");
                              if (!process.env.QB_USER_TOKEN)
                                throw new Error("QB_USER_TOKEN is not defined in .env");

                              console.log("Config used:", {
                                realm: process.env.QB_REALM,
                                userToken: process.env.QB_USER_TOKEN,
                                appId: getAppId,
                              });
                              const result = await client.getApp({ appId: getAppId });
                              console.log("Real API response:", result);
                              expect(result).toEqual({
                                id: getAppId,
                                name: "qb-copy",
                                created: new Date("2025-02-13T18:22:33Z"),
                                updated: new Date("2025-03-04T04:25:51Z"),
                                description: "",
                                timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                                dateFormat: "MM-DD-YYYY",
                                hasEveryoneOnTheInternet: false,
                                memoryInfo: { estMemory: 0, estMemoryInclDependentApps: 0 },
                                securityProperties: {
                                  allowClone: false,
                                  allowExport: true,
                                  enableAppTokens: true,
                                  hideFromPublic: false,
                                  mustBeRealmApproved: false,
                                  useIPFilter: false,
                                },
                              });
                            },
                            { timeout: 10000 }
                          );
                        });
                - name: fields
                  type: directory
                  children:
                    - name: getFields.test.ts
                      type: file
                      contents: |
                        import { describe, it, expect } from "vitest";
                        import { createClient } from "../../../setup.ts";

                        describe("QuickbaseClient Integration - getFields", () => {
                          const client = createClient();

                          it(
                            "fetches real field data from QuickBase",
                            async () => {
                              const tableId = "buwai2z3s";
                              if (!tableId) throw new Error("Table ID is not defined");
                              if (!process.env.QB_REALM)
                                throw new Error("QB_REALM is not defined in .env");
                              if (!process.env.QB_USER_TOKEN)
                                throw new Error("QB_USER_TOKEN is not defined in .env");

                              console.log("Config used:", {
                                realm: process.env.QB_REALM,
                                userToken: process.env.QB_USER_TOKEN,
                                tableId,
                              });
                              const result = await client.getFields({
                                tableId,
                                includeFieldPerms: true,
                              });
                              console.log("Real API response:", result);
                              expect(result).toEqual(
                                expect.arrayContaining([
                                  expect.objectContaining({
                                    id: 1,
                                    label: "Date Created",
                                    fieldType: "timestamp",
                                    noWrap: true,
                                    bold: false,
                                    required: false,
                                    appearsByDefault: false,
                                    findEnabled: false,
                                    unique: false,
                                    doesDataCopy: false,
                                    fieldHelp: "",
                                    audited: false,
                                    properties: expect.objectContaining({
                                      primaryKey: false,
                                      foreignKey: false,
                                      sortAsGiven: true,
                                      carryChoices: true,
                                      allowNewChoices: false,
                                      formula: "",
                                      defaultValue: "",
                                    }),
                                    permissions: expect.arrayContaining([
                                      expect.objectContaining({
                                        permissionType: "Modify",
                                        role: "Viewer",
                                        roleId: 10,
                                      }),
                                      expect.objectContaining({
                                        permissionType: "Modify",
                                        role: "Participant",
                                        roleId: 11,
                                      }),
                                      expect.objectContaining({
                                        permissionType: "Modify",
                                        role: "Administrator",
                                        roleId: 12,
                                      }),
                                    ]),
                                  }),
                                  expect.objectContaining({
                                    id: 2,
                                    label: "Date Modified",
                                    fieldType: "timestamp",
                                    noWrap: true,
                                    bold: false,
                                    required: false,
                                    appearsByDefault: false,
                                    findEnabled: false,
                                    unique: false,
                                    doesDataCopy: false,
                                    fieldHelp: "",
                                    audited: false,
                                    properties: expect.objectContaining({
                                      primaryKey: false,
                                      foreignKey: false,
                                      sortAsGiven: true,
                                      carryChoices: true,
                                      allowNewChoices: false,
                                      formula: "",
                                      defaultValue: "",
                                    }),
                                    permissions: expect.arrayContaining([
                                      expect.objectContaining({
                                        permissionType: "Modify",
                                        role: "Viewer",
                                        roleId: 10,
                                      }),
                                      expect.objectContaining({
                                        permissionType: "Modify",
                                        role: "Participant",
                                        roleId: 11,
                                      }),
                                      expect.objectContaining({
                                        permissionType: "Modify",
                                        role: "Administrator",
                                        roleId: 12,
                                      }),
                                    ]),
                                  }),
                                  expect.objectContaining({
                                    id: 3,
                                    label: "Record ID#",
                                    fieldType: "recordid",
                                    noWrap: true,
                                    bold: false,
                                    required: false,
                                    appearsByDefault: false,
                                    findEnabled: false,
                                    unique: true,
                                    doesDataCopy: false,
                                    fieldHelp: "",
                                    audited: false,
                                    properties: expect.objectContaining({
                                      primaryKey: true,
                                      foreignKey: false,
                                      sortAsGiven: true,
                                      carryChoices: true,
                                      allowNewChoices: false,
                                      formula: "",
                                      defaultValue: "",
                                    }),
                                    permissions: expect.arrayContaining([
                                      expect.objectContaining({
                                        permissionType: "Modify",
                                        role: "Viewer",
                                        roleId: 10,
                                      }),
                                      expect.objectContaining({
                                        permissionType: "Modify",
                                        role: "Participant",
                                        roleId: 11,
                                      }),
                                      expect.objectContaining({
                                        permissionType: "Modify",
                                        role: "Administrator",
                                        roleId: 12,
                                      }),
                                    ]),
                                  }),
                                  expect.objectContaining({
                                    id: 4,
                                    label: "Record Owner",
                                    fieldType: "user",
                                    noWrap: true,
                                    bold: false,
                                    required: false,
                                    appearsByDefault: false,
                                    findEnabled: true,
                                    unique: false,
                                    doesDataCopy: false,
                                    fieldHelp: "",
                                    audited: false,
                                    properties: expect.objectContaining({
                                      primaryKey: false,
                                      foreignKey: false,
                                      sortAsGiven: true,
                                      carryChoices: true,
                                      allowNewChoices: true,
                                      formula: "",
                                      defaultValue: "",
                                    }),
                                    permissions: expect.arrayContaining([
                                      expect.objectContaining({
                                        permissionType: "Modify",
                                        role: "Viewer",
                                        roleId: 10,
                                      }),
                                      expect.objectContaining({
                                        permissionType: "Modify",
                                        role: "Participant",
                                        roleId: 11,
                                      }),
                                      expect.objectContaining({
                                        permissionType: "Modify",
                                        role: "Administrator",
                                        roleId: 12,
                                      }),
                                    ]),
                                  }),
                                  expect.objectContaining({
                                    id: 5,
                                    label: "Last Modified By",
                                    fieldType: "user",
                                    noWrap: true,
                                    bold: false,
                                    required: false,
                                    appearsByDefault: false,
                                    findEnabled: true,
                                    unique: false,
                                    doesDataCopy: false,
                                    fieldHelp: "",
                                    audited: false,
                                    properties: expect.objectContaining({
                                      primaryKey: false,
                                      foreignKey: false,
                                      sortAsGiven: true,
                                      carryChoices: true,
                                      allowNewChoices: true,
                                      formula: "",
                                      defaultValue: "",
                                    }),
                                    permissions: expect.arrayContaining([
                                      expect.objectContaining({
                                        permissionType: "Modify",
                                        role: "Viewer",
                                        roleId: 10,
                                      }),
                                      expect.objectContaining({
                                        permissionType: "Modify",
                                        role: "Participant",
                                        roleId: 11,
                                      }),
                                      expect.objectContaining({
                                        permissionType: "Modify",
                                        role: "Administrator",
                                        roleId: 12,
                                      }),
                                    ]),
                                  }),
                                ])
                              );
                            },
                            { timeout: 10000 }
                          );
                        });
                - name: index.ts
                  type: file
                  contents: |
                    // Optional: Only add if you need to export tests
                    export * from "./apps/getApp.test.ts";
                    export * from "./fields/getFields.test.ts";
                    export * from "./tables/getAppTables.test.ts";
                - name: tables
                  type: directory
                  children:
                    - name: getAppTables.test.ts
                      type: file
                      contents: |
                        import { describe, it, expect } from "vitest";
                        import { createClient } from "../../../setup.ts";

                        describe("QuickbaseClient Integration - getAppTables", () => {
                          const client = createClient();

                          it(
                            "fetches real table data from QuickBase",
                            async () => {
                              const tablesAppId = process.env.QB_APP_ID;
                              if (!tablesAppId) throw new Error("QB_APP_ID is not defined in .env");
                              if (!process.env.QB_REALM)
                                throw new Error("QB_REALM is not defined in .env");
                              if (!process.env.QB_USER_TOKEN)
                                throw new Error("QB_USER_TOKEN is not defined in .env");

                              console.log("Config used:", {
                                realm: process.env.QB_REALM,
                                userToken: process.env.QB_USER_TOKEN,
                                appId: tablesAppId,
                              });
                              const result = await client.getAppTables({ appId: tablesAppId });
                              console.log("Real API response:", result);
                              expect(result).toEqual(
                                expect.arrayContaining([
                                  expect.objectContaining({
                                    alias: "_DBID_ROOT",
                                    created: new Date("2025-02-13T18:22:33Z"),
                                    defaultSortFieldId: 2,
                                    defaultSortOrder: "DESC",
                                    description: "",
                                    id: "buwai2zr4",
                                    keyFieldId: 3,
                                    name: "Root",
                                    nextFieldId: 6,
                                    nextRecordId: 1,
                                    pluralRecordName: "Roots",
                                    singleRecordName: "Root",
                                    sizeLimit: "500 MB",
                                    spaceRemaining: "500 MB",
                                    spaceUsed: "0 KB",
                                    updated: new Date("2025-02-13T18:22:34Z"),
                                  }),
                                  expect.objectContaining({
                                    alias: "_DBID_ROLES",
                                    created: new Date("2025-02-13T18:22:33Z"),
                                    defaultSortFieldId: 2,
                                    defaultSortOrder: "DESC",
                                    description: "",
                                    id: "buwai2z3s",
                                    keyFieldId: 3,
                                    name: "Roles",
                                    nextFieldId: 6,
                                    nextRecordId: 1,
                                    pluralRecordName: "Roles",
                                    singleRecordName: "Role",
                                    sizeLimit: "500 MB",
                                    spaceRemaining: "500 MB",
                                    spaceUsed: "0 KB",
                                    updated: new Date("2025-02-13T18:22:34Z"),
                                  }),
                                ])
                              );
                            },
                            { timeout: 10000 }
                          );
                        });
            - name: unit
              type: directory
              children:
                - name: apps
                  type: directory
                  children:
                    - name: getApp.test.ts
                      type: file
                      contents: |
                        import { describe, it, expect, beforeEach } from "vitest";
                        import { createClient, mockFetch } from "../../setup.ts";

                        describe("QuickbaseClient - getApp (Unit)", () => {
                          const client = createClient(mockFetch);

                          beforeEach(() => {
                            mockFetch.mockClear();
                          });

                          it("initializes without errors", () => {
                            expect(client).toBeDefined();
                          });

                          it("has getApp method", () => {
                            expect(typeof client.getApp).toBe("function");
                          });

                          it("calls getApp successfully", async () => {
                            mockFetch.mockImplementation((url: string, options: any) => {
                              console.log("Mock fetch:", url, options);
                              return Promise.resolve({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve({
                                    id: process.env.QB_APP_ID,
                                    name: "qb-copy",
                                    created: "2025-02-13T18:22:33Z",
                                    updated: "2025-03-04T04:25:51Z",
                                    description: "",
                                    timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                                    dateFormat: "MM-DD-YYYY",
                                    hasEveryoneOnTheInternet: false,
                                    memoryInfo: { estMemory: 0, estMemoryInclDependentApps: 0 },
                                    securityProperties: {
                                      allowClone: false,
                                      allowExport: true,
                                      enableAppTokens: true,
                                      hideFromPublic: false,
                                      mustBeRealmApproved: false,
                                      useIPFilter: false,
                                    },
                                  }),
                              } as Response);
                            });

                            const getAppId = process.env.QB_APP_ID;
                            if (!getAppId) throw new Error("QB_APP_ID is not defined in .env");
                            console.log("Test appId:", getAppId);
                            const result = await client.getApp({ appId: getAppId });
                            expect(result).toEqual({
                              id: getAppId,
                              name: "qb-copy",
                              created: new Date("2025-02-13T18:22:33Z"),
                              updated: new Date("2025-03-04T04:25:51Z"),
                              description: "",
                              timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                              dateFormat: "MM-DD-YYYY",
                              hasEveryoneOnTheInternet: false,
                              memoryInfo: { estMemory: 0, estMemoryInclDependentApps: 0 },
                              securityProperties: {
                                allowClone: false,
                                allowExport: true,
                                enableAppTokens: true,
                                hideFromPublic: false,
                                mustBeRealmApproved: false,
                                useIPFilter: false,
                              },
                            });
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps/${getAppId}`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: `QB-USER-TOKEN ${process.env.QB_USER_TOKEN}`,
                                  "QB-Realm-Hostname": `${process.env.QB_REALM}.quickbase.com`,
                                }),
                              })
                            );
                          });
                        });
                - name: auth
                  type: directory
                  children:
                    - name: getTempToken.test.ts
                      type: file
                      contents: |
                        import { describe, it, expect, beforeEach } from "vitest";
                        import { createClient, mockFetch } from "../../setup.ts";

                        describe("QuickbaseClient - getTempTokenDBID (Unit)", () => {
                          const client = createClient(mockFetch);

                          beforeEach(() => {
                            mockFetch.mockClear();
                          });

                          it("initializes without errors", () => {
                            expect(client).toBeDefined();
                          });

                          it("has getTempTokenDBID method", () => {
                            expect(typeof client.getTempTokenDBID).toBe("function");
                          });

                          it("calls getTempTokenDBID successfully", async () => {
                            const mockDbid = "mockDbid123";
                            const mockToken = "b123xyz_temp_token";

                            mockFetch.mockResolvedValue({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve({ temporaryAuthorization: mockToken }),
                            } as Response);

                            const result = await client.getTempTokenDBID({ dbid: mockDbid });
                            expect(result).toEqual({ temporaryAuthorization: mockToken });
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/auth/temporary/${mockDbid}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  Authorization: `QB-USER-TOKEN ${process.env.QB_USER_TOKEN}`,
                                  "QB-Realm-Hostname": `${process.env.QB_REALM}.quickbase.com`,
                                  "Content-Type": "application/json",
                                }),
                              })
                            );
                          });

                          it("handles API error", async () => {
                            const mockDbid = "mockDbid123";
                            const errorResponse = {
                              ok: false,
                              status: 401,
                              json: () => Promise.resolve({ message: "Unauthorized" }),
                            } as Response;

                            mockFetch.mockResolvedValue(errorResponse);

                            await expect(client.getTempTokenDBID({ dbid: mockDbid })).rejects.toSatisfy(
                              (error: Error) => {
                                expect(error).toBeInstanceOf(Error);
                                expect(error.message).toBe("API Error: Unauthorized (Status: 401)");
                                return true;
                              }
                            );
                          });
                        });
                - name: fields
                  type: directory
                  children:
                    - name: getFields.test.ts
                      type: file
                      contents: |
                        import { describe, it, expect } from "vitest";
                        import { createClient, mockFetch } from "../../setup.ts";

                        describe("QuickbaseClient - getFields (Unit)", () => {
                          it("calls getFields successfully", async () => {
                            mockFetch.mockImplementation((url: string, options: any) => {
                              console.log("Mock fetch for getFields:", url, options);
                              return Promise.resolve({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve([
                                    {
                                      id: 1,
                                      label: "Field1",
                                      fieldType: "text",
                                      noWrap: false,
                                      bold: false,
                                      required: false,
                                      appearsByDefault: false,
                                      findEnabled: false,
                                      unique: false,
                                      doesDataCopy: false,
                                      fieldHelp: "field help",
                                      audited: false,
                                      properties: {
                                        primaryKey: false,
                                        foreignKey: false,
                                        numLines: 1,
                                        maxLength: 0,
                                        appendOnly: false,
                                        allowHTML: false,
                                        allowMentions: false,
                                        sortAsGiven: false,
                                        carryChoices: true,
                                        allowNewChoices: false,
                                        formula: "",
                                        defaultValue: "",
                                      },
                                      permissions: [
                                        { permissionType: "View", role: "Viewer", roleId: 10 },
                                        { permissionType: "None", role: "Participant", roleId: 11 },
                                        { permissionType: "Modify", role: "Administrator", roleId: 12 },
                                      ],
                                    },
                                  ]),
                              } as Response);
                            });

                            const client = createClient(mockFetch);
                            const result = await client.getFields({
                              tableId: "dummyTableId",
                              includeFieldPerms: true,
                            });
                            console.log("getFields response:", result);
                            expect(result).toEqual(
                              expect.arrayContaining([
                                expect.objectContaining({
                                  id: 1,
                                  label: "Field1",
                                  fieldType: "text",
                                  noWrap: false,
                                  bold: false,
                                  required: false,
                                  appearsByDefault: false,
                                  findEnabled: false,
                                  unique: false,
                                  doesDataCopy: false,
                                  fieldHelp: "field help",
                                  audited: false,
                                  properties: expect.objectContaining({
                                    primaryKey: false,
                                    foreignKey: false,
                                    numLines: 1,
                                    maxLength: 0,
                                    appendOnly: false,
                                    allowHTML: false,
                                    allowMentions: false,
                                    sortAsGiven: false,
                                    carryChoices: true,
                                    allowNewChoices: false,
                                    formula: "",
                                    defaultValue: "",
                                  }),
                                  permissions: expect.arrayContaining([
                                    expect.objectContaining({
                                      permissionType: "View",
                                      role: "Viewer",
                                      roleId: 10,
                                    }),
                                    expect.objectContaining({
                                      permissionType: "None",
                                      role: "Participant",
                                      roleId: 11,
                                    }),
                                    expect.objectContaining({
                                      permissionType: "Modify",
                                      role: "Administrator",
                                      roleId: 12,
                                    }),
                                  ]),
                                }),
                              ])
                            );
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields?tableId=dummyTableId&includeFieldPerms=true`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: `QB-USER-TOKEN ${process.env.QB_USER_TOKEN}`,
                                  "QB-Realm-Hostname": `${process.env.QB_REALM}.quickbase.com`,
                                }),
                              })
                            );
                          });
                        });
                - name: index.ts
                  type: file
                  contents: |
                    // tests/unit/index.ts
                    export * from "./apps/getApp.test.ts";
                    export * from "./fields/getFields.test.ts";
                    export * from "./tables/getAppTables.test.ts";
                - name: tables
                  type: directory
                  children:
                    - name: getAppTables.test.ts
                      type: file
                      contents: |
                        import { describe, it, expect } from "vitest";
                        import { createClient, mockFetch } from "../../setup.ts";

                        describe("QuickbaseClient - getAppTables (Unit)", () => {
                          it("calls getAppTables successfully", async () => {
                            mockFetch.mockImplementation((url: string, options: any) => {
                              console.log("Mock fetch for getAppTables:", url, options);
                              return Promise.resolve({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve([
                                    {
                                      alias: "_DBID_ROOT",
                                      created: "2025-02-13T18:22:33Z",
                                      defaultSortFieldId: 2,
                                      defaultSortOrder: "DESC",
                                      description: "",
                                      id: "buwai2zr4",
                                      keyFieldId: 3,
                                      name: "Root",
                                      nextFieldId: 6,
                                      nextRecordId: 1,
                                      pluralRecordName: "Roots",
                                      singleRecordName: "Root",
                                      sizeLimit: "500 MB",
                                      spaceRemaining: "500 MB",
                                      spaceUsed: "0 KB",
                                      updated: "2025-02-13T18:22:34Z",
                                    },
                                  ]),
                              } as Response);
                            });

                            const client = createClient(mockFetch);
                            const tablesAppId = process.env.QB_APP_ID;
                            if (!tablesAppId) throw new Error("QB_APP_ID is not defined in .env");
                            const result = await client.getAppTables({ appId: tablesAppId });
                            console.log("getAppTables response:", result);
                            expect(result).toEqual(
                              expect.arrayContaining([
                                expect.objectContaining({
                                  alias: "_DBID_ROOT",
                                  created: new Date("2025-02-13T18:22:33Z"),
                                  defaultSortFieldId: 2,
                                  defaultSortOrder: "DESC",
                                  description: "",
                                  id: "buwai2zr4",
                                  keyFieldId: 3,
                                  name: "Root",
                                  nextFieldId: 6,
                                  nextRecordId: 1,
                                  pluralRecordName: "Roots",
                                  singleRecordName: "Root",
                                  sizeLimit: "500 MB",
                                  spaceRemaining: "500 MB",
                                  spaceUsed: "0 KB",
                                  updated: new Date("2025-02-13T18:22:34Z"),
                                }),
                              ])
                            );
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables?appId=${tablesAppId}`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: `QB-USER-TOKEN ${process.env.QB_USER_TOKEN}`,
                                  "QB-Realm-Hostname": `${process.env.QB_REALM}.quickbase.com`,
                                }),
                              })
                            );
                          });
                        });
    - name: text.txt
      type: file
    - name: tsconfig.json
      type: file
      contents: |-
        {
          "compilerOptions": {
            "target": "ESNext",
            "module": "ESNext", // Changed from NodeNext to match bundler
            "moduleResolution": "bundler",
            "strict": true,
            "lib": ["ESNext", "DOM"],
            "types": ["node", "playwright/test"],
            "esModuleInterop": true,
            "resolveJsonModule": true,
            "allowImportingTsExtensions": true,
            "noEmit": true,
            "outDir": "dist",
            "rootDir": ".", // Includes src/ and tests/
            "declaration": true,
            "sourceMap": true
          },
          "include": ["src/**/*", "tests/**/*"],
          "exclude": ["node_modules", "dist", "src/generated-old"],
          "ts-node": {
            "esm": true,
            "transpileOnly": true
          }
        }
    - name: vitest.config.ts
      type: file
      contents: |
        import { defineConfig } from "vitest/config";

        export default defineConfig({
          test: {
            environment: "jsdom", // Matches your current setup
            include: ["tests/**/*.test.ts"], // Matches all test files
            setupFiles: ["tests/setup.ts"], // Runs setup.ts before tests
          },
        });

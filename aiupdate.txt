[quickbase-js] Tree - 3/5/2025
Root: /home/drew/Projects/quickbase-js

Project Goals:
- Implement a QuickBase API client in TypeScript.
- Generate client methods from the QuickBase RESTful API spec.
- Provide a simple and intuitive interface for interacting with QuickBase.
- This library should not have to manually update the client methods when the QuickBase API changes.
- Generate ergonomic client methods from the QuickBase RESTful API spec that do not require manual updates.
- Support both Node.js and browser environments.
- The intent is to use this in JS frameworks like React, Vue, and Angular.
- Use the Fetch API for making HTTP requests and avoid Axios with the OpenAPI Generator.
- Use OpenAPI to generate the TypeScript types and methods.
- Use the latest ES6+ features and TypeScript features.


├─ .env.development
├─ .env.production
├─ .gitignore
├─ LICENSE
├─ README.md
├─ aiupdate.ts
├─ aiupdate.txt
├─ build.js
├─ code-generation/
│ ├─ fix-spec.ts
│ │   Contents:
│ │     #!/usr/bin/env node
│ │     import { promises as fs } from "fs";
│ │     import path from "path";
│ │     import * as glob from "glob";
│ │     
│ │     // Define types for the spec structure (simplified for brevity)
│ │     interface Parameter {
│ │       name: string;
│ │       in: string;
│ │       required?: boolean;
│ │       type?: string;
│ │       schema?: { type?: string; items?: any };
│ │       example?: any;
│ │     }
│ │     
│ │     interface Operation {
│ │       parameters?: Parameter[];
│ │       responses?: Record<string, { description: string; schema?: any }>;
│ │     }
│ │     
│ │     interface Spec {
│ │       paths: Record<string, Record<string, Operation>>;
│ │       definitions?: Record<string, any>;
│ │       operations?: any;
│ │       groups?: any;
│ │       components?: any;
│ │     }
│ │     
│ │     async function fixQuickBaseSpec(): Promise<void> {
│ │       try {
│ │         const CODEGEN_DIR = path.dirname(new URL(import.meta.url).pathname);
│ │         const SPECS_DIR = path.join(CODEGEN_DIR, "..", "specs");
│ │         console.log("Finding latest QuickBase RESTful API spec...");
│ │         const specFiles = glob.sync(
│ │           path.join(SPECS_DIR, "QuickBase_RESTful_*.json")
│ │         );
│ │         if (specFiles.length === 0) {
│ │           console.error(
│ │             "No QuickBase_RESTful_*.json files found in specs/ folder."
│ │           );
│ │           process.exit(1);
│ │         }
│ │         const inputFile = specFiles.sort().pop() as string;
│ │         const outputFile = path.join(CODEGEN_DIR, "quickbase-fixed.json");
│ │     
│ │         console.log(`Reading ${path.basename(inputFile)} from specs/...`);
│ │         const specContent = await fs.readFile(inputFile, "utf8");
│ │         const spec: Spec = JSON.parse(specContent);
│ │     
│ │         console.log("Fixing parameters...");
│ │         for (const pathKey in spec.paths) {
│ │           for (const method in spec.paths[pathKey]) {
│ │             const operation = spec.paths[pathKey][method];
│ │             if (operation.parameters) {
│ │               operation.parameters = operation.parameters.map(
│ │                 (param: Parameter) => {
│ │                   if ("example" in param) delete param.example;
│ │                   if ("schema" in param && param.in !== "body") delete param.schema;
│ │                   if (!param.type && param.in !== "body") param.type = "string";
│ │                   if (
│ │                     param.name === "generated" &&
│ │                     param.schema?.type === "array" &&
│ │                     !param.schema.items
│ │                   ) {
│ │                     param.schema!.items = { $ref: "#/definitions/Record" };
│ │                   }
│ │                   return param;
│ │                 }
│ │               );
│ │             }
│ │           }
│ │         }
│ │     
│ │         console.log("Adding responses and schemas...");
│ │         // Fix /fields endpoint
│ │         if (spec.paths["/fields"]?.get) {
│ │           spec.paths["/fields"].get.parameters = [
│ │             { name: "tableId", in: "query", required: true, type: "string" },
│ │             {
│ │               name: "includeFieldPerms",
│ │               in: "query",
│ │               required: false,
│ │               type: "boolean",
│ │             },
│ │           ];
│ │           spec.paths["/fields"].get.responses = {
│ │             200: {
│ │               description: "Successful response",
│ │               schema: { type: "array", items: { $ref: "#/definitions/Field" } },
│ │             },
│ │           };
│ │         }
│ │     
│ │         // Fix /fields/{fieldId} endpoint (example)
│ │         if (spec.paths["/fields/{fieldId}"]?.get) {
│ │           spec.paths["/fields/{fieldId}"].get.responses = {
│ │             200: {
│ │               description: "Successful response",
│ │               schema: { $ref: "#/definitions/Field" },
│ │             },
│ │           };
│ │         }
│ │     
│ │         // Add /tables/{tableId} endpoint with Table definition
│ │         if (spec.paths["/tables/{tableId}"]?.get) {
│ │           spec.paths["/tables/{tableId}"].get.parameters = [
│ │             { name: "appId", in: "query", required: true, type: "string" },
│ │             { name: "tableId", in: "path", required: true, type: "string" },
│ │           ];
│ │           spec.paths["/tables/{tableId}"].get.responses = {
│ │             200: {
│ │               description: "Successful response",
│ │               schema: { $ref: "#/definitions/Table" },
│ │             },
│ │           };
│ │         }
│ │     
│ │         // Fix /apps/{appId} endpoint (example)
│ │         if (spec.paths["/apps/{appId}"]?.get) {
│ │           spec.paths["/apps/{appId}"].get.responses = {
│ │             200: {
│ │               description: "Successful response",
│ │               schema: { $ref: "#/definitions/App" },
│ │             },
│ │           };
│ │         }
│ │     
│ │         // Add more endpoints as needed...
│ │     
│ │         console.log("Adding definitions...");
│ │         if (!spec.definitions) spec.definitions = {};
│ │     
│ │         // Field definition (already present)
│ │         spec.definitions.Field = {
│ │           type: "object",
│ │           properties: {
│ │             appearsByDefault: { type: "boolean" },
│ │             audited: { type: "boolean" },
│ │             bold: { type: "boolean" },
│ │             doesDataCopy: { type: "boolean" },
│ │             fieldHelp: { type: "string" },
│ │             fieldType: { type: "string" },
│ │             findEnabled: { type: "boolean" },
│ │             id: { type: "integer" },
│ │             label: { type: "string" },
│ │             mode: { type: "string" },
│ │             noWrap: { type: "boolean" },
│ │             properties: { type: "object", additionalProperties: true },
│ │             required: { type: "boolean" },
│ │             unique: { type: "boolean" },
│ │           },
│ │         };
│ │     
│ │         // Add Table definition
│ │         spec.definitions.Table = {
│ │           type: "object",
│ │           properties: {
│ │             id: { type: "string", description: "Unique identifier for the table" },
│ │             name: { type: "string", description: "Name of the table" },
│ │             created: {
│ │               type: "string",
│ │               format: "date-time",
│ │               description: "Creation timestamp",
│ │             },
│ │             updated: {
│ │               type: "string",
│ │               format: "date-time",
│ │               description: "Last updated timestamp",
│ │             },
│ │             description: { type: "string", description: "Table description" },
│ │             keyFieldId: { type: "integer", description: "ID of the key field" },
│ │             nextFieldId: {
│ │               type: "integer",
│ │               description: "Next available field ID",
│ │             },
│ │             nextRecordId: {
│ │               type: "integer",
│ │               description: "Next available record ID",
│ │             },
│ │             // Add more properties based on QuickBase API docs
│ │           },
│ │           required: ["id", "name"],
│ │         };
│ │     
│ │         // Add App definition (example)
│ │         spec.definitions.App = {
│ │           type: "object",
│ │           properties: {
│ │             id: { type: "string", description: "Unique identifier for the app" },
│ │             name: { type: "string", description: "Name of the app" },
│ │             created: { type: "string", format: "date-time" },
│ │             updated: { type: "string", format: "date-time" },
│ │             description: { type: "string" },
│ │             // Add more properties as needed
│ │           },
│ │           required: ["id", "name"],
│ │         };
│ │     
│ │         // Add more definitions as needed (e.g., Record, ReportData)...
│ │     
│ │         console.log("Removing unexpected top-level attributes...");
│ │         delete spec.operations;
│ │         delete spec.groups;
│ │         delete spec.components;
│ │     
│ │         console.log(`Writing fixed spec to ${path.basename(outputFile)}...`);
│ │         await fs.writeFile(outputFile, JSON.stringify(spec, null, 2), "utf8");
│ │         console.log("Spec fixed successfully!");
│ │       } catch (error) {
│ │         console.error("Failed to fix spec:", error);
│ │         process.exit(1);
│ │       }
│ │     }
│ │     
│ │     fixQuickBaseSpec();
│ │     
│ ├─ openapi-generator-cli.jar
│ ├─ quickbase-fixed.json
│ └─ regenerate-client.ts
│     Contents:
│       #!/usr/bin/env node
│       import { execSync } from "child_process";
│       import { existsSync, readFileSync, writeFileSync, readdirSync } from "fs";
│       import { join, dirname, basename } from "path";
│       import { fileURLToPath } from "url";
│       
│       const __dirname = dirname(fileURLToPath(import.meta.url));
│       const CODEGEN_DIR = __dirname;
│       const SPEC_FILE = join(CODEGEN_DIR, "quickbase-fixed.json");
│       const GENERATED_DIR = join(__dirname, "..", "src", "generated");
│       const BACKUP_DIR = join(__dirname, "..", "src", "generated-old");
│       const JAR_PATH = join(CODEGEN_DIR, "openapi-generator-cli.jar");
│       
│       function backupGeneratedDir(): void {
│         console.log("Backing up existing src/generated/...");
│         if (existsSync(GENERATED_DIR)) {
│           if (existsSync(BACKUP_DIR))
│             execSync(`rm -rf ${BACKUP_DIR}`, { stdio: "inherit" });
│           execSync(`mv ${GENERATED_DIR} ${BACKUP_DIR}`, { stdio: "inherit" });
│           console.log(`Moved src/generated/ to ${basename(BACKUP_DIR)}`);
│         } else {
│           console.log("No existing src/generated/ to backup.");
│         }
│       }
│       
│       function generateClient(): void {
│         if (!existsSync(SPEC_FILE)) {
│           console.error(
│             `Fixed spec file ${basename(SPEC_FILE)} not found. Run 'npm run fix-spec' first.`
│           );
│           process.exit(1);
│         }
│         console.log("Generating TypeScript client with Fetch API using JAR...");
│         execSync(
│           `java -jar ${JAR_PATH} generate \
│             -i ${SPEC_FILE} \
│             -g typescript-fetch \
│             -o ${GENERATED_DIR} \
│             --skip-validate-spec \
│             --additional-properties=supportsES6=true,modelPropertyNaming=original,typescriptThreePlus=true,apiPackage=generated.api,modelPackage=generated.model`,
│           { stdio: "inherit" }
│         );
│         console.log(`Client generated successfully in ${GENERATED_DIR}`);
│       }
│       
│       function fixImports(): void {
│         console.log("Fixing ESM imports in generated files...");
│         const files = readdirSync(GENERATED_DIR).filter((f: string) =>
│           f.endsWith(".ts")
│         );
│         for (const file of files) {
│           const filePath = join(GENERATED_DIR, file);
│           let content = readFileSync(filePath, "utf8");
│           content = content.replace(/(from\s+['"])(\.\/[^'"]+)(['"])/g, "$1$2.js$3");
│           writeFileSync(filePath, content, "utf8");
│         }
│         console.log("Imports fixed.");
│       }
│       
│       function main(): void {
│         try {
│           execSync("java -version", { stdio: "ignore" });
│         } catch (error) {
│           console.error(
│             "Java is not installed or not in PATH. Install Java (e.g., OpenJDK 17)."
│           );
│           process.exit(1);
│         }
│         backupGeneratedDir();
│         generateClient();
│         fixImports();
│       }
│       
│       main();
│       
├─ openapitools.json
├─ package-lock.json
├─ package.json
│   Contents:
│     {
│       "name": "quickbase-js",
│       "version": "1.0.0",
│       "description": "",
│       "type": "module",
│       "scripts": {
│         "fix-spec": "node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' code-generation/fix-spec.ts",
│         "regenerate": "node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' code-generation/regenerate-client.ts",
│         "aiupdate": "node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' aiupdate.ts",
│         "prepublishOnly": "npm run fix-spec && npm run regenerate && npm run build",
│         "generate-types": "node --no-warnings --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' src/generate-types.ts",
│         "build": "tsc",
│         "buildwithtypes": "npm run generate-types && tsc",
│         "test": "node dist/test.js"
│       },
│       "main": "dist/QuickBaseClient.js",
│       "browser": "dist/quickbase-client.browser.min.js",
│       "types": "dist/QuickBaseClient.d.ts",
│       "keywords": [
│         "quickbase",
│         "api",
│         "client",
│         "javascript",
│         "typescript"
│       ],
│       "author": "Drew Bradford",
│       "license": "ISC",
│       "dependencies": {
│         "typescript": "^5.8.2"
│       },
│       "devDependencies": {
│         "@openapitools/openapi-generator-cli": "^2.17.0",
│         "@types/node": "^22.13.9",
│         "@types/react": "^19.0.10",
│         "glob": "^10.4.5",
│         "prettier": "^3.5.3",
│         "react": "^19.0.0",
│         "ts-node": "^10.9.2"
│       }
│     }
│     
├─ specs/
│ └─ QuickBase_RESTful_API_2025-03-04T06_22_39.725Z.json
├─ src/
│ ├─ QuickbaseClient.ts
│ │   Contents:
│ │     import { Configuration, HTTPHeaders } from "./generated/runtime";
│ │     import { FieldsApi } from "./generated/apis/FieldsApi";
│ │     import { TablesApi } from "./generated/apis/TablesApi";
│ │     import { AppsApi } from "./generated/apis/AppsApi";
│ │     import { Field } from "./generated/models/Field";
│ │     import { GetApp200Response } from "./generated/models/GetApp200Response";
│ │     import { CreateField200Response } from "./generated/models/CreateField200Response";
│ │     import { DeleteFields200Response } from "./generated/models/DeleteFields200Response";
│ │     import { Upsert200Response } from "./generated/models/Upsert200Response";
│ │     import { Table } from "./generated/models/Table";
│ │     // Add this if Table type is missing; we'll fix spec later
│ │     interface Table {
│ │       id: string;
│ │       name: string;
│ │       // Add more properties as needed
│ │     }
│ │     
│ │     export interface QuickbaseMethods {
│ │       getFields(params: {
│ │         tableId: string;
│ │         includeFieldPerms?: boolean;
│ │       }): Promise<Field[]>;
│ │       getTable(params: { appId: string; tableId: string }): Promise<Table>; // Temporary until spec fix
│ │       getApp(params: { appId: string }): Promise<GetApp200Response>;
│ │       createField(params: {
│ │         tableId: string;
│ │         generated: any;
│ │       }): Promise<CreateField200Response>;
│ │       deleteFields(params: {
│ │         tableId: string;
│ │         generated: any;
│ │       }): Promise<DeleteFields200Response>;
│ │       upsert(params: { generated: any }): Promise<Upsert200Response>;
│ │     }
│ │     
│ │     interface QuickbaseConfig {
│ │       realm: string;
│ │       userToken?: string;
│ │       tempToken?: string;
│ │       defaultDbid?: string;
│ │     }
│ │     
│ │     type ApiMethod = (...args: unknown[]) => Promise<unknown>;
│ │     type MethodMap = Record<
│ │       string,
│ │       {
│ │         api: FieldsApi | TablesApi | AppsApi;
│ │         method: ApiMethod;
│ │         paramMap: string[];
│ │       }
│ │     >;
│ │     
│ │     const simplifyName = (name: string): string =>
│ │       name
│ │         .replace(/ById$/, "")
│ │         .replace(/Api$/, "")
│ │         .replace(/^(\w)/, (_, c) => c.toLowerCase());
│ │     
│ │     export function createQuickbaseClient(
│ │       config: QuickbaseConfig
│ │     ): QuickbaseClient {
│ │       const token = config.tempToken || config.userToken || ""; // Default to empty string
│ │       const baseUrl = `https://api.quickbase.com/v1`;
│ │       const headers: HTTPHeaders = {
│ │         Authorization: `QB-USER-TOKEN ${token}`,
│ │         "QB-Realm-Hostname": `${config.realm}.quickbase.com`,
│ │         "Content-Type": "application/json",
│ │       };
│ │     
│ │       const configuration = new Configuration({
│ │         basePath: baseUrl,
│ │         headers,
│ │         fetchApi: typeof window !== "undefined" ? window.fetch.bind(window) : fetch,
│ │       });
│ │     
│ │       const apis: Record<string, FieldsApi | TablesApi | AppsApi> = {
│ │         fields: new FieldsApi(configuration),
│ │         tables: new TablesApi(configuration),
│ │         apps: new AppsApi(configuration),
│ │       };
│ │     
│ │       const methodMap = buildMethodMap();
│ │     
│ │       function buildMethodMap(): MethodMap {
│ │         const methodMap: MethodMap = {};
│ │         for (const [apiName, api] of Object.entries(apis)) {
│ │           const methods = Object.keys(api).filter(
│ │             (m) =>
│ │               typeof api[m as keyof typeof api] === "function" && !m.startsWith("_")
│ │           );
│ │           for (const methodName of methods) {
│ │             const friendlyName = simplifyName(methodName);
│ │             const paramNames = getParamNames(
│ │               api[methodName as keyof typeof api] as ApiMethod
│ │             ).filter((name) => name !== "options");
│ │             methodMap[friendlyName] = {
│ │               api,
│ │               method: api[methodName as keyof typeof api] as ApiMethod,
│ │               paramMap: paramNames,
│ │             };
│ │           }
│ │         }
│ │         return methodMap;
│ │       }
│ │     
│ │       function getParamNames(fn: ApiMethod): string[] {
│ │         const fnStr = fn.toString();
│ │         const paramStr = fnStr.slice(fnStr.indexOf("(") + 1, fnStr.indexOf(")"));
│ │         return paramStr
│ │           .split(",")
│ │           .map((p) => p.trim().split("=")[0].trim())
│ │           .filter((p) => p && !p.match(/^\{/));
│ │       }
│ │     
│ │       async function invokeMethod<K extends keyof QuickbaseMethods>(
│ │         methodName: K,
│ │         params: Parameters<QuickbaseMethods[K]>[0]
│ │       ): Promise<ReturnType<QuickbaseMethods[K]>> {
│ │         const methodInfo = methodMap[methodName];
│ │         if (!methodInfo) throw new Error(`Method ${methodName} not found`);
│ │         const { method, paramMap } = methodInfo;
│ │     
│ │         const userParams: Record<string, unknown> = { ...params };
│ │         const args: unknown[] = [];
│ │         paramMap.forEach((param) => {
│ │           args.push(userParams[param] ?? undefined);
│ │         });
│ │     
│ │         const response = await (method(...args) as Promise<Response>);
│ │         return response.json() as Promise<ReturnType<QuickbaseMethods[K]>>;
│ │       }
│ │     
│ │       return new Proxy<QuickbaseClient>({} as QuickbaseClient, {
│ │         get(_target, prop: string) {
│ │           if (prop in methodMap) {
│ │             return (
│ │               params: Parameters<QuickbaseMethods[keyof QuickbaseMethods]>[0]
│ │             ) => invokeMethod(prop as keyof QuickbaseMethods, params || {});
│ │           }
│ │           return undefined;
│ │         },
│ │       });
│ │     }
│ │     
│ │     export type QuickbaseClient = QuickbaseMethods;
│ │     
│ ├─ generated/
│ │ ├─ .openapi-generator/
│ │ │ ├─ FILES
│ │ │ └─ VERSION
│ │ ├─ .openapi-generator-ignore
│ │ ├─ apis/
│ │ │ ├─ AppsApi.ts
│ │ │ ├─ AuditApi.ts
│ │ │ ├─ AuthApi.ts
│ │ │ ├─ DocumentTemplatesApi.ts
│ │ │ ├─ FieldsApi.ts
│ │ │ ├─ FilesApi.ts
│ │ │ ├─ FormulasApi.ts
│ │ │ ├─ PlatformAnalyticsApi.ts
│ │ │ ├─ RecordsApi.ts
│ │ │ ├─ ReportsApi.ts
│ │ │ ├─ SolutionsApi.ts
│ │ │ ├─ TablesApi.ts
│ │ │ ├─ UserTokenApi.ts
│ │ │ ├─ UsersApi.ts
│ │ │ └─ index.ts
│ │ ├─ index.ts
│ │ ├─ models/
│ │ │ ├─ AddMembersToGroup200Response.ts
│ │ │ ├─ AddSubgroupsToGroup200Response.ts
│ │ │ ├─ App.ts
│ │ │ ├─ Audit200Response.ts
│ │ │ ├─ Audit202Response.ts
│ │ │ ├─ AuditRequest.ts
│ │ │ ├─ CloneUserToken200Response.ts
│ │ │ ├─ CloneUserTokenRequest.ts
│ │ │ ├─ CopyApp200Response.ts
│ │ │ ├─ CopyAppRequest.ts
│ │ │ ├─ CreateApp200Response.ts
│ │ │ ├─ CreateAppRequest.ts
│ │ │ ├─ CreateField200Response.ts
│ │ │ ├─ CreateFieldRequest.ts
│ │ │ ├─ CreateRelationship200Response.ts
│ │ │ ├─ CreateRelationshipRequest.ts
│ │ │ ├─ CreateTable200Response.ts
│ │ │ ├─ CreateTableRequest.ts
│ │ │ ├─ DeactivateUserToken200Response.ts
│ │ │ ├─ DeleteApp200Response.ts
│ │ │ ├─ DeleteAppRequest.ts
│ │ │ ├─ DeleteFields200Response.ts
│ │ │ ├─ DeleteFieldsRequest.ts
│ │ │ ├─ DeleteFile200Response.ts
│ │ │ ├─ DeleteRecords200Response.ts
│ │ │ ├─ DeleteRecordsRequest.ts
│ │ │ ├─ DeleteRelationship200Response.ts
│ │ │ ├─ DeleteTable200Response.ts
│ │ │ ├─ DenyUsers200Response.ts
│ │ │ ├─ ExchangeSsoToken200Response.ts
│ │ │ ├─ ExchangeSsoTokenRequest.ts
│ │ │ ├─ Field.ts
│ │ │ ├─ GenerateDocument200Response.ts
│ │ │ ├─ GetRelationships200Response.ts
│ │ │ ├─ GetReport200Response.ts
│ │ │ ├─ GetTempTokenDBID200Response.ts
│ │ │ ├─ GetUsers200Response.ts
│ │ │ ├─ GetUsersRequest.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200Response.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseMetadata.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInner.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseTotals.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseWhereInner.ts
│ │ │ ├─ PlatformAnalyticEventSummariesRequest.ts
│ │ │ ├─ PlatformAnalyticEventSummariesRequestWhereInner.ts
│ │ │ ├─ PlatformAnalyticReads200Response.ts
│ │ │ ├─ RemoveMembersFromGroup200Response.ts
│ │ │ ├─ RemoveSubgroupsFromGroup200Response.ts
│ │ │ ├─ RunFormula200Response.ts
│ │ │ ├─ RunFormulaRequest.ts
│ │ │ ├─ RunQuery200Response.ts
│ │ │ ├─ RunQueryRequest.ts
│ │ │ ├─ RunReport200Response.ts
│ │ │ ├─ Table.ts
│ │ │ │   Contents:
│ │ │ │     /* tslint:disable */
│ │ │ │     /* eslint-disable */
│ │ │ │     /**
│ │ │ │      * Quick Base API
│ │ │ │      * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
│ │ │ │      *
│ │ │ │      * The version of the OpenAPI document: 1.0.0
│ │ │ │      * 
│ │ │ │      *
│ │ │ │      * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
│ │ │ │      * https://openapi-generator.tech
│ │ │ │      * Do not edit the class manually.
│ │ │ │      */
│ │ │ │     
│ │ │ │     import { mapValues } from '../runtime';
│ │ │ │     /**
│ │ │ │      * 
│ │ │ │      * @export
│ │ │ │      * @interface Table
│ │ │ │      */
│ │ │ │     export interface Table {
│ │ │ │         /**
│ │ │ │          * Unique identifier for the table
│ │ │ │          * @type {string}
│ │ │ │          * @memberof Table
│ │ │ │          */
│ │ │ │         id: string;
│ │ │ │         /**
│ │ │ │          * Name of the table
│ │ │ │          * @type {string}
│ │ │ │          * @memberof Table
│ │ │ │          */
│ │ │ │         name: string;
│ │ │ │         /**
│ │ │ │          * Creation timestamp
│ │ │ │          * @type {Date}
│ │ │ │          * @memberof Table
│ │ │ │          */
│ │ │ │         created?: Date;
│ │ │ │         /**
│ │ │ │          * Last updated timestamp
│ │ │ │          * @type {Date}
│ │ │ │          * @memberof Table
│ │ │ │          */
│ │ │ │         updated?: Date;
│ │ │ │         /**
│ │ │ │          * Table description
│ │ │ │          * @type {string}
│ │ │ │          * @memberof Table
│ │ │ │          */
│ │ │ │         description?: string;
│ │ │ │         /**
│ │ │ │          * ID of the key field
│ │ │ │          * @type {number}
│ │ │ │          * @memberof Table
│ │ │ │          */
│ │ │ │         keyFieldId?: number;
│ │ │ │         /**
│ │ │ │          * Next available field ID
│ │ │ │          * @type {number}
│ │ │ │          * @memberof Table
│ │ │ │          */
│ │ │ │         nextFieldId?: number;
│ │ │ │         /**
│ │ │ │          * Next available record ID
│ │ │ │          * @type {number}
│ │ │ │          * @memberof Table
│ │ │ │          */
│ │ │ │         nextRecordId?: number;
│ │ │ │     }
│ │ │ │     
│ │ │ │     /**
│ │ │ │      * Check if a given object implements the Table interface.
│ │ │ │      */
│ │ │ │     export function instanceOfTable(value: object): value is Table {
│ │ │ │         if (!('id' in value) || value['id'] === undefined) return false;
│ │ │ │         if (!('name' in value) || value['name'] === undefined) return false;
│ │ │ │         return true;
│ │ │ │     }
│ │ │ │     
│ │ │ │     export function TableFromJSON(json: any): Table {
│ │ │ │         return TableFromJSONTyped(json, false);
│ │ │ │     }
│ │ │ │     
│ │ │ │     export function TableFromJSONTyped(json: any, ignoreDiscriminator: boolean): Table {
│ │ │ │         if (json == null) {
│ │ │ │             return json;
│ │ │ │         }
│ │ │ │         return {
│ │ │ │             
│ │ │ │             'id': json['id'],
│ │ │ │             'name': json['name'],
│ │ │ │             'created': json['created'] == null ? undefined : (new Date(json['created'])),
│ │ │ │             'updated': json['updated'] == null ? undefined : (new Date(json['updated'])),
│ │ │ │             'description': json['description'] == null ? undefined : json['description'],
│ │ │ │             'keyFieldId': json['keyFieldId'] == null ? undefined : json['keyFieldId'],
│ │ │ │             'nextFieldId': json['nextFieldId'] == null ? undefined : json['nextFieldId'],
│ │ │ │             'nextRecordId': json['nextRecordId'] == null ? undefined : json['nextRecordId'],
│ │ │ │         };
│ │ │ │     }
│ │ │ │     
│ │ │ │     export function TableToJSON(json: any): Table {
│ │ │ │         return TableToJSONTyped(json, false);
│ │ │ │     }
│ │ │ │     
│ │ │ │     export function TableToJSONTyped(value?: Table | null, ignoreDiscriminator: boolean = false): any {
│ │ │ │         if (value == null) {
│ │ │ │             return value;
│ │ │ │         }
│ │ │ │     
│ │ │ │         return {
│ │ │ │             
│ │ │ │             'id': value['id'],
│ │ │ │             'name': value['name'],
│ │ │ │             'created': value['created'] == null ? undefined : ((value['created']).toISOString()),
│ │ │ │             'updated': value['updated'] == null ? undefined : ((value['updated']).toISOString()),
│ │ │ │             'description': value['description'],
│ │ │ │             'keyFieldId': value['keyFieldId'],
│ │ │ │             'nextFieldId': value['nextFieldId'],
│ │ │ │             'nextRecordId': value['nextRecordId'],
│ │ │ │         };
│ │ │ │     }
│ │ │ │     
│ │ │ │     
│ │ │ ├─ TransferUserToken200Response.ts
│ │ │ ├─ TransferUserTokenRequest.ts
│ │ │ ├─ UndenyUsers200Response.ts
│ │ │ ├─ UpdateApp200Response.ts
│ │ │ ├─ UpdateAppRequest.ts
│ │ │ ├─ UpdateFieldRequest.ts
│ │ │ ├─ UpdateRelationshipRequest.ts
│ │ │ ├─ UpdateTableRequest.ts
│ │ │ ├─ Upsert200Response.ts
│ │ │ ├─ Upsert207Response.ts
│ │ │ ├─ Upsert400Response.ts
│ │ │ ├─ UpsertRequest.ts
│ │ │ └─ index.ts
│ │ └─ runtime.ts
│ ├─ generated-old/
│ │ ├─ .openapi-generator/
│ │ │ ├─ FILES
│ │ │ └─ VERSION
│ │ ├─ .openapi-generator-ignore
│ │ ├─ apis/
│ │ │ ├─ AppsApi.ts
│ │ │ ├─ AuditApi.ts
│ │ │ ├─ AuthApi.ts
│ │ │ ├─ DocumentTemplatesApi.ts
│ │ │ ├─ FieldsApi.ts
│ │ │ ├─ FilesApi.ts
│ │ │ ├─ FormulasApi.ts
│ │ │ ├─ PlatformAnalyticsApi.ts
│ │ │ ├─ RecordsApi.ts
│ │ │ ├─ ReportsApi.ts
│ │ │ ├─ SolutionsApi.ts
│ │ │ ├─ TablesApi.ts
│ │ │ ├─ UserTokenApi.ts
│ │ │ ├─ UsersApi.ts
│ │ │ └─ index.ts
│ │ ├─ index.ts
│ │ ├─ models/
│ │ │ ├─ AddMembersToGroup200Response.ts
│ │ │ ├─ AddSubgroupsToGroup200Response.ts
│ │ │ ├─ Audit200Response.ts
│ │ │ ├─ Audit202Response.ts
│ │ │ ├─ AuditRequest.ts
│ │ │ ├─ CloneUserToken200Response.ts
│ │ │ ├─ CloneUserTokenRequest.ts
│ │ │ ├─ CopyApp200Response.ts
│ │ │ ├─ CopyAppRequest.ts
│ │ │ ├─ CreateApp200Response.ts
│ │ │ ├─ CreateAppRequest.ts
│ │ │ ├─ CreateField200Response.ts
│ │ │ ├─ CreateFieldRequest.ts
│ │ │ ├─ CreateRelationship200Response.ts
│ │ │ ├─ CreateRelationshipRequest.ts
│ │ │ ├─ CreateTable200Response.ts
│ │ │ ├─ CreateTableRequest.ts
│ │ │ ├─ DeactivateUserToken200Response.ts
│ │ │ ├─ DeleteApp200Response.ts
│ │ │ ├─ DeleteAppRequest.ts
│ │ │ ├─ DeleteFields200Response.ts
│ │ │ ├─ DeleteFieldsRequest.ts
│ │ │ ├─ DeleteFile200Response.ts
│ │ │ ├─ DeleteRecords200Response.ts
│ │ │ ├─ DeleteRecordsRequest.ts
│ │ │ ├─ DeleteRelationship200Response.ts
│ │ │ ├─ DeleteTable200Response.ts
│ │ │ ├─ DenyUsers200Response.ts
│ │ │ ├─ ExchangeSsoToken200Response.ts
│ │ │ ├─ ExchangeSsoTokenRequest.ts
│ │ │ ├─ Field.ts
│ │ │ ├─ GenerateDocument200Response.ts
│ │ │ ├─ GetApp200Response.ts
│ │ │ ├─ GetRelationships200Response.ts
│ │ │ ├─ GetReport200Response.ts
│ │ │ ├─ GetTempTokenDBID200Response.ts
│ │ │ ├─ GetUsers200Response.ts
│ │ │ ├─ GetUsersRequest.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200Response.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseMetadata.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInner.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseTotals.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseWhereInner.ts
│ │ │ ├─ PlatformAnalyticEventSummariesRequest.ts
│ │ │ ├─ PlatformAnalyticEventSummariesRequestWhereInner.ts
│ │ │ ├─ PlatformAnalyticReads200Response.ts
│ │ │ ├─ RemoveMembersFromGroup200Response.ts
│ │ │ ├─ RemoveSubgroupsFromGroup200Response.ts
│ │ │ ├─ RunFormula200Response.ts
│ │ │ ├─ RunFormulaRequest.ts
│ │ │ ├─ RunQuery200Response.ts
│ │ │ ├─ RunQueryRequest.ts
│ │ │ ├─ RunReport200Response.ts
│ │ │ ├─ TransferUserToken200Response.ts
│ │ │ ├─ TransferUserTokenRequest.ts
│ │ │ ├─ UndenyUsers200Response.ts
│ │ │ ├─ UpdateAppRequest.ts
│ │ │ ├─ UpdateFieldRequest.ts
│ │ │ ├─ UpdateRelationshipRequest.ts
│ │ │ ├─ UpdateTableRequest.ts
│ │ │ ├─ Upsert200Response.ts
│ │ │ ├─ Upsert207Response.ts
│ │ │ ├─ Upsert400Response.ts
│ │ │ ├─ UpsertRequest.ts
│ │ │ └─ index.ts
│ │ └─ runtime.ts
│ ├─ index.ts
│ ├─ test-esm.ts
│ └─ test.ts
├─ test-output.txt
├─ tsconfig.json
│   Contents:
│     {
│       "compilerOptions": {
│         "target": "ESNext",
│         "module": "ESNext",
│         "moduleResolution": "Bundler",
│         "outDir": "dist",
│         "rootDir": ".", // Include root-level files
│         "esModuleInterop": true,
│         "forceConsistentCasingInFileNames": true,
│         "strict": true,
│         "skipLibCheck": true,
│         "declaration": true,
│         "types": ["node"],
│         "noEmit": false,
│         "resolveJsonModule": true,
│         "isolatedModules": false,
│         "lib": ["ESNext", "DOM"]
│       },
│       "include": [
│         "src/**/*",
│         "code-generation/**/*",
│         "aiupdate.ts",
│         "types/QuickbaseClient.d.ts"
│       ],
│       "exclude": ["node_modules", "dist", "src/generated-old"]
│     }
│     
├─ tsconfig.json.bak
└─ types/
  └─ QuickbaseClient.d.ts
      Contents:
        // Auto-generated type declarations for QuickbaseClient
        
        export interface QuickbaseMethods {
          copyApp(params: { appId: string, userAgent?: string, generated?: any }): Promise<any>;
          createApp(params: { userAgent?: string, generated?: any }): Promise<any>;
          deleteApp(params: { appId: string, userAgent?: string, generated?: any }): Promise<any>;
          getApp(params: { appId: string, userAgent?: string }): Promise<any>;
          getAppEvents(params: { appId: string, userAgent?: string }): Promise<any>;
          updateApp(params: { appId: string, userAgent?: string, generated?: any }): Promise<any>;
          createField(params: { tableId: string, userAgent?: string, generated?: any }): Promise<any>;
          deleteFields(params: { tableId: string, userAgent?: string, generated?: any }): Promise<any>;
          getField(params: { tableId: string, fieldId: string, includeFieldPerms?: boolean, userAgent?: string }): Promise<any>;
          getFieldUsage(params: { tableId: string, fieldId: string, userAgent?: string }): Promise<any>;
          getFields(params: { tableId: string, includeFieldPerms?: boolean, userAgent?: string }): Promise<any>;
          getFieldsUsage(params: { tableId: string, skip: number, top: number, userAgent?: string }): Promise<any>;
          updateField(params: { tableId: string, fieldId: string, userAgent?: string, generated?: any }): Promise<any>;
          deleteRecords(params: { userAgent?: string, generated?: any }): Promise<any>;
          runQuery(params: { userAgent?: string, generated?: any }): Promise<any>;
          upsert(params: { userAgent?: string, generated?: any }): Promise<any>;
          createRelationship(params: { tableId: string, userAgent?: string, generated?: any }): Promise<any>;
          createTable(params: { appId: string, userAgent?: string, generated?: any }): Promise<any>;
          deleteRelationship(params: { tableId: string, relationshipId: string, userAgent?: string }): Promise<any>;
          deleteTable(params: { appId: string, tableId: string, userAgent?: string }): Promise<any>;
          getAppTables(params: { appId: string, userAgent?: string }): Promise<any>;
          getRelationships(params: { tableId: string, skip: number, userAgent?: string }): Promise<any>;
          getTable(params: { appId: string, tableId: string, userAgent?: string }): Promise<any>;
          updateRelationship(params: { tableId: string, relationshipId: string, userAgent?: string, generated?: any }): Promise<any>;
          updateTable(params: { appId: string, tableId: string, userAgent?: string, generated?: any }): Promise<any>;
        }
        
        export class QuickbaseClient implements QuickbaseMethods {}
        

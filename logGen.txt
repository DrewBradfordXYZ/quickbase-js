[quickbase-js] Tree - 3/6/2025
Root: /home/drew/Projects/quickbase-js

Project Goals:
- Implement a QuickBase API client in TypeScript.
- Generate client methods from the QuickBase RESTful API spec.
- Provide a simple and intuitive interface for interacting with QuickBase.
- This library should not have to manually update the client methods when the QuickBase API changes.
- Generate ergonomic client methods from the QuickBase RESTful API spec that do not require manual updates.
- Support both Node.js and browser environments.
- The intent is to use this in JS frameworks like React, Vue, and Angular.
- Use OpenAPI to generate the TypeScript types and methods.
- Use the latest ES6+ features and TypeScript features.


├─ .env
├─ .gitignore
├─ LICENSE
├─ README.md
├─ build.js
├─ dist/
│ ├─ quickbaseClient.d.ts
│ ├─ quickbaseClient.js
│ └─ quickbaseClient.js.map
├─ examples/
│ ├─ react.js
│ └─ vanillajs.html
├─ logGen.txt
├─ openapitools.json
├─ package-lock.json
├─ package.json
│   Contents:
│     {
│       "name": "quickbase-js",
│       "version": "1.0.0",
│       "description": "QuickBase JavaScript client for frameworks and vanilla JS",
│       "module": "dist/quickbaseClient.js",
│       "types": "dist/quickbaseClient.d.ts",
│       "type": "module",
│       "exports": {
│         ".": {
│           "import": "./dist/quickbaseClient.js",
│           "types": "./dist/quickbaseClient.d.ts"
│         }
│       },
│       "scripts": {
│         "fix-spec": "node --loader ts-node/esm src/code-generation/fix-spec-main.ts",
│         "fix-spec-old": "node --loader ts-node/esm src/code-generation/fix-spec.ts",
│         "regenerate": "node --loader ts-node/esm src/code-generation/regenerate-client.ts",
│         "generate-unified": "node --loader ts-node/esm src/code-generation/generate-unified-interface.ts",
│         "log-gen": "node --loader ts-node/esm src/log-gen.ts",
│         "build": "rollup -c",
│         "build:prod": "rm -rf dist/* && NODE_ENV=production rollup -c",
│         "test": "vitest run --environment jsdom tests/quickbaseClient.test.ts",
│         "test:integration": "vitest run --environment jsdom tests/integration.test.ts",
│         "test:all": "vitest run --environment jsdom tests/quickbaseClient.test.ts tests/integration.test.ts"
│       },
│       "dependencies": {
│         "typescript": "^5.8.2"
│       },
│       "devDependencies": {
│         "@rollup/plugin-commonjs": "^28.0.3",
│         "@rollup/plugin-node-resolve": "^16.0.0",
│         "@rollup/plugin-terser": "^0.4.4",
│         "@rollup/plugin-typescript": "^12.1.2",
│         "@types/node": "^20.11.20",
│         "dotenv": "^16.4.7",
│         "glob": "^11.0.1",
│         "jsdom": "^24.1.3",
│         "node-fetch": "^3.3.2",
│         "openapi-types": "^12.1.3",
│         "rollup": "^4.34.9",
│         "rollup-plugin-dts": "^6.1.1",
│         "ts-morph": "^23.0.0",
│         "ts-node": "^10.9.2",
│         "tslib": "^2.8.1",
│         "vitest": "^1.6.0"
│       }
│     }
│     
├─ rollup.config.js
│   Contents:
│     import typescript from "@rollup/plugin-typescript";
│     import terser from "@rollup/plugin-terser";
│     import nodeResolve from "@rollup/plugin-node-resolve";
│     import commonjs from "@rollup/plugin-commonjs";
│     import dts from "rollup-plugin-dts";
│     
│     const isProd = process.env.NODE_ENV === "production";
│     
│     export default [
│       {
│         input: "src/quickbaseClient.ts",
│         output: {
│           dir: "dist", // Switch to dir for multiple chunks
│           format: "esm",
│           sourcemap: true,
│           compact: isProd,
│           entryFileNames: "quickbaseClient.js", // Maintain output file name
│         },
│         external: [
│           "node:http",
│           "node:https",
│           "node:zlib",
│           "node:stream",
│           "node:buffer",
│           "node:util",
│           "node:url",
│           "node:net",
│           "node:fs",
│           "node:path",
│           "node-fetch", // Externalize node-fetch
│         ],
│         plugins: [
│           nodeResolve({ preferBuiltins: true }), // Use Node.js built-ins
│           commonjs(), // Handle CommonJS modules like node-fetch
│           typescript({
│             tsconfig: "./tsconfig.build.json",
│             declaration: false, // Keep this
│           }),
│           isProd && terser(),
│         ],
│       },
│       {
│         input: "src/quickbaseClient.ts",
│         output: {
│           file: "dist/quickbaseClient.d.ts", // Keep as file since dts generates a single file
│           format: "esm",
│         },
│         plugins: [
│           dts({
│             tsconfig: "./tsconfig.build.json",
│           }),
│         ],
│       },
│     ].map((config) => ({
│       ...config,
│       onwarn(warning, warn) {
│         if (
│           warning.code === "PLUGIN_WARNING" &&
│           warning.plugin === "typescript" &&
│           warning.message.includes("TS5096")
│         ) {
│           return; // Suppress TS5096
│         }
│         warn(warning);
│       },
│     }));
│     
├─ src/
│ ├─ code-generation/
│ │ ├─ fix-spec-definitions.ts
│ │ │   Contents:
│ │ │     export const definitions = {
│ │ │       Field: {
│ │ │         type: "object",
│ │ │         properties: {
│ │ │           id: { type: "integer" },
│ │ │           label: { type: "string" },
│ │ │           fieldType: { type: "string" },
│ │ │           appearsByDefault: { type: "boolean" },
│ │ │           audited: { type: "boolean" },
│ │ │           bold: { type: "boolean" },
│ │ │           doesDataCopy: { type: "boolean" },
│ │ │           fieldHelp: { type: "string" },
│ │ │           findEnabled: { type: "boolean" },
│ │ │           mode: { type: "string" },
│ │ │           noWrap: { type: "boolean" },
│ │ │           required: { type: "boolean" },
│ │ │           unique: { type: "boolean" },
│ │ │           addToForms: { type: "boolean" },
│ │ │           permissions: {
│ │ │             type: "array",
│ │ │             items: {
│ │ │               type: "object",
│ │ │               properties: {
│ │ │                 permissionType: { type: "string" },
│ │ │                 role: { type: "string" },
│ │ │                 roleId: { type: "integer" },
│ │ │               },
│ │ │               required: ["permissionType", "role", "roleId"],
│ │ │             },
│ │ │           },
│ │ │           properties: {
│ │ │             type: "object",
│ │ │             properties: {
│ │ │               primaryKey: { type: "boolean" },
│ │ │               foreignKey: { type: "boolean" },
│ │ │               formula: { type: "string" },
│ │ │               defaultValue: { type: "string" },
│ │ │               carryChoices: { type: "boolean" },
│ │ │               allowNewChoices: { type: "boolean" },
│ │ │               sortAsGiven: { type: "boolean" },
│ │ │               numLines: { type: "integer" },
│ │ │               maxLength: { type: "integer" },
│ │ │               appendOnly: { type: "boolean" },
│ │ │               allowHTML: { type: "boolean" },
│ │ │               allowMentions: { type: "boolean" },
│ │ │               numberFormat: { type: "integer" },
│ │ │               decimalPlaces: { type: "integer" },
│ │ │               doesAverage: { type: "boolean" },
│ │ │               doesTotal: { type: "boolean" },
│ │ │               blankIsZero: { type: "boolean" },
│ │ │               commaStart: { type: "integer" },
│ │ │               defaultToday: { type: "boolean" },
│ │ │               displayDayOfWeek: { type: "boolean" },
│ │ │               displayMonth: { type: "string" },
│ │ │               displayRelative: { type: "boolean" },
│ │ │               displayTime: { type: "boolean" },
│ │ │               displayTimezone: { type: "boolean" },
│ │ │               defaultKind: { type: "string" },
│ │ │               displayUser: { type: "string" },
│ │ │             },
│ │ │           },
│ │ │         },
│ │ │         required: ["id", "label", "fieldType"],
│ │ │       },
│ │ │       Table: {
│ │ │         type: "object",
│ │ │         properties: { id: { type: "string" }, name: { type: "string" } },
│ │ │         required: ["id", "name"],
│ │ │       },
│ │ │       App: {
│ │ │         type: "object",
│ │ │         properties: {
│ │ │           id: { type: "string" },
│ │ │           name: { type: "string" },
│ │ │           created: { type: "string", format: "date-time" },
│ │ │           updated: { type: "string", format: "date-time" },
│ │ │           description: { type: "string" },
│ │ │           timeZone: { type: "string" },
│ │ │           dateFormat: { type: "string" },
│ │ │           hasEveryoneOnTheInternet: { type: "boolean" },
│ │ │           memoryInfo: {
│ │ │             type: "object",
│ │ │             properties: {
│ │ │               estMemory: { type: "number" },
│ │ │               estMemoryInclDependentApps: { type: "number" },
│ │ │             },
│ │ │           },
│ │ │           securityProperties: {
│ │ │             type: "object",
│ │ │             properties: {
│ │ │               allowClone: { type: "boolean" },
│ │ │               allowExport: { type: "boolean" },
│ │ │               enableAppTokens: { type: "boolean" },
│ │ │               hideFromPublic: { type: "boolean" },
│ │ │               mustBeRealmApproved: { type: "boolean" },
│ │ │               useIPFilter: { type: "boolean" },
│ │ │             },
│ │ │           },
│ │ │         },
│ │ │         required: ["id", "name"],
│ │ │       },
│ │ │       Record: { type: "object", additionalProperties: true },
│ │ │       CreateField200Response: {
│ │ │         type: "object",
│ │ │         properties: { id: { type: "integer" } },
│ │ │       },
│ │ │       DeleteFields200Response: {
│ │ │         type: "object",
│ │ │         properties: { deleted: { type: "boolean" } },
│ │ │       },
│ │ │       Upsert200Response: {
│ │ │         type: "object",
│ │ │         properties: { metadata: { type: "object" } },
│ │ │       },
│ │ │       CopyAppRequest: {
│ │ │         type: "object",
│ │ │         properties: { name: { type: "string" } },
│ │ │       },
│ │ │       CopyApp200Response: {
│ │ │         type: "object",
│ │ │         properties: { id: { type: "string" } },
│ │ │       },
│ │ │       CreateAppRequest: {
│ │ │         type: "object",
│ │ │         properties: { name: { type: "string" } },
│ │ │       },
│ │ │       CreateApp200Response: {
│ │ │         type: "object",
│ │ │         properties: { id: { type: "string" } },
│ │ │       },
│ │ │       DeleteAppRequest: {
│ │ │         type: "object",
│ │ │         properties: { name: { type: "string" } },
│ │ │       },
│ │ │       DeleteApp200Response: {
│ │ │         type: "object",
│ │ │         properties: { deleted: { type: "boolean" } },
│ │ │       },
│ │ │       UpdateAppRequest: {
│ │ │         type: "object",
│ │ │         properties: { name: { type: "string" } },
│ │ │       },
│ │ │       UpdateApp200Response: {
│ │ │         type: "object",
│ │ │         properties: { id: { type: "string" } },
│ │ │       },
│ │ │     };
│ │ │     
│ │ ├─ fix-spec-main.ts
│ │ │   Contents:
│ │ │     #!/usr/bin/env node
│ │ │     import { promises as fs } from "fs";
│ │ │     import path from "path";
│ │ │     import * as glob from "glob";
│ │ │     import { paths } from "./fix-spec-paths.ts";
│ │ │     import { definitions } from "./fix-spec-definitions.ts";
│ │ │     
│ │ │     interface Parameter {
│ │ │       name: string;
│ │ │       in: string;
│ │ │       required?: boolean;
│ │ │       type?: string;
│ │ │       schema?: { type?: string; items?: any; $ref?: string };
│ │ │       example?: any;
│ │ │     }
│ │ │     
│ │ │     interface Operation {
│ │ │       parameters?: Parameter[];
│ │ │       responses?: Record<string, { description: string; schema?: any }>;
│ │ │       operationId?: string;
│ │ │       summary?: string;
│ │ │       tags?: string[];
│ │ │     }
│ │ │     
│ │ │     interface Spec {
│ │ │       paths: Record<string, Record<string, Operation>>;
│ │ │       definitions?: Record<string, any>;
│ │ │       operations?: any;
│ │ │       groups?: any;
│ │ │       components?: any;
│ │ │     }
│ │ │     
│ │ │     function toCamelCase(str: string): string {
│ │ │       return str
│ │ │         .replace(/[-_](.)/g, (_, char) => char.toUpperCase())
│ │ │         .replace(/^./, (str) => str.toLowerCase());
│ │ │     }
│ │ │     
│ │ │     async function fixQuickBaseSpec(): Promise<void> {
│ │ │       try {
│ │ │         const CODEGEN_DIR = path.dirname(new URL(import.meta.url).pathname);
│ │ │         const SPECS_DIR = path.join(CODEGEN_DIR, "..", "specs");
│ │ │         console.log("Finding latest QuickBase RESTful API spec...");
│ │ │         const specFiles = glob.sync(
│ │ │           path.join(SPECS_DIR, "QuickBase_RESTful_*.json")
│ │ │         );
│ │ │         if (specFiles.length === 0) {
│ │ │           console.error(
│ │ │             "No QuickBase_RESTful_*.json files found in specs/ folder."
│ │ │           );
│ │ │           process.exit(1);
│ │ │         }
│ │ │         const inputFile = specFiles.sort().pop() as string;
│ │ │         const outputFile = path.join(CODEGEN_DIR, "quickbase-fixed.json");
│ │ │     
│ │ │         console.log(`Reading ${path.basename(inputFile)} from specs/...`);
│ │ │         const specContent = await fs.readFile(inputFile, "utf8");
│ │ │         const spec: Spec = JSON.parse(specContent);
│ │ │     
│ │ │         console.log("Fixing parameters...");
│ │ │         for (const pathKey in spec.paths) {
│ │ │           for (const method in spec.paths[pathKey]) {
│ │ │             const operation = spec.paths[pathKey][method];
│ │ │             if (operation.parameters) {
│ │ │               operation.parameters = operation.parameters.map(
│ │ │                 (param: Parameter) => {
│ │ │                   param.name = toCamelCase(param.name);
│ │ │                   if ("example" in param) delete param.example;
│ │ │                   if ("schema" in param && param.in !== "body") delete param.schema;
│ │ │                   if (!param.type && param.in !== "body") param.type = "string";
│ │ │                   if (
│ │ │                     param.name === "generated" &&
│ │ │                     param.schema?.type === "array" &&
│ │ │                     !param.schema.items
│ │ │                   ) {
│ │ │                     param.schema!.items = { $ref: "#/definitions/Record" };
│ │ │                   }
│ │ │                   return param;
│ │ │                 }
│ │ │               );
│ │ │             }
│ │ │           }
│ │ │         }
│ │ │     
│ │ │         console.log("Applying endpoint fixes...");
│ │ │         Object.assign(spec.paths, paths);
│ │ │     
│ │ │         console.log("Applying definitions...");
│ │ │         spec.definitions = definitions;
│ │ │     
│ │ │         console.log("Removing unexpected top-level attributes...");
│ │ │         delete spec.operations;
│ │ │         delete spec.groups;
│ │ │         delete spec.components;
│ │ │     
│ │ │         console.log(`Writing fixed spec to ${path.basename(outputFile)}...`);
│ │ │         await fs.writeFile(outputFile, JSON.stringify(spec, null, 2), "utf8");
│ │ │         console.log("Spec fixed successfully!");
│ │ │       } catch (error) {
│ │ │         console.error("Failed to fix spec:", error);
│ │ │         process.exit(1);
│ │ │       }
│ │ │     }
│ │ │     
│ │ │     fixQuickBaseSpec();
│ │ │     
│ │ ├─ fix-spec-paths.ts
│ │ │   Contents:
│ │ │     export const paths = {
│ │ │       "/fields": {
│ │ │         get: {
│ │ │           operationId: "getFields",
│ │ │           summary: "Get fields for a table",
│ │ │           tags: ["Fields"],
│ │ │           parameters: [
│ │ │             { name: "tableId", in: "query", required: true, type: "string" },
│ │ │             {
│ │ │               name: "includeFieldPerms",
│ │ │               in: "query",
│ │ │               required: false,
│ │ │               type: "boolean",
│ │ │             },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { type: "array", items: { $ref: "#/definitions/Field" } },
│ │ │             },
│ │ │           },
│ │ │         },
│ │ │         post: {
│ │ │           operationId: "createField",
│ │ │           summary: "Create a field",
│ │ │           tags: ["Fields"],
│ │ │           parameters: [
│ │ │             { name: "tableId", in: "query", required: true, type: "string" },
│ │ │             {
│ │ │               name: "generated",
│ │ │               in: "body",
│ │ │               required: true,
│ │ │               schema: { type: "object" },
│ │ │             },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { $ref: "#/definitions/CreateField200Response" },
│ │ │             },
│ │ │           },
│ │ │         },
│ │ │         delete: {
│ │ │           operationId: "deleteFields",
│ │ │           summary: "Delete fields",
│ │ │           tags: ["Fields"],
│ │ │           parameters: [
│ │ │             { name: "tableId", in: "query", required: true, type: "string" },
│ │ │             {
│ │ │               name: "generated",
│ │ │               in: "body",
│ │ │               required: true,
│ │ │               schema: { type: "object" },
│ │ │             },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { $ref: "#/definitions/DeleteFields200Response" },
│ │ │             },
│ │ │           },
│ │ │         },
│ │ │       },
│ │ │       "/tables/{tableId}": {
│ │ │         get: {
│ │ │           operationId: "getTable",
│ │ │           summary: "Get table details",
│ │ │           tags: ["Tables"],
│ │ │           parameters: [
│ │ │             { name: "appId", in: "query", required: true, type: "string" },
│ │ │             { name: "tableId", in: "path", required: true, type: "string" },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { $ref: "#/definitions/Table" },
│ │ │             },
│ │ │           },
│ │ │         },
│ │ │       },
│ │ │       "/apps/{appId}": {
│ │ │         get: {
│ │ │           operationId: "getAppById",
│ │ │           summary: "Get application details by ID",
│ │ │           tags: ["Apps"],
│ │ │           parameters: [
│ │ │             { name: "appId", in: "path", required: true, type: "string" },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { $ref: "#/definitions/App" },
│ │ │             },
│ │ │           },
│ │ │         },
│ │ │         post: {
│ │ │           operationId: "updateApp",
│ │ │           summary: "Update an app",
│ │ │           tags: ["Apps"],
│ │ │           parameters: [
│ │ │             { name: "appId", in: "path", required: true, type: "string" },
│ │ │             {
│ │ │               name: "generated",
│ │ │               in: "body",
│ │ │               required: true,
│ │ │               schema: { $ref: "#/definitions/UpdateAppRequest" },
│ │ │             },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { $ref: "#/definitions/UpdateApp200Response" },
│ │ │             },
│ │ │           },
│ │ │         },
│ │ │         delete: {
│ │ │           operationId: "deleteApp",
│ │ │           summary: "Delete an app",
│ │ │           tags: ["Apps"],
│ │ │           parameters: [
│ │ │             { name: "appId", in: "path", required: true, type: "string" },
│ │ │             {
│ │ │               name: "generated",
│ │ │               in: "body",
│ │ │               required: true,
│ │ │               schema: { $ref: "#/definitions/DeleteAppRequest" },
│ │ │             },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { $ref: "#/definitions/DeleteApp200Response" },
│ │ │             },
│ │ │           },
│ │ │         },
│ │ │       },
│ │ │       "/apps": {
│ │ │         post: {
│ │ │           operationId: "createApp",
│ │ │           summary: "Create an app",
│ │ │           tags: ["Apps"],
│ │ │           parameters: [
│ │ │             {
│ │ │               name: "generated",
│ │ │               in: "body",
│ │ │               required: true,
│ │ │               schema: { $ref: "#/definitions/CreateAppRequest" },
│ │ │             },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { $ref: "#/definitions/CreateApp200Response" },
│ │ │             },
│ │ │           },
│ │ │         },
│ │ │       },
│ │ │       "/apps/{appId}/copy": {
│ │ │         post: {
│ │ │           operationId: "copyApp",
│ │ │           summary: "Copy an app",
│ │ │           tags: ["Apps"],
│ │ │           parameters: [
│ │ │             { name: "appId", in: "path", required: true, type: "string" },
│ │ │             {
│ │ │               name: "generated",
│ │ │               in: "body",
│ │ │               required: true,
│ │ │               schema: { $ref: "#/definitions/CopyAppRequest" },
│ │ │             },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { $ref: "#/definitions/CopyApp200Response" },
│ │ │             },
│ │ │           },
│ │ │         },
│ │ │       },
│ │ │       "/apps/{appId}/events": {
│ │ │         get: {
│ │ │           operationId: "getAppEvents",
│ │ │           summary: "Get app events",
│ │ │           tags: ["Apps"],
│ │ │           parameters: [
│ │ │             { name: "appId", in: "path", required: true, type: "string" },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { type: "array", items: { type: "object" } },
│ │ │             },
│ │ │           },
│ │ │         },
│ │ │       },
│ │ │       "/records": {
│ │ │         post: {
│ │ │           operationId: "upsert",
│ │ │           summary: "Upsert records",
│ │ │           tags: ["Records"],
│ │ │           parameters: [
│ │ │             {
│ │ │               name: "generated",
│ │ │               in: "body",
│ │ │               required: true,
│ │ │               schema: { type: "object" },
│ │ │             },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { $ref: "#/definitions/Upsert200Response" },
│ │ │             },
│ │ │           },
│ │ │         },
│ │ │       },
│ │ │     };
│ │ │     
│ │ ├─ fix-spec.ts.bak
│ │ ├─ generate-unified-interface.ts
│ │ │   Contents:
│ │ │     #!/usr/bin/env node
│ │ │     import { readFileSync, writeFileSync, mkdirSync, existsSync } from "fs";
│ │ │     import { join, dirname } from "path";
│ │ │     import { fileURLToPath } from "url";
│ │ │     import { simplifyName } from "../utils.ts";
│ │ │     import { OpenAPIV3 } from "openapi-types";
│ │ │     
│ │ │     const __dirname = dirname(fileURLToPath(import.meta.url));
│ │ │     const SPEC_FILE = join(__dirname, "quickbase-fixed.json");
│ │ │     const OUTPUT_DIR = join(__dirname, "..", "generated-unified");
│ │ │     const OUTPUT_FILE = join(OUTPUT_DIR, "QuickbaseClient.ts");
│ │ │     
│ │ │     function generateInterface() {
│ │ │       if (!existsSync(SPEC_FILE)) {
│ │ │         console.error(
│ │ │           `Spec file ${SPEC_FILE} not found. Run 'npm run fix-spec' first.`
│ │ │         );
│ │ │         process.exit(1);
│ │ │       }
│ │ │     
│ │ │       console.log("Generating unified QuickbaseClient interface...");
│ │ │       const spec = JSON.parse(
│ │ │         readFileSync(SPEC_FILE, "utf8")
│ │ │       ) as OpenAPIV3.Document;
│ │ │       const { paths } = spec;
│ │ │     
│ │ │       const modelImports = new Set<string>();
│ │ │       const methods: string[] = [];
│ │ │     
│ │ │       for (const [path, methodsObj] of Object.entries(
│ │ │         paths as OpenAPIV3.PathsObject
│ │ │       )) {
│ │ │         if (!methodsObj) continue; // Guard against undefined PathItemObject
│ │ │     
│ │ │         for (const [method, operation] of Object.entries(
│ │ │           methodsObj as OpenAPIV3.PathItemObject
│ │ │         )) {
│ │ │           const op = operation as OpenAPIV3.OperationObject | undefined;
│ │ │           if (!op || !op.operationId) continue;
│ │ │     
│ │ │           const opId = simplifyName(op.operationId);
│ │ │           const params = (op.parameters || [])
│ │ │             .filter((p) => {
│ │ │               const param = p as OpenAPIV3.ParameterObject;
│ │ │               return !["QB-Realm-Hostname", "Authorization", "User-Agent"].includes(
│ │ │                 param.name
│ │ │               );
│ │ │             })
│ │ │             .map((p) => {
│ │ │               const param = p as OpenAPIV3.ParameterObject;
│ │ │               const type = param.schema
│ │ │                 ? mapRefToType(param.schema, modelImports)
│ │ │                 : "any";
│ │ │               return `${param.name}${param.required ? "" : "?"}: ${type}`;
│ │ │             })
│ │ │             .join("; ");
│ │ │           const response = op.responses?.["200"] as
│ │ │             | OpenAPIV3.ResponseObject
│ │ │             | undefined;
│ │ │           const returnType = response?.content?.["application/json"]?.schema
│ │ │             ? mapRefToType(
│ │ │                 response.content["application/json"].schema,
│ │ │                 modelImports
│ │ │               )
│ │ │             : "void";
│ │ │           methods.push(
│ │ │             `  ${opId}: (params: { ${params} }) => Promise<${returnType}>;`
│ │ │           );
│ │ │         }
│ │ │       }
│ │ │     
│ │ │       const importLines = Array.from(modelImports)
│ │ │         .map((m) => `import { ${m} } from "../generated/models/${m}.ts";`) // Add .ts extension
│ │ │         .join("\n");
│ │ │       const interfaceContent = `// Generated on ${new Date().toISOString()}\n${importLines}\n\nexport interface QuickbaseClient {\n${methods.join(
│ │ │         "\n"
│ │ │       )}\n}\n`;
│ │ │     
│ │ │       if (!existsSync(OUTPUT_DIR)) {
│ │ │         mkdirSync(OUTPUT_DIR, { recursive: true });
│ │ │       }
│ │ │       writeFileSync(OUTPUT_FILE, interfaceContent, "utf8");
│ │ │       console.log(`Generated ${OUTPUT_FILE}`);
│ │ │     }
│ │ │     
│ │ │     function mapRefToType(
│ │ │       schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject,
│ │ │       modelImports: Set<string>
│ │ │     ): string {
│ │ │       if ("$ref" in schema) {
│ │ │         const model = schema.$ref.split("/").pop()!;
│ │ │         modelImports.add(model);
│ │ │         return model;
│ │ │       }
│ │ │       if (schema.type === "array" && schema.items) {
│ │ │         const itemType =
│ │ │           "$ref" in schema.items
│ │ │             ? schema.items.$ref.split("/").pop()!
│ │ │             : schema.items.type || "any";
│ │ │         if ("$ref" in schema.items) modelImports.add(itemType);
│ │ │         return `${itemType}[]`;
│ │ │       }
│ │ │       return schema.type || "any";
│ │ │     }
│ │ │     
│ │ │     try {
│ │ │       generateInterface();
│ │ │     } catch (error) {
│ │ │       console.error("Generation failed:", error);
│ │ │       process.exit(1);
│ │ │     }
│ │ │     
│ │ ├─ openapi-generator-cli.jar
│ │ ├─ quickbase-fixed.json
│ │ └─ regenerate-client.ts
│ │     Contents:
│ │       #!/usr/bin/env node
│ │       import { execSync } from "child_process";
│ │       import { existsSync } from "fs";
│ │       import { join, dirname, basename } from "path";
│ │       import { fileURLToPath } from "url";
│ │       import { Project } from "ts-morph";
│ │       
│ │       const __dirname = dirname(fileURLToPath(import.meta.url));
│ │       const CODEGEN_DIR = __dirname;
│ │       const SPEC_FILE = join(CODEGEN_DIR, "quickbase-fixed.json");
│ │       const GENERATED_DIR = join(__dirname, "..", "generated");
│ │       const BACKUP_DIR = join(__dirname, "..", "generated-old");
│ │       const JAR_PATH = join(CODEGEN_DIR, "openapi-generator-cli.jar");
│ │       
│ │       function backupGeneratedDir(): void {
│ │         console.log("Backing up existing src/generated/...");
│ │         if (existsSync(GENERATED_DIR)) {
│ │           if (existsSync(BACKUP_DIR))
│ │             execSync(`rm -rf ${BACKUP_DIR}`, { stdio: "inherit" });
│ │           execSync(`mv ${GENERATED_DIR} ${BACKUP_DIR}`, { stdio: "inherit" });
│ │           console.log(`Moved src/generated/ to ${basename(BACKUP_DIR)}`);
│ │         } else {
│ │           console.log("No existing src/generated/ to backup.");
│ │         }
│ │       }
│ │       
│ │       function generateClient(): void {
│ │         if (!existsSync(SPEC_FILE)) {
│ │           console.error(
│ │             `Fixed spec file ${basename(
│ │               SPEC_FILE
│ │             )} not found. Run 'npm run fix-spec' first.`
│ │           );
│ │           process.exit(1);
│ │         }
│ │         console.log("Generating TypeScript client with Fetch API using JAR...");
│ │         const command = `java -jar ${JAR_PATH} generate \
│ │           -i ${SPEC_FILE} \
│ │           -g typescript-fetch \
│ │           -o ${GENERATED_DIR} \
│ │           --skip-validate-spec \
│ │           --additional-properties=supportsES6=true,modelPropertyNaming=original,typescriptThreePlus=true,apiPackage=apis,modelPackage=models`;
│ │         console.log("Executing command:", command);
│ │         try {
│ │           execSync(command, { stdio: "inherit" });
│ │           console.log(`Client generated successfully in ${GENERATED_DIR}`);
│ │           console.log(
│ │             "Generated APIs:",
│ │             execSync(
│ │               `ls ${GENERATED_DIR}/apis/ || echo "No APIs generated"`
│ │             ).toString()
│ │           );
│ │           console.log(
│ │             "Checking for getAppById:",
│ │             execSync(
│ │               `grep "getAppById" ${GENERATED_DIR}/apis/AppsApi.ts || echo "Not found"`
│ │             ).toString()
│ │           );
│ │         } catch (error) {
│ │           console.error("Generation failed:", (error as Error).message);
│ │           process.exit(1);
│ │         }
│ │       }
│ │       
│ │       function fixImportsAndExports(): void {
│ │         console.log(
│ │           "Fixing ESM imports and exports in generated files to use .ts extensions..."
│ │         );
│ │         const project = new Project({
│ │           tsConfigFilePath: join(__dirname, "../../tsconfig.json"),
│ │         });
│ │         project.addSourceFilesAtPaths(`${GENERATED_DIR}/**/*.ts`);
│ │         const sourceFiles = project.getSourceFiles();
│ │       
│ │         for (const sourceFile of sourceFiles) {
│ │           const filePath = sourceFile.getFilePath();
│ │           console.log(`Processing ${basename(filePath)}`);
│ │           const imports = sourceFile.getImportDeclarations();
│ │           const exports = sourceFile.getExportDeclarations();
│ │       
│ │           for (const importDecl of imports) {
│ │             const moduleSpecifier = importDecl.getModuleSpecifierValue();
│ │             if (
│ │               moduleSpecifier.startsWith("./") ||
│ │               moduleSpecifier.startsWith("../")
│ │             ) {
│ │               if (!moduleSpecifier.endsWith(".ts")) {
│ │                 importDecl.setModuleSpecifier(`${moduleSpecifier}.ts`);
│ │                 console.log(
│ │                   `Updated import: ${moduleSpecifier} -> ${moduleSpecifier}.ts`
│ │                 );
│ │               }
│ │             }
│ │           }
│ │       
│ │           for (const exportDecl of exports) {
│ │             const moduleSpecifier = exportDecl.getModuleSpecifierValue();
│ │             if (
│ │               moduleSpecifier &&
│ │               (moduleSpecifier.startsWith("./") || moduleSpecifier.startsWith("../"))
│ │             ) {
│ │               if (!moduleSpecifier.endsWith(".ts")) {
│ │                 exportDecl.setModuleSpecifier(`${moduleSpecifier}.ts`);
│ │                 console.log(
│ │                   `Updated export: ${moduleSpecifier} -> ${moduleSpecifier}.ts`
│ │                 );
│ │               }
│ │             }
│ │           }
│ │           sourceFile.saveSync();
│ │         }
│ │         console.log("All imports and exports fixed with .ts extensions.");
│ │       }
│ │       
│ │       function main(): void {
│ │         try {
│ │           execSync("java -version", { stdio: "ignore" });
│ │         } catch (error) {
│ │           console.error(
│ │             "Java is not installed or not in PATH. Install Java (e.g., OpenJDK 17)."
│ │           );
│ │           process.exit(1);
│ │         }
│ │         backupGeneratedDir();
│ │         generateClient();
│ │         fixImportsAndExports();
│ │       }
│ │       
│ │       main();
│ │       
│ ├─ generated/
│ │ ├─ .openapi-generator/
│ │ │ ├─ FILES
│ │ │ └─ VERSION
│ │ ├─ .openapi-generator-ignore
│ │ ├─ apis/
│ │ │ ├─ AppsApi.ts
│ │ │ ├─ AuditApi.ts
│ │ │ ├─ AuthApi.ts
│ │ │ ├─ DocumentTemplatesApi.ts
│ │ │ ├─ FieldsApi.ts
│ │ │ ├─ FilesApi.ts
│ │ │ ├─ FormulasApi.ts
│ │ │ ├─ PlatformAnalyticsApi.ts
│ │ │ ├─ RecordsApi.ts
│ │ │ ├─ ReportsApi.ts
│ │ │ ├─ SolutionsApi.ts
│ │ │ ├─ TablesApi.ts
│ │ │ ├─ UserTokenApi.ts
│ │ │ ├─ UsersApi.ts
│ │ │ └─ index.ts
│ │ ├─ index.ts
│ │ ├─ models/
│ │ │ ├─ AddMembersToGroup200Response.ts
│ │ │ ├─ AddSubgroupsToGroup200Response.ts
│ │ │ ├─ App.ts
│ │ │ ├─ AppMemoryInfo.ts
│ │ │ ├─ AppSecurityProperties.ts
│ │ │ ├─ Audit200Response.ts
│ │ │ ├─ Audit202Response.ts
│ │ │ ├─ AuditRequest.ts
│ │ │ ├─ CloneUserToken200Response.ts
│ │ │ ├─ CloneUserTokenRequest.ts
│ │ │ ├─ CopyApp200Response.ts
│ │ │ ├─ CopyAppRequest.ts
│ │ │ ├─ CreateApp200Response.ts
│ │ │ ├─ CreateAppRequest.ts
│ │ │ ├─ CreateField200Response.ts
│ │ │ ├─ CreateRelationship200Response.ts
│ │ │ ├─ CreateRelationshipRequest.ts
│ │ │ ├─ CreateTable200Response.ts
│ │ │ ├─ CreateTableRequest.ts
│ │ │ ├─ DeactivateUserToken200Response.ts
│ │ │ ├─ DeleteApp200Response.ts
│ │ │ ├─ DeleteAppRequest.ts
│ │ │ ├─ DeleteFields200Response.ts
│ │ │ ├─ DeleteFile200Response.ts
│ │ │ ├─ DeleteRelationship200Response.ts
│ │ │ ├─ DenyUsers200Response.ts
│ │ │ ├─ ExchangeSsoToken200Response.ts
│ │ │ ├─ ExchangeSsoTokenRequest.ts
│ │ │ ├─ Field.ts
│ │ │ ├─ FieldPermissionsInner.ts
│ │ │ ├─ FieldProperties.ts
│ │ │ ├─ GenerateDocument200Response.ts
│ │ │ ├─ GetField200Response.ts
│ │ │ ├─ GetRelationships200Response.ts
│ │ │ ├─ GetReport200Response.ts
│ │ │ ├─ GetTempTokenDBID200Response.ts
│ │ │ ├─ GetUsers200Response.ts
│ │ │ ├─ GetUsersRequest.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200Response.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseMetadata.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInner.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseTotals.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseWhereInner.ts
│ │ │ ├─ PlatformAnalyticEventSummariesRequest.ts
│ │ │ ├─ PlatformAnalyticEventSummariesRequestWhereInner.ts
│ │ │ ├─ PlatformAnalyticReads200Response.ts
│ │ │ ├─ RemoveMembersFromGroup200Response.ts
│ │ │ ├─ RemoveSubgroupsFromGroup200Response.ts
│ │ │ ├─ RunFormula200Response.ts
│ │ │ ├─ RunFormulaRequest.ts
│ │ │ ├─ RunQuery200Response.ts
│ │ │ ├─ RunQueryRequest.ts
│ │ │ ├─ RunReport200Response.ts
│ │ │ ├─ Table.ts
│ │ │ ├─ TransferUserToken200Response.ts
│ │ │ ├─ TransferUserTokenRequest.ts
│ │ │ ├─ UndenyUsers200Response.ts
│ │ │ ├─ UpdateApp200Response.ts
│ │ │ ├─ UpdateAppRequest.ts
│ │ │ ├─ UpdateFieldRequest.ts
│ │ │ ├─ UpdateRelationshipRequest.ts
│ │ │ ├─ Upsert200Response.ts
│ │ │ └─ index.ts
│ │ └─ runtime.ts
│ ├─ generated-old/
│ │ ├─ .openapi-generator/
│ │ │ ├─ FILES
│ │ │ └─ VERSION
│ │ ├─ .openapi-generator-ignore
│ │ ├─ apis/
│ │ │ ├─ AppsApi.ts
│ │ │ ├─ AuditApi.ts
│ │ │ ├─ AuthApi.ts
│ │ │ ├─ DocumentTemplatesApi.ts
│ │ │ ├─ FieldsApi.ts
│ │ │ ├─ FilesApi.ts
│ │ │ ├─ FormulasApi.ts
│ │ │ ├─ PlatformAnalyticsApi.ts
│ │ │ ├─ RecordsApi.ts
│ │ │ ├─ ReportsApi.ts
│ │ │ ├─ SolutionsApi.ts
│ │ │ ├─ TablesApi.ts
│ │ │ ├─ UserTokenApi.ts
│ │ │ ├─ UsersApi.ts
│ │ │ └─ index.ts
│ │ ├─ index.ts
│ │ ├─ models/
│ │ │ ├─ AddMembersToGroup200Response.ts
│ │ │ ├─ AddSubgroupsToGroup200Response.ts
│ │ │ ├─ App.ts
│ │ │ ├─ AppMemoryInfo.ts
│ │ │ ├─ AppSecurityProperties.ts
│ │ │ ├─ Audit200Response.ts
│ │ │ ├─ Audit202Response.ts
│ │ │ ├─ AuditRequest.ts
│ │ │ ├─ CloneUserToken200Response.ts
│ │ │ ├─ CloneUserTokenRequest.ts
│ │ │ ├─ CopyApp200Response.ts
│ │ │ ├─ CopyAppRequest.ts
│ │ │ ├─ CreateApp200Response.ts
│ │ │ ├─ CreateAppRequest.ts
│ │ │ ├─ CreateField200Response.ts
│ │ │ ├─ CreateRelationship200Response.ts
│ │ │ ├─ CreateRelationshipRequest.ts
│ │ │ ├─ CreateTable200Response.ts
│ │ │ ├─ CreateTableRequest.ts
│ │ │ ├─ DeactivateUserToken200Response.ts
│ │ │ ├─ DeleteApp200Response.ts
│ │ │ ├─ DeleteAppRequest.ts
│ │ │ ├─ DeleteFields200Response.ts
│ │ │ ├─ DeleteFile200Response.ts
│ │ │ ├─ DeleteRecords200Response.ts
│ │ │ ├─ DeleteRecordsRequest.ts
│ │ │ ├─ DeleteRelationship200Response.ts
│ │ │ ├─ DeleteTable200Response.ts
│ │ │ ├─ DenyUsers200Response.ts
│ │ │ ├─ ExchangeSsoToken200Response.ts
│ │ │ ├─ ExchangeSsoTokenRequest.ts
│ │ │ ├─ Field.ts
│ │ │ ├─ GenerateDocument200Response.ts
│ │ │ ├─ GetField200Response.ts
│ │ │ ├─ GetRelationships200Response.ts
│ │ │ ├─ GetReport200Response.ts
│ │ │ ├─ GetTempTokenDBID200Response.ts
│ │ │ ├─ GetUsers200Response.ts
│ │ │ ├─ GetUsersRequest.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200Response.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseMetadata.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInner.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseTotals.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseWhereInner.ts
│ │ │ ├─ PlatformAnalyticEventSummariesRequest.ts
│ │ │ ├─ PlatformAnalyticEventSummariesRequestWhereInner.ts
│ │ │ ├─ PlatformAnalyticReads200Response.ts
│ │ │ ├─ RemoveMembersFromGroup200Response.ts
│ │ │ ├─ RemoveSubgroupsFromGroup200Response.ts
│ │ │ ├─ RunFormula200Response.ts
│ │ │ ├─ RunFormulaRequest.ts
│ │ │ ├─ RunQuery200Response.ts
│ │ │ ├─ RunQueryRequest.ts
│ │ │ ├─ RunReport200Response.ts
│ │ │ ├─ Table.ts
│ │ │ ├─ TransferUserToken200Response.ts
│ │ │ ├─ TransferUserTokenRequest.ts
│ │ │ ├─ UndenyUsers200Response.ts
│ │ │ ├─ UpdateApp200Response.ts
│ │ │ ├─ UpdateAppRequest.ts
│ │ │ ├─ UpdateFieldRequest.ts
│ │ │ ├─ UpdateRelationshipRequest.ts
│ │ │ ├─ UpdateTableRequest.ts
│ │ │ ├─ Upsert200Response.ts
│ │ │ └─ index.ts
│ │ └─ runtime.ts
│ ├─ generated-unified/
│ │ └─ QuickbaseClient.ts
│ ├─ index.ts
│ ├─ log-gen.ts
│ ├─ quickbaseClient.ts
│ │   Contents:
│ │     import { QuickbaseClient } from "./generated-unified/QuickbaseClient.ts";
│ │     import { Configuration, HTTPHeaders } from "./generated/runtime.ts";
│ │     import * as apis from "./generated/apis/index.ts";
│ │     import { simplifyName } from "./utils.ts";
│ │     import fetch from "node-fetch"; // No need for RequestInit import since we won't use it directly
│ │     
│ │     export interface QuickbaseConfig {
│ │       realm: string;
│ │       userToken?: string;
│ │       tempToken?: string;
│ │       debug?: boolean;
│ │       fetchApi?: typeof fetch; // Still typed as node-fetch's fetch
│ │     }
│ │     
│ │     type ApiMethod<K extends keyof QuickbaseClient> = (
│ │       requestParameters: Parameters<QuickbaseClient[K]>[0],
│ │       initOverrides?: RequestInit
│ │     ) => Promise<ReturnType<QuickbaseClient[K]>>;
│ │     
│ │     interface MethodInfo<K extends keyof QuickbaseClient> {
│ │       api: any;
│ │       method: ApiMethod<K>;
│ │       paramMap: string[];
│ │     }
│ │     
│ │     type MethodMap = { [K in keyof QuickbaseClient]: MethodInfo<K> };
│ │     
│ │     const getParamNames = (fn: (...args: any[]) => any): string[] =>
│ │       fn
│ │         .toString()
│ │         .slice(fn.toString().indexOf("(") + 1, fn.toString().indexOf(")"))
│ │         .split(",")
│ │         .map((p) => p.trim().split("=")[0].trim())
│ │         .filter((p) => p && !p.match(/^\{/) && p !== "options");
│ │     
│ │     export function quickbaseClient(config: QuickbaseConfig): QuickbaseClient {
│ │       const token = config.tempToken || config.userToken || "";
│ │       const baseUrl = `https://api.quickbase.com/v1`;
│ │       const headers: HTTPHeaders = {
│ │         Authorization: `QB-USER-TOKEN ${token}`,
│ │         "QB-Realm-Hostname": `${config.realm}.quickbase.com`,
│ │         "Content-Type": "application/json",
│ │       };
│ │       const configuration = new Configuration({
│ │         basePath: baseUrl,
│ │         headers,
│ │         fetchApi: config.fetchApi || (fetch as any),
│ │       });
│ │     
│ │       const apiInstances = Object.fromEntries(
│ │         Object.entries(apis)
│ │           .filter(([name]) => name.endsWith("Api"))
│ │           .map(([name, ApiClass]) => [
│ │             name.replace("Api", "").toLowerCase(),
│ │             new ApiClass(configuration),
│ │           ])
│ │       );
│ │     
│ │       const methodMap = buildMethodMap();
│ │     
│ │       function buildMethodMap(): MethodMap {
│ │         const methodMap: Partial<MethodMap> = {};
│ │         const isValidMethod = (name: string) =>
│ │           !name.startsWith("_") &&
│ │           name !== "constructor" &&
│ │           !["Middleware", "Pre", "Post", "Raw"].some((s) => name.includes(s));
│ │     
│ │         for (const [apiName, api] of Object.entries(apiInstances)) {
│ │           Object.getOwnPropertyNames(Object.getPrototypeOf(api))
│ │             .filter(
│ │               (name) =>
│ │                 isValidMethod(name) &&
│ │                 typeof api[name as keyof typeof api] === "function"
│ │             )
│ │             .forEach((rawMethodName) => {
│ │               const simplifiedName = simplifyName(
│ │                 rawMethodName
│ │               ) as keyof QuickbaseClient;
│ │               const method = api[rawMethodName as keyof typeof api];
│ │               const boundMethod = method.bind(api) as unknown;
│ │               if (typeof boundMethod === "function" && boundMethod.length <= 2) {
│ │                 methodMap[simplifiedName] = {
│ │                   api,
│ │                   method: boundMethod as ApiMethod<typeof simplifiedName>,
│ │                   paramMap: getParamNames(method),
│ │                 };
│ │                 if (config.debug) {
│ │                   console.log(`Mapped ${rawMethodName} to ${simplifiedName}`);
│ │                 }
│ │               }
│ │             });
│ │         }
│ │         return methodMap as MethodMap;
│ │       }
│ │     
│ │       const invokeMethod = <K extends keyof QuickbaseClient>(
│ │         methodName: K,
│ │         params: Parameters<QuickbaseClient[K]>[0]
│ │       ): Promise<ReturnType<QuickbaseClient[K]>> => {
│ │         const methodInfo = methodMap[methodName];
│ │         if (!methodInfo) {
│ │           console.error(`Method ${methodName} not found in methodMap`, methodMap);
│ │           throw new Error(`Method ${methodName} not found`);
│ │         }
│ │         if (config.debug) {
│ │           console.log(`Invoking ${methodName} with params:`, params);
│ │           console.log(`Calling method with args:`, [params, undefined]);
│ │         }
│ │         const args: [any, RequestInit | undefined] =
│ │           methodInfo.paramMap.length === 1 &&
│ │           methodInfo.paramMap[0] === "requestParameters"
│ │             ? [params, undefined]
│ │             : [params, undefined];
│ │         const responsePromise = methodInfo.method(...args);
│ │         if (config.debug) {
│ │           responsePromise.then((response) => {
│ │             console.log(`Response from ${methodName}:`, response);
│ │           });
│ │         }
│ │         return responsePromise;
│ │       };
│ │     
│ │       return new Proxy<QuickbaseClient>({} as QuickbaseClient, {
│ │         get: (_, prop: string): ((params: any) => Promise<any>) | undefined => {
│ │           if (prop in methodMap) {
│ │             const methodName = prop as keyof QuickbaseClient;
│ │             return (params: Parameters<QuickbaseClient[typeof methodName]>[0]) => {
│ │               if (config.debug) {
│ │                 console.log(`Proxy called ${methodName} with:`, params);
│ │               }
│ │               return invokeMethod(methodName, params);
│ │             };
│ │           }
│ │           console.warn(`Method ${prop} not found in methodMap`);
│ │           return undefined;
│ │         },
│ │       });
│ │     }
│ │     
│ ├─ specs/
│ │ └─ QuickBase_RESTful_API_2025-03-04T06_22_39.725Z.json
│ ├─ test-esm.ts
│ ├─ test.ts
│ └─ utils.ts
├─ tests/
│ ├─ integration.test.ts
│ │   Contents:
│ │     import { describe, it, expect } from "vitest";
│ │     import { quickbaseClient } from "../src/quickbaseClient.ts";
│ │     import dotenv from "dotenv";
│ │     
│ │     dotenv.config();
│ │     
│ │     describe("QuickbaseClient Integration", () => {
│ │       const client = quickbaseClient({
│ │         realm: process.env.QB_REALM!,
│ │         userToken: process.env.QB_USER_TOKEN!,
│ │         debug: true,
│ │       });
│ │     
│ │       it(
│ │         "fetches real app data from QuickBase",
│ │         async () => {
│ │           const appId = process.env.QB_APP_ID;
│ │           if (!appId) throw new Error("QB_APP_ID is not defined in .env");
│ │           if (!process.env.QB_REALM)
│ │             throw new Error("QB_REALM is not defined in .env");
│ │           if (!process.env.QB_USER_TOKEN)
│ │             throw new Error("QB_USER_TOKEN is not defined in .env");
│ │     
│ │           console.log("Config used:", {
│ │             realm: process.env.QB_REALM,
│ │             userToken: process.env.QB_USER_TOKEN,
│ │             appId,
│ │           });
│ │           const result = await client.getApp({ appId });
│ │           console.log("Real API response:", result);
│ │           expect(result).toEqual({
│ │             id: appId,
│ │             name: "qb-copy",
│ │             created: new Date("2025-02-13T18:22:33Z"),
│ │             updated: new Date("2025-03-04T04:25:51Z"),
│ │             description: "",
│ │             timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
│ │             dateFormat: "MM-DD-YYYY",
│ │             hasEveryoneOnTheInternet: false,
│ │             memoryInfo: {
│ │               estMemory: 0,
│ │               estMemoryInclDependentApps: 0,
│ │             },
│ │             securityProperties: {
│ │               allowClone: false,
│ │               allowExport: true,
│ │               enableAppTokens: true,
│ │               hideFromPublic: false,
│ │               mustBeRealmApproved: false,
│ │               useIPFilter: false,
│ │             },
│ │           });
│ │         },
│ │         { timeout: 10000 }
│ │       );
│ │     
│ │       it(
│ │         "fetches real field data from QuickBase",
│ │         async () => {
│ │           const tableId = "buwai2z3s"; // From your curl
│ │           if (!tableId) throw new Error("Table ID is not defined");
│ │           if (!process.env.QB_REALM)
│ │             throw new Error("QB_REALM is not defined in .env");
│ │           if (!process.env.QB_USER_TOKEN)
│ │             throw new Error("QB_USER_TOKEN is not defined in .env");
│ │     
│ │           console.log("Config used:", {
│ │             realm: process.env.QB_REALM,
│ │             userToken: process.env.QB_USER_TOKEN,
│ │             tableId,
│ │           });
│ │           const result = await client.getFields({
│ │             tableId,
│ │             includeFieldPerms: true,
│ │           });
│ │           console.log("Real API response:", result);
│ │           expect(result).toEqual(
│ │             expect.arrayContaining([
│ │               expect.objectContaining({
│ │                 id: 1,
│ │                 label: "Date Created",
│ │                 fieldType: "timestamp",
│ │                 appearsByDefault: false,
│ │                 audited: false,
│ │                 bold: false,
│ │                 doesDataCopy: false,
│ │                 fieldHelp: "",
│ │                 findEnabled: false,
│ │                 mode: "",
│ │                 noWrap: true,
│ │                 required: false,
│ │                 unique: false,
│ │                 addToForms: undefined,
│ │                 permissions: expect.arrayContaining([
│ │                   expect.objectContaining({
│ │                     permissionType: "Modify",
│ │                     role: "Viewer",
│ │                     roleId: 10,
│ │                   }),
│ │                   expect.objectContaining({
│ │                     permissionType: "Modify",
│ │                     role: "Participant",
│ │                     roleId: 11,
│ │                   }),
│ │                   expect.objectContaining({
│ │                     permissionType: "Modify",
│ │                     role: "Administrator",
│ │                     roleId: 12,
│ │                   }),
│ │                 ]),
│ │                 properties: expect.objectContaining({
│ │                   allowNewChoices: false,
│ │                   carryChoices: true,
│ │                   defaultToday: false,
│ │                   defaultValue: "",
│ │                   displayDayOfWeek: false,
│ │                   displayMonth: "number",
│ │                   displayRelative: false,
│ │                   displayTime: true,
│ │                   displayTimezone: false,
│ │                   foreignKey: false,
│ │                   formula: "",
│ │                   primaryKey: false,
│ │                   sortAsGiven: true,
│ │                 }),
│ │               }),
│ │               expect.objectContaining({
│ │                 id: 3,
│ │                 label: "Record ID#",
│ │                 fieldType: "recordid",
│ │                 appearsByDefault: false,
│ │                 audited: false,
│ │                 bold: false,
│ │                 doesDataCopy: false,
│ │                 fieldHelp: "",
│ │                 findEnabled: false,
│ │                 mode: "",
│ │                 noWrap: true,
│ │                 required: false,
│ │                 unique: true,
│ │                 addToForms: undefined,
│ │                 permissions: expect.arrayContaining([
│ │                   expect.objectContaining({
│ │                     permissionType: "Modify",
│ │                     role: "Viewer",
│ │                     roleId: 10,
│ │                   }),
│ │                   expect.objectContaining({
│ │                     permissionType: "Modify",
│ │                     role: "Participant",
│ │                     roleId: 11,
│ │                   }),
│ │                   expect.objectContaining({
│ │                     permissionType: "Modify",
│ │                     role: "Administrator",
│ │                     roleId: 12,
│ │                   }),
│ │                 ]),
│ │                 properties: expect.objectContaining({
│ │                   primaryKey: true,
│ │                   foreignKey: false,
│ │                   formula: "",
│ │                   defaultValue: "",
│ │                   carryChoices: true,
│ │                   allowNewChoices: false,
│ │                   sortAsGiven: true,
│ │                   numberFormat: 0,
│ │                   decimalPlaces: 0,
│ │                   doesAverage: false,
│ │                   doesTotal: false,
│ │                   blankIsZero: true,
│ │                   commaStart: 4,
│ │                 }),
│ │               }),
│ │             ])
│ │           );
│ │         },
│ │         { timeout: 10000 }
│ │       );
│ │     });
│ │     
│ └─ quickbaseClient.test.ts
│     Contents:
│       import { describe, it, expect, vi, beforeEach } from "vitest";
│       import { quickbaseClient } from "../src/quickbaseClient.ts";
│       import dotenv from "dotenv";
│       
│       dotenv.config();
│       
│       describe("QuickbaseClient", () => {
│         const mockFetchApp = vi.fn((url: string, options: any) => {
│           console.log("Mock fetch:", url, options);
│           return Promise.resolve({
│             ok: true,
│             status: 200,
│             json: () =>
│               Promise.resolve({
│                 id: process.env.QB_APP_ID,
│                 name: "qb-copy",
│                 created: "2025-02-13T18:22:33Z",
│                 updated: "2025-03-04T04:25:51Z",
│                 description: "",
│                 timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
│                 dateFormat: "MM-DD-YYYY",
│                 hasEveryoneOnTheInternet: false,
│                 memoryInfo: {
│                   estMemory: 0,
│                   estMemoryInclDependentApps: 0,
│                 },
│                 securityProperties: {
│                   allowClone: false,
│                   allowExport: true,
│                   enableAppTokens: true,
│                   hideFromPublic: false,
│                   mustBeRealmApproved: false,
│                   useIPFilter: false,
│                 },
│               }),
│           } as Response);
│         });
│       
│         const client = quickbaseClient({
│           realm: process.env.QB_REALM || "default-realm",
│           userToken: process.env.QB_USER_TOKEN || "default-token",
│           debug: true,
│           fetchApi: mockFetchApp as any, // Type assertion to bypass strict typing for simplicity
│         });
│       
│         beforeEach(() => {
│           mockFetchApp.mockClear();
│         });
│       
│         it("initializes without errors", () => {
│           expect(client).toBeDefined();
│         });
│       
│         it("has getApp method", () => {
│           expect(typeof client.getApp).toBe("function");
│         });
│       
│         it("calls getApp successfully", async () => {
│           const appId = process.env.QB_APP_ID;
│           if (!appId) throw new Error("QB_APP_ID is not defined in .env");
│           console.log("Test appId:", appId);
│           const result = await client.getApp({ appId });
│           expect(result).toEqual({
│             id: appId,
│             name: "qb-copy",
│             created: new Date("2025-02-13T18:22:33Z"),
│             updated: new Date("2025-03-04T04:25:51Z"),
│             description: "",
│             timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
│             dateFormat: "MM-DD-YYYY",
│             hasEveryoneOnTheInternet: false,
│             memoryInfo: {
│               estMemory: 0,
│               estMemoryInclDependentApps: 0,
│             },
│             securityProperties: {
│               allowClone: false,
│               allowExport: true,
│               enableAppTokens: true,
│               hideFromPublic: false,
│               mustBeRealmApproved: false,
│               useIPFilter: false,
│             },
│           });
│           expect(mockFetchApp).toHaveBeenCalledWith(
│             `https://api.quickbase.com/v1/apps/${appId}`,
│             expect.objectContaining({
│               headers: expect.objectContaining({
│                 Authorization: `QB-USER-TOKEN ${process.env.QB_USER_TOKEN}`,
│                 "QB-Realm-Hostname": `${process.env.QB_REALM}.quickbase.com`,
│               }),
│             })
│           );
│         });
│       
│         it("calls getFields successfully", async () => {
│           const mockFetchFields = vi.fn((url: string, options: any) => {
│             console.log("Mock fetch for getFields:", url, options);
│             return Promise.resolve({
│               ok: true,
│               status: 200,
│               json: () =>
│                 Promise.resolve([
│                   {
│                     id: 1,
│                     label: "Field1",
│                     fieldType: "text",
│                     noWrap: false,
│                     bold: false,
│                     required: false,
│                     appearsByDefault: false,
│                     findEnabled: false,
│                     unique: false,
│                     doesDataCopy: false,
│                     fieldHelp: "field help",
│                     audited: false,
│                     properties: {
│                       primaryKey: false,
│                       foreignKey: false,
│                       numLines: 1,
│                       maxLength: 0,
│                       appendOnly: false,
│                       allowHTML: false,
│                       allowMentions: false,
│                       sortAsGiven: false,
│                       carryChoices: true,
│                       allowNewChoices: false,
│                       formula: "",
│                       defaultValue: "",
│                     },
│                     permissions: [
│                       { permissionType: "View", role: "Viewer", roleId: 10 },
│                       { permissionType: "None", role: "Participant", roleId: 11 },
│                       { permissionType: "Modify", role: "Administrator", roleId: 12 },
│                     ],
│                   },
│                 ]),
│             } as Response);
│           });
│       
│           const clientWithMock = quickbaseClient({
│             realm: process.env.QB_REALM || "default-realm",
│             userToken: process.env.QB_USER_TOKEN || "default-token",
│             debug: true,
│             fetchApi: mockFetchFields as any, // Type assertion to bypass strict typing
│           });
│       
│           const result = await clientWithMock.getFields({
│             tableId: "dummyTableId",
│             includeFieldPerms: true,
│           });
│           console.log("getFields response:", result);
│           expect(result).toEqual(
│             expect.arrayContaining([
│               expect.objectContaining({
│                 id: 1,
│                 label: "Field1",
│                 fieldType: "text",
│                 noWrap: false,
│                 bold: false,
│                 required: false,
│                 appearsByDefault: false,
│                 findEnabled: false,
│                 unique: false,
│                 doesDataCopy: false,
│                 fieldHelp: "field help",
│                 audited: false,
│                 properties: expect.objectContaining({
│                   primaryKey: false,
│                   foreignKey: false,
│                   numLines: 1,
│                   maxLength: 0,
│                   appendOnly: false,
│                   allowHTML: false,
│                   allowMentions: false,
│                   sortAsGiven: false,
│                   carryChoices: true,
│                   allowNewChoices: false,
│                   formula: "",
│                   defaultValue: "",
│                 }),
│                 permissions: expect.arrayContaining([
│                   expect.objectContaining({
│                     permissionType: "View",
│                     role: "Viewer",
│                     roleId: 10,
│                   }),
│                   expect.objectContaining({
│                     permissionType: "None",
│                     role: "Participant",
│                     roleId: 11,
│                   }),
│                   expect.objectContaining({
│                     permissionType: "Modify",
│                     role: "Administrator",
│                     roleId: 12,
│                   }),
│                 ]),
│               }),
│             ])
│           );
│           expect(mockFetchFields).toHaveBeenCalledWith(
│             `https://api.quickbase.com/v1/fields?tableId=dummyTableId&includeFieldPerms=true`,
│             expect.objectContaining({
│               headers: expect.objectContaining({
│                 Authorization: `QB-USER-TOKEN ${process.env.QB_USER_TOKEN}`,
│                 "QB-Realm-Hostname": `${process.env.QB_REALM}.quickbase.com`,
│               }),
│             })
│           );
│         });
│       });
│       
├─ text.txt
├─ tsconfig.build.json
│   Contents:
│     {
│       "extends": "./tsconfig.json",
│       "compilerOptions": {
│         "outDir": "dist",
│         "rootDir": "src",
│         "module": "NodeNext",
│         "moduleResolution": "NodeNext",
│         "declaration": false, // Disable individual .d.ts generation
│         "allowImportingTsExtensions": true,
│         "noEmit": true
│       },
│       "include": ["src/quickbaseClient.ts"], // Only process the entry point
│       "exclude": ["node_modules", "dist", "src/generated-old"]
│     }
└─ tsconfig.json
    Contents:
      {
        "compilerOptions": {
          "target": "ESNext",
          "module": "NodeNext",
          "moduleResolution": "NodeNext",
          "strict": true,
          "lib": ["ESNext", "DOM"],
          "types": ["node"],
          "esModuleInterop": true,
          "resolveJsonModule": true,
          "allowImportingTsExtensions": true,
          "noEmit": true
        },
        "include": ["src/**/*"],
        "exclude": ["node_modules", "dist", "src/generated-old"],
        "ts-node": {
          "esm": true,
          "transpileOnly": true
        }
      }

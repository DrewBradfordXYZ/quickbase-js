[quickbase-js] Tree - 3/6/2025
Root: /home/drew/Projects/quickbase-js

Project Goals:
- Implement a QuickBase API client in TypeScript.
- Generate client methods from the QuickBase RESTful API spec.
- Provide a simple and intuitive interface for interacting with QuickBase.
- This library should not have to manually update the client methods when the QuickBase API changes.
- Generate ergonomic client methods from the QuickBase RESTful API spec that do not require manual updates.
- Support both Node.js and browser environments.
- The intent is to use this in JS frameworks like React, Vue, and Angular.
- Use OpenAPI to generate the TypeScript types and methods.
- Use the latest ES6+ features and TypeScript features.


├─ .env
├─ .gitignore
├─ LICENSE
├─ README.md
├─ build.js
├─ dist/
│ ├─ quickbaseClient.d.ts
│ ├─ quickbaseClient.js
│ └─ quickbaseClient.js.map
├─ examples/
│ ├─ react.js
│ └─ vanillajs.html
├─ logGen.txt
├─ openapitools.json
├─ package-lock.json
├─ package.json
│   Contents:
│     {
│       "name": "quickbase-js",
│       "version": "1.0.0",
│       "description": "QuickBase JavaScript client for frameworks and vanilla JS",
│       "module": "dist/quickbaseClient.js",
│       "types": "dist/quickbaseClient.d.ts",
│       "type": "module",
│       "exports": {
│         ".": {
│           "import": "./dist/quickbaseClient.js",
│           "types": "./dist/quickbaseClient.d.ts"
│         }
│       },
│       "scripts": {
│         "fix-spec": "node --loader ts-node/esm src/code-generation/fix-spec.ts",
│         "regenerate": "node --loader ts-node/esm src/code-generation/regenerate-client.ts",
│         "generate-unified": "node --loader ts-node/esm src/code-generation/generate-unified-interface.ts",
│         "log-gen": "node --loader ts-node/esm src/log-gen.ts",
│         "build": "rollup -c",
│         "build:prod": "rm -rf dist/* && NODE_ENV=production rollup -c",
│         "test": "vitest run --environment jsdom tests/quickbaseClient.test.ts",
│         "test:integration": "vitest run --environment jsdom tests/integration.test.ts",
│         "test:all": "vitest run --environment jsdom tests/quickbaseClient.test.ts tests/integration.test.ts"
│       },
│       "dependencies": {
│         "typescript": "^5.8.2"
│       },
│       "devDependencies": {
│         "@rollup/plugin-commonjs": "^28.0.3",
│         "@rollup/plugin-node-resolve": "^16.0.0",
│         "@rollup/plugin-terser": "^0.4.4",
│         "@rollup/plugin-typescript": "^12.1.2",
│         "@types/node": "^20.11.20",
│         "dotenv": "^16.4.7",
│         "glob": "^11.0.1",
│         "jsdom": "^24.1.3",
│         "node-fetch": "^3.3.2",
│         "openapi-types": "^12.1.3",
│         "rollup": "^4.34.9",
│         "rollup-plugin-dts": "^6.1.1",
│         "ts-morph": "^23.0.0",
│         "ts-node": "^10.9.2",
│         "tslib": "^2.8.1",
│         "vitest": "^1.6.0"
│       }
│     }
│     
├─ rollup.config.js
│   Contents:
│     import typescript from "@rollup/plugin-typescript";
│     import terser from "@rollup/plugin-terser";
│     import nodeResolve from "@rollup/plugin-node-resolve";
│     import commonjs from "@rollup/plugin-commonjs";
│     import dts from "rollup-plugin-dts";
│     
│     const isProd = process.env.NODE_ENV === "production";
│     
│     export default [
│       {
│         input: "src/quickbaseClient.ts",
│         output: {
│           dir: "dist", // Switch to dir for multiple chunks
│           format: "esm",
│           sourcemap: true,
│           compact: isProd,
│           entryFileNames: "quickbaseClient.js", // Maintain output file name
│         },
│         external: [
│           "node:http",
│           "node:https",
│           "node:zlib",
│           "node:stream",
│           "node:buffer",
│           "node:util",
│           "node:url",
│           "node:net",
│           "node:fs",
│           "node:path",
│           "node-fetch", // Externalize node-fetch
│         ],
│         plugins: [
│           nodeResolve({ preferBuiltins: true }), // Use Node.js built-ins
│           commonjs(), // Handle CommonJS modules like node-fetch
│           typescript({
│             tsconfig: "./tsconfig.build.json",
│             declaration: false, // Keep this
│           }),
│           isProd && terser(),
│         ],
│       },
│       {
│         input: "src/quickbaseClient.ts",
│         output: {
│           file: "dist/quickbaseClient.d.ts", // Keep as file since dts generates a single file
│           format: "esm",
│         },
│         plugins: [
│           dts({
│             tsconfig: "./tsconfig.build.json",
│           }),
│         ],
│       },
│     ].map((config) => ({
│       ...config,
│       onwarn(warning, warn) {
│         if (
│           warning.code === "PLUGIN_WARNING" &&
│           warning.plugin === "typescript" &&
│           warning.message.includes("TS5096")
│         ) {
│           return; // Suppress TS5096
│         }
│         warn(warning);
│       },
│     }));
│     
├─ src/
│ ├─ code-generation/
│ │ ├─ fix-spec.ts
│ │ │   Contents:
│ │ │     #!/usr/bin/env node
│ │ │     import { promises as fs } from "fs";
│ │ │     import path from "path";
│ │ │     import * as glob from "glob";
│ │ │     
│ │ │     interface Parameter {
│ │ │       name: string;
│ │ │       in: string;
│ │ │       required?: boolean;
│ │ │       type?: string;
│ │ │       schema?: { type?: string; items?: any; $ref?: string };
│ │ │       example?: any;
│ │ │     }
│ │ │     
│ │ │     interface Operation {
│ │ │       parameters?: Parameter[];
│ │ │       responses?: Record<string, { description: string; schema?: any }>;
│ │ │       operationId?: string;
│ │ │       summary?: string;
│ │ │       tags?: string[];
│ │ │     }
│ │ │     
│ │ │     interface Spec {
│ │ │       paths: Record<string, Record<string, Operation>>;
│ │ │       definitions?: Record<string, any>;
│ │ │       operations?: any;
│ │ │       groups?: any;
│ │ │       components?: any;
│ │ │     }
│ │ │     
│ │ │     // Function to convert hyphenated names to camelCase
│ │ │     function toCamelCase(str: string): string {
│ │ │       return str
│ │ │         .replace(/[-_](.)/g, (_, char) => char.toUpperCase())
│ │ │         .replace(/^./, (str) => str.toLowerCase());
│ │ │     }
│ │ │     
│ │ │     async function fixQuickBaseSpec(): Promise<void> {
│ │ │       try {
│ │ │         const CODEGEN_DIR = path.dirname(new URL(import.meta.url).pathname);
│ │ │         const SPECS_DIR = path.join(CODEGEN_DIR, "..", "specs");
│ │ │         console.log("Finding latest QuickBase RESTful API spec...");
│ │ │         const specFiles = glob.sync(
│ │ │           path.join(SPECS_DIR, "QuickBase_RESTful_*.json")
│ │ │         );
│ │ │         if (specFiles.length === 0) {
│ │ │           console.error(
│ │ │             "No QuickBase_RESTful_*.json files found in specs/ folder."
│ │ │           );
│ │ │           process.exit(1);
│ │ │         }
│ │ │         const inputFile = specFiles.sort().pop() as string;
│ │ │         const outputFile = path.join(CODEGEN_DIR, "quickbase-fixed.json");
│ │ │     
│ │ │         console.log(`Reading ${path.basename(inputFile)} from specs/...`);
│ │ │         const specContent = await fs.readFile(inputFile, "utf8");
│ │ │         const spec: Spec = JSON.parse(specContent);
│ │ │     
│ │ │         console.log("Fixing parameters...");
│ │ │         for (const pathKey in spec.paths) {
│ │ │           for (const method in spec.paths[pathKey]) {
│ │ │             const operation = spec.paths[pathKey][method];
│ │ │             if (operation.parameters) {
│ │ │               operation.parameters = operation.parameters.map(
│ │ │                 (param: Parameter) => {
│ │ │                   // Transform hyphenated parameter names to camelCase
│ │ │                   param.name = toCamelCase(param.name);
│ │ │                   if ("example" in param) delete param.example;
│ │ │                   if ("schema" in param && param.in !== "body") delete param.schema;
│ │ │                   if (!param.type && param.in !== "body") param.type = "string";
│ │ │                   if (
│ │ │                     param.name === "generated" &&
│ │ │                     param.schema?.type === "array" &&
│ │ │                     !param.schema.items
│ │ │                   ) {
│ │ │                     param.schema!.items = { $ref: "#/definitions/Record" };
│ │ │                   }
│ │ │                   return param;
│ │ │                 }
│ │ │               );
│ │ │             }
│ │ │           }
│ │ │         }
│ │ │     
│ │ │         console.log("Ensuring required endpoints...");
│ │ │         // Fields endpoints
│ │ │         spec.paths["/fields"] = spec.paths["/fields"] || {};
│ │ │         spec.paths["/fields"].get = {
│ │ │           operationId: "getFields",
│ │ │           summary: "Get fields for a table",
│ │ │           tags: ["Fields"],
│ │ │           parameters: [
│ │ │             { name: "tableId", in: "query", required: true, type: "string" },
│ │ │             {
│ │ │               name: "includeFieldPerms",
│ │ │               in: "query",
│ │ │               required: false,
│ │ │               type: "boolean",
│ │ │             },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { type: "array", items: { $ref: "#/definitions/Field" } },
│ │ │             },
│ │ │           },
│ │ │         };
│ │ │     
│ │ │         spec.paths["/fields"].post = {
│ │ │           operationId: "createField",
│ │ │           summary: "Create a field",
│ │ │           tags: ["Fields"],
│ │ │           parameters: [
│ │ │             { name: "tableId", in: "query", required: true, type: "string" },
│ │ │             {
│ │ │               name: "generated",
│ │ │               in: "body",
│ │ │               required: true,
│ │ │               schema: { type: "object" },
│ │ │             },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { $ref: "#/definitions/CreateField200Response" },
│ │ │             },
│ │ │           },
│ │ │         };
│ │ │     
│ │ │         spec.paths["/fields"].delete = {
│ │ │           operationId: "deleteFields",
│ │ │           summary: "Delete fields",
│ │ │           tags: ["Fields"],
│ │ │           parameters: [
│ │ │             { name: "tableId", in: "query", required: true, type: "string" },
│ │ │             {
│ │ │               name: "generated",
│ │ │               in: "body",
│ │ │               required: true,
│ │ │               schema: { type: "object" },
│ │ │             },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { $ref: "#/definitions/DeleteFields200Response" },
│ │ │             },
│ │ │           },
│ │ │         };
│ │ │     
│ │ │         // Tables endpoint
│ │ │         spec.paths["/tables/{tableId}"] = spec.paths["/tables/{tableId}"] || {};
│ │ │         spec.paths["/tables/{tableId}"].get = {
│ │ │           operationId: "getTable",
│ │ │           summary: "Get table details",
│ │ │           tags: ["Tables"],
│ │ │           parameters: [
│ │ │             { name: "appId", in: "query", required: true, type: "string" },
│ │ │             { name: "tableId", in: "path", required: true, type: "string" },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { $ref: "#/definitions/Table" },
│ │ │             },
│ │ │           },
│ │ │         };
│ │ │     
│ │ │         // Apps endpoints (overwriting /apps/{appId} entirely)
│ │ │         spec.paths["/apps/{appId}"] = {
│ │ │           get: {
│ │ │             operationId: "getAppById",
│ │ │             summary: "Get application details by ID",
│ │ │             tags: ["Apps"],
│ │ │             parameters: [
│ │ │               { name: "appId", in: "path", required: true, type: "string" },
│ │ │             ],
│ │ │             responses: {
│ │ │               200: {
│ │ │                 description: "Success",
│ │ │                 schema: { $ref: "#/definitions/App" },
│ │ │               },
│ │ │             },
│ │ │           },
│ │ │           post: {
│ │ │             operationId: "updateApp",
│ │ │             summary: "Update an app",
│ │ │             tags: ["Apps"],
│ │ │             parameters: [
│ │ │               { name: "appId", in: "path", required: true, type: "string" },
│ │ │               {
│ │ │                 name: "generated",
│ │ │                 in: "body",
│ │ │                 required: true,
│ │ │                 schema: { $ref: "#/definitions/UpdateAppRequest" },
│ │ │               },
│ │ │             ],
│ │ │             responses: {
│ │ │               200: {
│ │ │                 description: "Success",
│ │ │                 schema: { $ref: "#/definitions/UpdateApp200Response" },
│ │ │               },
│ │ │             },
│ │ │           },
│ │ │           delete: {
│ │ │             operationId: "deleteApp",
│ │ │             summary: "Delete an app",
│ │ │             tags: ["Apps"],
│ │ │             parameters: [
│ │ │               { name: "appId", in: "path", required: true, type: "string" },
│ │ │               {
│ │ │                 name: "generated",
│ │ │                 in: "body",
│ │ │                 required: true,
│ │ │                 schema: { $ref: "#/definitions/DeleteAppRequest" },
│ │ │               },
│ │ │             ],
│ │ │             responses: {
│ │ │               200: {
│ │ │                 description: "Success",
│ │ │                 schema: { $ref: "#/definitions/DeleteApp200Response" },
│ │ │               },
│ │ │             },
│ │ │           },
│ │ │         };
│ │ │     
│ │ │         spec.paths["/apps"] = {
│ │ │           post: {
│ │ │             operationId: "createApp",
│ │ │             summary: "Create an app",
│ │ │             tags: ["Apps"],
│ │ │             parameters: [
│ │ │               {
│ │ │                 name: "generated",
│ │ │                 in: "body",
│ │ │                 required: true,
│ │ │                 schema: { $ref: "#/definitions/CreateAppRequest" },
│ │ │               },
│ │ │             ],
│ │ │             responses: {
│ │ │               200: {
│ │ │                 description: "Success",
│ │ │                 schema: { $ref: "#/definitions/CreateApp200Response" },
│ │ │               },
│ │ │             },
│ │ │           },
│ │ │         };
│ │ │     
│ │ │         spec.paths["/apps/{appId}/copy"] = {
│ │ │           post: {
│ │ │             operationId: "copyApp",
│ │ │             summary: "Copy an app",
│ │ │             tags: ["Apps"],
│ │ │             parameters: [
│ │ │               { name: "appId", in: "path", required: true, type: "string" },
│ │ │               {
│ │ │                 name: "generated",
│ │ │                 in: "body",
│ │ │                 required: true,
│ │ │                 schema: { $ref: "#/definitions/CopyAppRequest" },
│ │ │               },
│ │ │             ],
│ │ │             responses: {
│ │ │               200: {
│ │ │                 description: "Success",
│ │ │                 schema: { $ref: "#/definitions/CopyApp200Response" },
│ │ │               },
│ │ │             },
│ │ │           },
│ │ │         };
│ │ │     
│ │ │         spec.paths["/apps/{appId}/events"] = {
│ │ │           get: {
│ │ │             operationId: "getAppEvents",
│ │ │             summary: "Get app events",
│ │ │             tags: ["Apps"],
│ │ │             parameters: [
│ │ │               { name: "appId", in: "path", required: true, type: "string" },
│ │ │             ],
│ │ │             responses: {
│ │ │               200: {
│ │ │                 description: "Success",
│ │ │                 schema: { type: "array", items: { type: "object" } },
│ │ │               },
│ │ │             },
│ │ │           },
│ │ │         };
│ │ │     
│ │ │         // Records endpoint
│ │ │         spec.paths["/records"] = spec.paths["/records"] || {};
│ │ │         spec.paths["/records"].post = {
│ │ │           operationId: "upsert",
│ │ │           summary: "Upsert records",
│ │ │           tags: ["Records"],
│ │ │           parameters: [
│ │ │             {
│ │ │               name: "generated",
│ │ │               in: "body",
│ │ │               required: true,
│ │ │               schema: { type: "object" },
│ │ │             },
│ │ │           ],
│ │ │           responses: {
│ │ │             200: {
│ │ │               description: "Success",
│ │ │               schema: { $ref: "#/definitions/Upsert200Response" },
│ │ │             },
│ │ │           },
│ │ │         };
│ │ │     
│ │ │         console.log("Adding definitions...");
│ │ │         if (!spec.definitions) spec.definitions = {};
│ │ │         spec.definitions.Field = {
│ │ │           type: "object",
│ │ │           properties: { id: { type: "integer" }, label: { type: "string" } },
│ │ │         };
│ │ │         spec.definitions.Table = {
│ │ │           type: "object",
│ │ │           properties: { id: { type: "string" }, name: { type: "string" } },
│ │ │           required: ["id", "name"],
│ │ │         };
│ │ │         spec.definitions.App = {
│ │ │           type: "object",
│ │ │           properties: { id: { type: "string" }, name: { type: "string" } },
│ │ │           required: ["id", "name"],
│ │ │         };
│ │ │         spec.definitions.Record = { type: "object", additionalProperties: true };
│ │ │         spec.definitions.CreateField200Response = {
│ │ │           type: "object",
│ │ │           properties: { id: { type: "integer" } },
│ │ │         };
│ │ │         spec.definitions.DeleteFields200Response = {
│ │ │           type: "object",
│ │ │           properties: { deleted: { type: "boolean" } },
│ │ │         };
│ │ │         spec.definitions.Upsert200Response = {
│ │ │           type: "object",
│ │ │           properties: { metadata: { type: "object" } },
│ │ │         };
│ │ │         spec.definitions.CopyAppRequest = {
│ │ │           type: "object",
│ │ │           properties: { name: { type: "string" } },
│ │ │         };
│ │ │         spec.definitions.CopyApp200Response = {
│ │ │           type: "object",
│ │ │           properties: { id: { type: "string" } },
│ │ │         };
│ │ │         spec.definitions.CreateAppRequest = {
│ │ │           type: "object",
│ │ │           properties: { name: { type: "string" } },
│ │ │         };
│ │ │         spec.definitions.CreateApp200Response = {
│ │ │           type: "object",
│ │ │           properties: { id: { type: "string" } },
│ │ │         };
│ │ │         spec.definitions.DeleteAppRequest = {
│ │ │           type: "object",
│ │ │           properties: { name: { type: "string" } },
│ │ │         };
│ │ │         spec.definitions.DeleteApp200Response = {
│ │ │           type: "object",
│ │ │           properties: { deleted: { type: "boolean" } },
│ │ │         };
│ │ │         spec.definitions.UpdateAppRequest = {
│ │ │           type: "object",
│ │ │           properties: { name: { type: "string" } },
│ │ │         };
│ │ │         spec.definitions.UpdateApp200Response = {
│ │ │           type: "object",
│ │ │           properties: { id: { type: "string" } },
│ │ │         };
│ │ │     
│ │ │         console.log("Removing unexpected top-level attributes...");
│ │ │         delete spec.operations;
│ │ │         delete spec.groups;
│ │ │         delete spec.components;
│ │ │     
│ │ │         console.log(`Writing fixed spec to ${path.basename(outputFile)}...`);
│ │ │         await fs.writeFile(outputFile, JSON.stringify(spec, null, 2), "utf8");
│ │ │         console.log("Spec fixed successfully!");
│ │ │       } catch (error) {
│ │ │         console.error("Failed to fix spec:", error);
│ │ │         process.exit(1);
│ │ │       }
│ │ │     }
│ │ │     
│ │ │     fixQuickBaseSpec();
│ │ │     
│ │ ├─ generate-unified-interface.ts
│ │ │   Contents:
│ │ │     #!/usr/bin/env node
│ │ │     import { readFileSync, writeFileSync, mkdirSync, existsSync } from "fs";
│ │ │     import { join, dirname } from "path";
│ │ │     import { fileURLToPath } from "url";
│ │ │     import { simplifyName } from "../utils.ts";
│ │ │     import { OpenAPIV3 } from "openapi-types";
│ │ │     
│ │ │     const __dirname = dirname(fileURLToPath(import.meta.url));
│ │ │     const SPEC_FILE = join(__dirname, "quickbase-fixed.json");
│ │ │     const OUTPUT_DIR = join(__dirname, "..", "generated-unified");
│ │ │     const OUTPUT_FILE = join(OUTPUT_DIR, "QuickbaseClient.ts");
│ │ │     
│ │ │     function generateInterface() {
│ │ │       if (!existsSync(SPEC_FILE)) {
│ │ │         console.error(
│ │ │           `Spec file ${SPEC_FILE} not found. Run 'npm run fix-spec' first.`
│ │ │         );
│ │ │         process.exit(1);
│ │ │       }
│ │ │     
│ │ │       console.log("Generating unified QuickbaseClient interface...");
│ │ │       const spec = JSON.parse(
│ │ │         readFileSync(SPEC_FILE, "utf8")
│ │ │       ) as OpenAPIV3.Document;
│ │ │       const { paths } = spec;
│ │ │     
│ │ │       const modelImports = new Set<string>();
│ │ │       const methods: string[] = [];
│ │ │     
│ │ │       for (const [path, methodsObj] of Object.entries(
│ │ │         paths as OpenAPIV3.PathsObject
│ │ │       )) {
│ │ │         if (!methodsObj) continue; // Guard against undefined PathItemObject
│ │ │     
│ │ │         for (const [method, operation] of Object.entries(
│ │ │           methodsObj as OpenAPIV3.PathItemObject
│ │ │         )) {
│ │ │           const op = operation as OpenAPIV3.OperationObject | undefined;
│ │ │           if (!op || !op.operationId) continue;
│ │ │     
│ │ │           const opId = simplifyName(op.operationId);
│ │ │           const params = (op.parameters || [])
│ │ │             .filter((p) => {
│ │ │               const param = p as OpenAPIV3.ParameterObject;
│ │ │               return !["QB-Realm-Hostname", "Authorization", "User-Agent"].includes(
│ │ │                 param.name
│ │ │               );
│ │ │             })
│ │ │             .map((p) => {
│ │ │               const param = p as OpenAPIV3.ParameterObject;
│ │ │               const type = param.schema
│ │ │                 ? mapRefToType(param.schema, modelImports)
│ │ │                 : "any";
│ │ │               return `${param.name}${param.required ? "" : "?"}: ${type}`;
│ │ │             })
│ │ │             .join("; ");
│ │ │           const response = op.responses?.["200"] as
│ │ │             | OpenAPIV3.ResponseObject
│ │ │             | undefined;
│ │ │           const returnType = response?.content?.["application/json"]?.schema
│ │ │             ? mapRefToType(
│ │ │                 response.content["application/json"].schema,
│ │ │                 modelImports
│ │ │               )
│ │ │             : "void";
│ │ │           methods.push(
│ │ │             `  ${opId}: (params: { ${params} }) => Promise<${returnType}>;`
│ │ │           );
│ │ │         }
│ │ │       }
│ │ │     
│ │ │       const importLines = Array.from(modelImports)
│ │ │         .map((m) => `import { ${m} } from "../generated/models/${m}.ts";`) // Add .ts extension
│ │ │         .join("\n");
│ │ │       const interfaceContent = `// Generated on ${new Date().toISOString()}\n${importLines}\n\nexport interface QuickbaseClient {\n${methods.join(
│ │ │         "\n"
│ │ │       )}\n}\n`;
│ │ │     
│ │ │       if (!existsSync(OUTPUT_DIR)) {
│ │ │         mkdirSync(OUTPUT_DIR, { recursive: true });
│ │ │       }
│ │ │       writeFileSync(OUTPUT_FILE, interfaceContent, "utf8");
│ │ │       console.log(`Generated ${OUTPUT_FILE}`);
│ │ │     }
│ │ │     
│ │ │     function mapRefToType(
│ │ │       schema: OpenAPIV3.SchemaObject | OpenAPIV3.ReferenceObject,
│ │ │       modelImports: Set<string>
│ │ │     ): string {
│ │ │       if ("$ref" in schema) {
│ │ │         const model = schema.$ref.split("/").pop()!;
│ │ │         modelImports.add(model);
│ │ │         return model;
│ │ │       }
│ │ │       if (schema.type === "array" && schema.items) {
│ │ │         const itemType =
│ │ │           "$ref" in schema.items
│ │ │             ? schema.items.$ref.split("/").pop()!
│ │ │             : schema.items.type || "any";
│ │ │         if ("$ref" in schema.items) modelImports.add(itemType);
│ │ │         return `${itemType}[]`;
│ │ │       }
│ │ │       return schema.type || "any";
│ │ │     }
│ │ │     
│ │ │     try {
│ │ │       generateInterface();
│ │ │     } catch (error) {
│ │ │       console.error("Generation failed:", error);
│ │ │       process.exit(1);
│ │ │     }
│ │ │     
│ │ ├─ openapi-generator-cli.jar
│ │ ├─ quickbase-fixed.json
│ │ └─ regenerate-client.ts
│ │     Contents:
│ │       #!/usr/bin/env node
│ │       import { execSync } from "child_process";
│ │       import { existsSync } from "fs";
│ │       import { join, dirname, basename } from "path";
│ │       import { fileURLToPath } from "url";
│ │       import { Project } from "ts-morph";
│ │       
│ │       const __dirname = dirname(fileURLToPath(import.meta.url));
│ │       const CODEGEN_DIR = __dirname;
│ │       const SPEC_FILE = join(CODEGEN_DIR, "quickbase-fixed.json");
│ │       const GENERATED_DIR = join(__dirname, "..", "generated");
│ │       const BACKUP_DIR = join(__dirname, "..", "generated-old");
│ │       const JAR_PATH = join(CODEGEN_DIR, "openapi-generator-cli.jar");
│ │       
│ │       function backupGeneratedDir(): void {
│ │         console.log("Backing up existing src/generated/...");
│ │         if (existsSync(GENERATED_DIR)) {
│ │           if (existsSync(BACKUP_DIR))
│ │             execSync(`rm -rf ${BACKUP_DIR}`, { stdio: "inherit" });
│ │           execSync(`mv ${GENERATED_DIR} ${BACKUP_DIR}`, { stdio: "inherit" });
│ │           console.log(`Moved src/generated/ to ${basename(BACKUP_DIR)}`);
│ │         } else {
│ │           console.log("No existing src/generated/ to backup.");
│ │         }
│ │       }
│ │       
│ │       function generateClient(): void {
│ │         if (!existsSync(SPEC_FILE)) {
│ │           console.error(
│ │             `Fixed spec file ${basename(
│ │               SPEC_FILE
│ │             )} not found. Run 'npm run fix-spec' first.`
│ │           );
│ │           process.exit(1);
│ │         }
│ │         console.log("Generating TypeScript client with Fetch API using JAR...");
│ │         const command = `java -jar ${JAR_PATH} generate \
│ │           -i ${SPEC_FILE} \
│ │           -g typescript-fetch \
│ │           -o ${GENERATED_DIR} \
│ │           --skip-validate-spec \
│ │           --additional-properties=supportsES6=true,modelPropertyNaming=original,typescriptThreePlus=true,apiPackage=apis,modelPackage=models`;
│ │         console.log("Executing command:", command);
│ │         try {
│ │           execSync(command, { stdio: "inherit" });
│ │           console.log(`Client generated successfully in ${GENERATED_DIR}`);
│ │           console.log(
│ │             "Generated APIs:",
│ │             execSync(
│ │               `ls ${GENERATED_DIR}/apis/ || echo "No APIs generated"`
│ │             ).toString()
│ │           );
│ │           console.log(
│ │             "Checking for getAppById:",
│ │             execSync(
│ │               `grep "getAppById" ${GENERATED_DIR}/apis/AppsApi.ts || echo "Not found"`
│ │             ).toString()
│ │           );
│ │         } catch (error) {
│ │           console.error("Generation failed:", (error as Error).message);
│ │           process.exit(1);
│ │         }
│ │       }
│ │       
│ │       function fixImportsAndExports(): void {
│ │         console.log(
│ │           "Fixing ESM imports and exports in generated files to use .ts extensions..."
│ │         );
│ │         const project = new Project({
│ │           tsConfigFilePath: join(__dirname, "../../tsconfig.json"),
│ │         });
│ │         project.addSourceFilesAtPaths(`${GENERATED_DIR}/**/*.ts`);
│ │         const sourceFiles = project.getSourceFiles();
│ │       
│ │         for (const sourceFile of sourceFiles) {
│ │           const filePath = sourceFile.getFilePath();
│ │           console.log(`Processing ${basename(filePath)}`);
│ │           const imports = sourceFile.getImportDeclarations();
│ │           const exports = sourceFile.getExportDeclarations();
│ │       
│ │           for (const importDecl of imports) {
│ │             const moduleSpecifier = importDecl.getModuleSpecifierValue();
│ │             if (
│ │               moduleSpecifier.startsWith("./") ||
│ │               moduleSpecifier.startsWith("../")
│ │             ) {
│ │               if (!moduleSpecifier.endsWith(".ts")) {
│ │                 importDecl.setModuleSpecifier(`${moduleSpecifier}.ts`);
│ │                 console.log(
│ │                   `Updated import: ${moduleSpecifier} -> ${moduleSpecifier}.ts`
│ │                 );
│ │               }
│ │             }
│ │           }
│ │       
│ │           for (const exportDecl of exports) {
│ │             const moduleSpecifier = exportDecl.getModuleSpecifierValue();
│ │             if (
│ │               moduleSpecifier &&
│ │               (moduleSpecifier.startsWith("./") || moduleSpecifier.startsWith("../"))
│ │             ) {
│ │               if (!moduleSpecifier.endsWith(".ts")) {
│ │                 exportDecl.setModuleSpecifier(`${moduleSpecifier}.ts`);
│ │                 console.log(
│ │                   `Updated export: ${moduleSpecifier} -> ${moduleSpecifier}.ts`
│ │                 );
│ │               }
│ │             }
│ │           }
│ │           sourceFile.saveSync();
│ │         }
│ │         console.log("All imports and exports fixed with .ts extensions.");
│ │       }
│ │       
│ │       function main(): void {
│ │         try {
│ │           execSync("java -version", { stdio: "ignore" });
│ │         } catch (error) {
│ │           console.error(
│ │             "Java is not installed or not in PATH. Install Java (e.g., OpenJDK 17)."
│ │           );
│ │           process.exit(1);
│ │         }
│ │         backupGeneratedDir();
│ │         generateClient();
│ │         fixImportsAndExports();
│ │       }
│ │       
│ │       main();
│ │       
│ ├─ generated/
│ │ ├─ .openapi-generator/
│ │ │ ├─ FILES
│ │ │ └─ VERSION
│ │ ├─ .openapi-generator-ignore
│ │ ├─ apis/
│ │ │ ├─ AppsApi.ts
│ │ │ ├─ AuditApi.ts
│ │ │ ├─ AuthApi.ts
│ │ │ ├─ DocumentTemplatesApi.ts
│ │ │ ├─ FieldsApi.ts
│ │ │ ├─ FilesApi.ts
│ │ │ ├─ FormulasApi.ts
│ │ │ ├─ PlatformAnalyticsApi.ts
│ │ │ ├─ RecordsApi.ts
│ │ │ ├─ ReportsApi.ts
│ │ │ ├─ SolutionsApi.ts
│ │ │ ├─ TablesApi.ts
│ │ │ ├─ UserTokenApi.ts
│ │ │ ├─ UsersApi.ts
│ │ │ └─ index.ts
│ │ ├─ index.ts
│ │ ├─ models/
│ │ │ ├─ AddMembersToGroup200Response.ts
│ │ │ ├─ AddSubgroupsToGroup200Response.ts
│ │ │ ├─ App.ts
│ │ │ ├─ Audit200Response.ts
│ │ │ ├─ Audit202Response.ts
│ │ │ ├─ AuditRequest.ts
│ │ │ ├─ CloneUserToken200Response.ts
│ │ │ ├─ CloneUserTokenRequest.ts
│ │ │ ├─ CopyApp200Response.ts
│ │ │ ├─ CopyAppRequest.ts
│ │ │ ├─ CreateApp200Response.ts
│ │ │ ├─ CreateAppRequest.ts
│ │ │ ├─ CreateField200Response.ts
│ │ │ ├─ CreateRelationship200Response.ts
│ │ │ ├─ CreateRelationshipRequest.ts
│ │ │ ├─ CreateTable200Response.ts
│ │ │ ├─ CreateTableRequest.ts
│ │ │ ├─ DeactivateUserToken200Response.ts
│ │ │ ├─ DeleteApp200Response.ts
│ │ │ ├─ DeleteAppRequest.ts
│ │ │ ├─ DeleteFields200Response.ts
│ │ │ ├─ DeleteFile200Response.ts
│ │ │ ├─ DeleteRecords200Response.ts
│ │ │ ├─ DeleteRecordsRequest.ts
│ │ │ ├─ DeleteRelationship200Response.ts
│ │ │ ├─ DeleteTable200Response.ts
│ │ │ ├─ DenyUsers200Response.ts
│ │ │ ├─ ExchangeSsoToken200Response.ts
│ │ │ ├─ ExchangeSsoTokenRequest.ts
│ │ │ ├─ Field.ts
│ │ │ ├─ GenerateDocument200Response.ts
│ │ │ ├─ GetField200Response.ts
│ │ │ ├─ GetRelationships200Response.ts
│ │ │ ├─ GetReport200Response.ts
│ │ │ ├─ GetTempTokenDBID200Response.ts
│ │ │ ├─ GetUsers200Response.ts
│ │ │ ├─ GetUsersRequest.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200Response.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseMetadata.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInner.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseTotals.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseWhereInner.ts
│ │ │ ├─ PlatformAnalyticEventSummariesRequest.ts
│ │ │ ├─ PlatformAnalyticEventSummariesRequestWhereInner.ts
│ │ │ ├─ PlatformAnalyticReads200Response.ts
│ │ │ ├─ RemoveMembersFromGroup200Response.ts
│ │ │ ├─ RemoveSubgroupsFromGroup200Response.ts
│ │ │ ├─ RunFormula200Response.ts
│ │ │ ├─ RunFormulaRequest.ts
│ │ │ ├─ RunQuery200Response.ts
│ │ │ ├─ RunQueryRequest.ts
│ │ │ ├─ RunReport200Response.ts
│ │ │ ├─ Table.ts
│ │ │ ├─ TransferUserToken200Response.ts
│ │ │ ├─ TransferUserTokenRequest.ts
│ │ │ ├─ UndenyUsers200Response.ts
│ │ │ ├─ UpdateApp200Response.ts
│ │ │ ├─ UpdateAppRequest.ts
│ │ │ ├─ UpdateFieldRequest.ts
│ │ │ ├─ UpdateRelationshipRequest.ts
│ │ │ ├─ UpdateTableRequest.ts
│ │ │ ├─ Upsert200Response.ts
│ │ │ └─ index.ts
│ │ └─ runtime.ts
│ ├─ generated-old/
│ │ ├─ .openapi-generator/
│ │ │ ├─ FILES
│ │ │ └─ VERSION
│ │ ├─ .openapi-generator-ignore
│ │ ├─ apis/
│ │ │ ├─ AppsApi.ts
│ │ │ ├─ AuditApi.ts
│ │ │ ├─ AuthApi.ts
│ │ │ ├─ DocumentTemplatesApi.ts
│ │ │ ├─ FieldsApi.ts
│ │ │ ├─ FilesApi.ts
│ │ │ ├─ FormulasApi.ts
│ │ │ ├─ PlatformAnalyticsApi.ts
│ │ │ ├─ RecordsApi.ts
│ │ │ ├─ ReportsApi.ts
│ │ │ ├─ SolutionsApi.ts
│ │ │ ├─ TablesApi.ts
│ │ │ ├─ UserTokenApi.ts
│ │ │ ├─ UsersApi.ts
│ │ │ └─ index.ts
│ │ ├─ index.ts
│ │ ├─ models/
│ │ │ ├─ AddMembersToGroup200Response.ts
│ │ │ ├─ AddSubgroupsToGroup200Response.ts
│ │ │ ├─ App.ts
│ │ │ ├─ Audit200Response.ts
│ │ │ ├─ Audit202Response.ts
│ │ │ ├─ AuditRequest.ts
│ │ │ ├─ CloneUserToken200Response.ts
│ │ │ ├─ CloneUserTokenRequest.ts
│ │ │ ├─ CopyApp200Response.ts
│ │ │ ├─ CopyAppRequest.ts
│ │ │ ├─ CreateApp200Response.ts
│ │ │ ├─ CreateAppRequest.ts
│ │ │ ├─ CreateField200Response.ts
│ │ │ ├─ CreateRelationship200Response.ts
│ │ │ ├─ CreateRelationshipRequest.ts
│ │ │ ├─ CreateTable200Response.ts
│ │ │ ├─ CreateTableRequest.ts
│ │ │ ├─ DeactivateUserToken200Response.ts
│ │ │ ├─ DeleteApp200Response.ts
│ │ │ ├─ DeleteAppRequest.ts
│ │ │ ├─ DeleteFields200Response.ts
│ │ │ ├─ DeleteFile200Response.ts
│ │ │ ├─ DeleteRecords200Response.ts
│ │ │ ├─ DeleteRecordsRequest.ts
│ │ │ ├─ DeleteRelationship200Response.ts
│ │ │ ├─ DeleteTable200Response.ts
│ │ │ ├─ DenyUsers200Response.ts
│ │ │ ├─ ExchangeSsoToken200Response.ts
│ │ │ ├─ ExchangeSsoTokenRequest.ts
│ │ │ ├─ Field.ts
│ │ │ ├─ GenerateDocument200Response.ts
│ │ │ ├─ GetField200Response.ts
│ │ │ ├─ GetRelationships200Response.ts
│ │ │ ├─ GetReport200Response.ts
│ │ │ ├─ GetTempTokenDBID200Response.ts
│ │ │ ├─ GetUsers200Response.ts
│ │ │ ├─ GetUsersRequest.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200Response.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseMetadata.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInner.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseTotals.ts
│ │ │ ├─ PlatformAnalyticEventSummaries200ResponseWhereInner.ts
│ │ │ ├─ PlatformAnalyticEventSummariesRequest.ts
│ │ │ ├─ PlatformAnalyticEventSummariesRequestWhereInner.ts
│ │ │ ├─ PlatformAnalyticReads200Response.ts
│ │ │ ├─ RemoveMembersFromGroup200Response.ts
│ │ │ ├─ RemoveSubgroupsFromGroup200Response.ts
│ │ │ ├─ RunFormula200Response.ts
│ │ │ ├─ RunFormulaRequest.ts
│ │ │ ├─ RunQuery200Response.ts
│ │ │ ├─ RunQueryRequest.ts
│ │ │ ├─ RunReport200Response.ts
│ │ │ ├─ Table.ts
│ │ │ ├─ TransferUserToken200Response.ts
│ │ │ ├─ TransferUserTokenRequest.ts
│ │ │ ├─ UndenyUsers200Response.ts
│ │ │ ├─ UpdateApp200Response.ts
│ │ │ ├─ UpdateAppRequest.ts
│ │ │ ├─ UpdateFieldRequest.ts
│ │ │ ├─ UpdateRelationshipRequest.ts
│ │ │ ├─ UpdateTableRequest.ts
│ │ │ ├─ Upsert200Response.ts
│ │ │ └─ index.ts
│ │ └─ runtime.ts
│ ├─ generated-unified/
│ │ └─ QuickbaseClient.ts
│ ├─ index.ts
│ ├─ log-gen.ts
│ ├─ quickbaseClient.ts
│ │   Contents:
│ │     import { QuickbaseClient } from "./generated-unified/QuickbaseClient.ts";
│ │     import { Configuration, HTTPHeaders } from "./generated/runtime.ts";
│ │     import * as apis from "./generated/apis/index.ts";
│ │     import { simplifyName } from "./utils.ts";
│ │     import fetch, { RequestInit as NodeFetchRequestInit } from "node-fetch"; // Import node-fetch's RequestInit
│ │     
│ │     export interface QuickbaseConfig {
│ │       realm: string;
│ │       userToken?: string;
│ │       tempToken?: string;
│ │       debug?: boolean;
│ │       fetchApi?: typeof fetch; // Still typed as node-fetch's fetch
│ │     }
│ │     
│ │     type ApiMethod<K extends keyof QuickbaseClient> = (
│ │       requestParameters: Parameters<QuickbaseClient[K]>[0],
│ │       initOverrides?: RequestInit
│ │     ) => Promise<ReturnType<QuickbaseClient[K]>>;
│ │     
│ │     interface MethodInfo<K extends keyof QuickbaseClient> {
│ │       api: any;
│ │       method: ApiMethod<K>;
│ │       paramMap: string[];
│ │     }
│ │     
│ │     type MethodMap = { [K in keyof QuickbaseClient]: MethodInfo<K> };
│ │     
│ │     const getParamNames = (fn: (...args: any[]) => any): string[] =>
│ │       fn
│ │         .toString()
│ │         .slice(fn.toString().indexOf("(") + 1, fn.toString().indexOf(")"))
│ │         .split(",")
│ │         .map((p) => p.trim().split("=")[0].trim())
│ │         .filter((p) => p && !p.match(/^\{/) && p !== "options");
│ │     
│ │     export function quickbaseClient(config: QuickbaseConfig): QuickbaseClient {
│ │       const token = config.tempToken || config.userToken || "";
│ │       const baseUrl = `https://api.quickbase.com/v1`;
│ │       const headers: HTTPHeaders = {
│ │         Authorization: `QB-USER-TOKEN ${token}`,
│ │         "QB-Realm-Hostname": `${config.realm}.quickbase.com`,
│ │         "Content-Type": "application/json",
│ │       };
│ │       const configuration = new Configuration({
│ │         basePath: baseUrl,
│ │         headers,
│ │         fetchApi: config.fetchApi || (fetch as any),
│ │       });
│ │     
│ │       const apiInstances = Object.fromEntries(
│ │         Object.entries(apis)
│ │           .filter(([name]) => name.endsWith("Api"))
│ │           .map(([name, ApiClass]) => [
│ │             name.replace("Api", "").toLowerCase(),
│ │             new ApiClass(configuration),
│ │           ])
│ │       );
│ │     
│ │       const methodMap = buildMethodMap();
│ │     
│ │       function buildMethodMap(): MethodMap {
│ │         const methodMap: Partial<MethodMap> = {};
│ │         const isValidMethod = (name: string) =>
│ │           !name.startsWith("_") &&
│ │           name !== "constructor" &&
│ │           !["Middleware", "Pre", "Post", "Raw"].some((s) => name.includes(s));
│ │     
│ │         for (const [apiName, api] of Object.entries(apiInstances)) {
│ │           Object.getOwnPropertyNames(Object.getPrototypeOf(api))
│ │             .filter(
│ │               (name) =>
│ │                 isValidMethod(name) &&
│ │                 typeof api[name as keyof typeof api] === "function"
│ │             )
│ │             .forEach((rawMethodName) => {
│ │               const simplifiedName = simplifyName(
│ │                 rawMethodName
│ │               ) as keyof QuickbaseClient;
│ │               const method = api[rawMethodName as keyof typeof api];
│ │               const boundMethod = method.bind(api) as unknown;
│ │               if (typeof boundMethod === "function" && boundMethod.length <= 2) {
│ │                 methodMap[simplifiedName] = {
│ │                   api,
│ │                   method: boundMethod as ApiMethod<typeof simplifiedName>,
│ │                   paramMap: getParamNames(method),
│ │                 };
│ │                 if (config.debug) {
│ │                   console.log(`Mapped ${rawMethodName} to ${simplifiedName}`);
│ │                 }
│ │               }
│ │             });
│ │         }
│ │         return methodMap as MethodMap;
│ │       }
│ │     
│ │       const invokeMethod = <K extends keyof QuickbaseClient>(
│ │         methodName: K,
│ │         params: Parameters<QuickbaseClient[K]>[0]
│ │       ): Promise<any> => {
│ │         if (methodName === "getApp" && "appId" in params) {
│ │           // Custom fetch for getApp to bypass generated parsing
│ │           const url = `${configuration.basePath}/apps/${
│ │             (params as { appId: string }).appId
│ │           }`;
│ │           const fetchApi = config.fetchApi || fetch;
│ │           const requestOptions: NodeFetchRequestInit = {
│ │             // Use node-fetch's RequestInit
│ │             method: "GET",
│ │             headers: configuration.headers,
│ │           };
│ │           const responsePromise = fetchApi(url, requestOptions).then((res) => {
│ │             if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
│ │             return res.json();
│ │           });
│ │           if (config.debug) {
│ │             responsePromise.then((response) => {
│ │               console.log(`Response from ${methodName}:`, response);
│ │               console.log(`Request details:`, {
│ │                 url,
│ │                 headers: configuration.headers,
│ │                 method: "GET",
│ │               });
│ │             });
│ │           }
│ │           return responsePromise;
│ │         }
│ │     
│ │         const methodInfo = methodMap[methodName];
│ │         if (!methodInfo) {
│ │           console.error(`Method ${methodName} not found in methodMap`, methodMap);
│ │           throw new Error(`Method ${methodName} not found`);
│ │         }
│ │         if (config.debug) {
│ │           console.log(`Invoking ${methodName} with params:`, params);
│ │           console.log(`Calling method with args:`, [params, undefined]);
│ │         }
│ │         const args: [any, RequestInit | undefined] =
│ │           methodInfo.paramMap.length === 1 &&
│ │           methodInfo.paramMap[0] === "requestParameters"
│ │             ? [params, undefined]
│ │             : [params, undefined];
│ │         const responsePromise = methodInfo.method(...args);
│ │         if (config.debug) {
│ │           responsePromise.then((response) => {
│ │             console.log(`Response from ${methodName}:`, response);
│ │             console.log(`Request details:`, {
│ │               url:
│ │                 methodName === "getApp" && "appId" in params
│ │                   ? `${configuration.basePath}/apps/${
│ │                       (params as { appId: string }).appId
│ │                     }`
│ │                   : configuration.basePath,
│ │               headers: configuration.headers,
│ │               method: "GET",
│ │             });
│ │           });
│ │         }
│ │         return responsePromise;
│ │       };
│ │     
│ │       return new Proxy<QuickbaseClient>({} as QuickbaseClient, {
│ │         get: (_, prop: string): ((params: any) => Promise<any>) | undefined => {
│ │           if (prop in methodMap) {
│ │             const methodName = prop as keyof QuickbaseClient;
│ │             return (params: Parameters<QuickbaseClient[typeof methodName]>[0]) => {
│ │               if (config.debug) {
│ │                 console.log(`Proxy called ${methodName} with:`, params);
│ │               }
│ │               return invokeMethod(methodName, params);
│ │             };
│ │           }
│ │           console.warn(`Method ${prop} not found in methodMap`);
│ │           return undefined;
│ │         },
│ │       });
│ │     }
│ │     
│ ├─ specs/
│ │ └─ QuickBase_RESTful_API_2025-03-04T06_22_39.725Z.json
│ ├─ test-esm.ts
│ ├─ test.ts
│ └─ utils.ts
├─ tests/
│ ├─ integration.test.ts
│ └─ quickbaseClient.test.ts
│     Contents:
│       import { describe, it, expect, vi, beforeEach } from "vitest";
│       import { quickbaseClient } from "../src/quickbaseClient.ts";
│       import dotenv from "dotenv";
│       
│       dotenv.config();
│       
│       describe("QuickbaseClient", () => {
│         const mockFetch = vi.fn((url, options) => {
│           console.log("Mock fetch:", url, options);
│           return Promise.resolve({
│             ok: true,
│             status: 200,
│             json: () =>
│               Promise.resolve({
│                 id: process.env.QB_APP_ID,
│                 name: "qb-copy",
│                 created: "2025-02-13T18:22:33Z",
│                 updated: "2025-03-04T04:25:51Z",
│                 description: "",
│                 timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
│                 dateFormat: "MM-DD-YYYY",
│               }),
│           } as Response);
│         });
│       
│         const client = quickbaseClient({
│           realm: process.env.QB_REALM || "default-realm",
│           userToken: process.env.QB_USER_TOKEN || "default-token",
│           debug: true,
│           fetchApi: mockFetch,
│         });
│       
│         beforeEach(() => {
│           mockFetch.mockClear();
│         });
│       
│         it("initializes without errors", () => {
│           expect(client).toBeDefined();
│         });
│       
│         it("has getApp method", () => {
│           expect(typeof client.getApp).toBe("function");
│         });
│       
│         it("calls getApp successfully", async () => {
│           const appId = process.env.QB_APP_ID;
│           if (!appId) throw new Error("QB_APP_ID is not defined in .env");
│           console.log("Test appId:", appId);
│           const result = await client.getApp({ appId });
│           expect(result).toEqual({
│             id: appId,
│             name: "qb-copy",
│             created: "2025-02-13T18:22:33Z",
│             updated: "2025-03-04T04:25:51Z",
│             description: "",
│             timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
│             dateFormat: "MM-DD-YYYY",
│           });
│           expect(mockFetch).toHaveBeenCalledWith(
│             `https://api.quickbase.com/v1/apps/${appId}`,
│             expect.objectContaining({
│               headers: expect.objectContaining({
│                 Authorization: `QB-USER-TOKEN ${process.env.QB_USER_TOKEN}`,
│                 "QB-Realm-Hostname": `${process.env.QB_REALM}.quickbase.com`,
│               }),
│             })
│           );
│         });
│       });
│       
├─ text.txt
├─ tsconfig.build.json
│   Contents:
│     {
│       "extends": "./tsconfig.json",
│       "compilerOptions": {
│         "outDir": "dist",
│         "rootDir": "src",
│         "module": "NodeNext",
│         "moduleResolution": "NodeNext",
│         "declaration": false, // Disable individual .d.ts generation
│         "allowImportingTsExtensions": true,
│         "noEmit": true
│       },
│       "include": ["src/quickbaseClient.ts"], // Only process the entry point
│       "exclude": ["node_modules", "dist", "src/generated-old"]
│     }
└─ tsconfig.json
    Contents:
      {
        "compilerOptions": {
          "target": "ESNext",
          "module": "NodeNext",
          "moduleResolution": "NodeNext",
          "strict": true,
          "lib": ["ESNext", "DOM"],
          "types": ["node"],
          "esModuleInterop": true,
          "resolveJsonModule": true,
          "allowImportingTsExtensions": true,
          "noEmit": true
        },
        "include": ["src/**/*"],
        "exclude": ["node_modules", "dist", "src/generated-old"],
        "ts-node": {
          "esm": true,
          "transpileOnly": true
        }
      }

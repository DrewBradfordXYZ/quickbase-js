project: quickbase-js
date: 3/12/2025
root: /home/drew/Projects/quickbase-js
goals:
  - A library for interacting with the QuickBase RESTful API.
  - Use OpenAPI to generate types and methods using a proxy. Validate with tests.
  - Provide robust and intuitive temporary token support for browser environments.
  - User Tokens support both Node.js and browser environments.
  - 'Use case: JS frameworks like React, Vue, and Angular hosted in QuickBase code pages.'
  - Enable a flexible or native fetch in the browser.
  - Enable a flexible fetch framework in Node.js.
  - '#'
  - No manual updating methods when the QuickBase API changes.
  - The proxy magic dynamically maps generated methods and types.
  - '#'
  - TokenCache is defined per quickbaseClient call, so each instance has its own isolated TokenCache.
  - Each quickbase client instance has an isolated and individual token cache.
pipelineOverview:
  - 'fix-spec-main.ts: Input: Reads the latest QuickBase_RESTful*.json file from the specs/ folder and applies fixes to the parameters and paths.'
  - filters out the QB-Realm-Hostname, Authorization, and User-Agent parameters.
  - Converts parameter names to camelCase.
  - Fixes array schemas and applies custom paths.
  - Merges paths from fix-spec-paths.ts and definitions from fix-spec-definitions.ts.
  - 'Output: writes quickbase-fixed.json to src/code-generation/output/.'
  - 'Key Behavior: The merge (spec.paths = { ...spec.paths, ...paths }) preserves all origional endpoints, only overriding those defined in fix-spec-paths.ts.'
  - '#'
  - 'regenerate-client.ts: Uses quickbase-fixed.json to generate raw TypeScript-fetch files (src/generated/). including models and APIs.'
  - '#'
  - 'generate-unified-interface.ts: Uses quickbase-fixed.json to generate a unified QuickbaseClient.ts interface in src/generated-unified/.'
  - QuickbaseClient.ts includes all endpoints from src/code-generation/output/quickbase-fixed, and types from src/generated.
  - '#'
  - /specs/QuickBase_RESTful_API_*.json is over 46k lines of JSON, so it's not included in the snapshot, its too large to give to an AI.
  - which creates difficulties in understanding the structure of the API.
  - It makes it difficult to model the src/code-generation/fix-spec-*.ts files in the snapshot.
  - '#'
  - vitest unit and integration tests. Integration tests use the real QuickBase API with user token auth.
  - playwright is used to test the real QuickBase API in a browser enviornment with temporary token auth.
  - temp tokens can only be generated in a browser enviornment and can not be fetched with a user token.
  - '#'
  - getTempTokenDBID() method is wrapped to enhance temporary token generation reuse interacting with a token cache.
  - '#'
  - 'npm run fix-spec: Generates quickbase-fixed.json from the latest QuickBase_RESTful*.json file.'
  - npm run regenerate:openapi Generates raw TypeScript-fetch files in src/generated/.
  - 'npm run generate:unified: Generates a unified QuickbaseClient.ts interface in src/generated-unified/.'
tree:
  name: .
  type: directory
  children:
    - name: .env
      type: file
    - name: .gitignore
      type: file
    - name: CHANGELOG.md
      type: file
    - name: LICENSE
      type: file
    - name: README.md
      type: file
    - name: build.js
      type: file
    - name: dist
      type: directory
      children:
        - name: quickbase.d.ts
          type: file
        - name: quickbase.js
          type: file
        - name: quickbase.js.map
          type: file
    - name: examples
      type: directory
      children:
        - name: react.js
          type: file
        - name: vanillajs.html
          type: file
    - name: log-gen.yaml
      type: file
    - name: openapitools.json
      type: file
    - name: package-lock.json
      type: file
    - name: package.json
      type: file
      contents: |
        {
          "name": "quickbase-js",
          "main": "dist/quickbase.js",
          "types": "dist/quickbase.d.ts",
          "version": "1.1.0-beta.4",
          "publishConfig": {
            "access": "public"
          },
          "description": "QuickBase JavaScript client for frameworks and vanilla JS",
          "module": "dist/quickbase.js",
          "type": "module",
          "exports": {
            ".": {
              "import": "./dist/quickbase.js",
              "types": "./dist/quickbase.d.ts"
            }
          },
          "scripts": {
            "release": "standard-version",
            "release:beta": "standard-version --prerelease beta",
            "release:alpha": "standard-version --prerelease alpha",
            "release:push": "npm run release:beta && git push --follow-tags origin main",
            "release:publish": "npm run release:push && npm publish --tag beta",
            "fix-spec": "node --loader ts-node/esm src/code-generation/fix-spec-main.ts",
            "regenerate:openapi": "rimraf src/generated && node --loader ts-node/esm src/code-generation/regenerate-client.ts",
            "regenerate:unified": "node --loader ts-node/esm src/code-generation/generate-unified-interface.ts",
            "regenerate:all": "npm run fix-spec && npm run regenerate:openapi && npm run regenerate:unified",
            "log-gen": "node --loader ts-node/esm src/log-gen.ts",
            "build": "rimraf dist && rollup -c",
            "build:prod": "rm -rf dist/* && NODE_ENV=production rollup -c",
            "test:all": "vitest run tests/vitest/**/**/*.test.ts --reporter=basic && playwright test tests/playwright/qb --config playwright.config.ts --reporter=dot --quiet",
            "test:pw:qb:all": "playwright test tests/playwright/qb --config playwright.config.ts",
            "test:vitest:all": "vitest run tests/vitest/**/**/*.test.ts",
            "test:vitest:qb": "vitest run tests/vitest/qb/**/*.test.ts",
            "test:vitest:unit": "vitest run tests/vitest/unit/**/*.test.ts",
            "test:vitest:qb:apps": "vitest run tests/vitest/qb/apps/**/*.test.ts",
            "test:vitest:qb:auth": "vitest run tests/vitest/qb/auth/**/*.test.ts",
            "test:vitest:qb:fields": "vitest run tests/vitest/qb/fields/**/*.test.ts",
            "test:vitest:qb:records": "vitest run tests/vitest/qb/records/**/*.test.ts",
            "test:vitest:qb:tables": "vitest run tests/vitest/qb/tables/**/*.test.ts",
            "test:vitest:unit:apps": "vitest run tests/vitest/unit/apps/**/*.test.ts",
            "test:vitest:unit:auth": "vitest run tests/vitest/unit/auth/**/*.test.ts",
            "test:vitest:unit:fields": "vitest run tests/vitest/unit/fields/**/*.test.ts",
            "test:vitest:unit:records": "vitest run tests/vitest/unit/records/**/*.test.ts",
            "test:vitest:unit:tables": "vitest run tests/vitest/unit/tables/**/*.test.ts",
            "test:pw:qb:auth": "playwright test tests/playwright/qb/auth"
          },
          "dependencies": {
            "typescript": "^5.8.2"
          },
          "devDependencies": {
            "@openapitools/openapi-generator-cli": "^2.17.0",
            "@playwright/test": "^1.51.0",
            "@rollup/plugin-commonjs": "^28.0.3",
            "@rollup/plugin-node-resolve": "^16.0.0",
            "@rollup/plugin-terser": "^0.4.4",
            "@rollup/plugin-typescript": "^12.1.2",
            "@types/node": "^22.13.10",
            "dotenv": "^16.4.7",
            "glob": "^11.0.1",
            "js-yaml": "^4.1.0",
            "jsdom": "^26.0.0",
            "node-fetch": "^3.3.2",
            "openapi-types": "^12.1.3",
            "rimraf": "^5.0.10",
            "rollup": "^4.35.0",
            "rollup-plugin-dts": "^6.1.1",
            "standard-version": "^9.5.0",
            "ts-morph": "^25.0.1",
            "ts-node": "^10.9.2",
            "tslib": "^2.8.1",
            "vitest": "^3.0.8"
          }
        }
    - name: playwright-results.txt
      type: directory
      children:
        - name: .last-run.json
          type: file
    - name: playwright.config.ts
      type: file
    - name: rollup.config.js
      type: file
      contents: |
        import typescript from "@rollup/plugin-typescript";
        import terser from "@rollup/plugin-terser";
        import nodeResolve from "@rollup/plugin-node-resolve";
        import commonjs from "@rollup/plugin-commonjs";
        import dts from "rollup-plugin-dts";

        const isProd = process.env.NODE_ENV === "production";

        export default [
          {
            input: "src/quickbaseClient.ts",
            output: {
              dir: "dist",
              format: "esm",
              sourcemap: true,
              compact: isProd,
              entryFileNames: "quickbase.js",
            },
            external: [
              "node:http",
              "node:https",
              "node:zlib",
              "node:stream",
              "node:buffer",
              "node:util",
              "node:url",
              "node:net",
              "node:fs",
              "node:path",
              "node-fetch",
            ],
            plugins: [
              nodeResolve({ preferBuiltins: true }),
              commonjs(),
              typescript({
                tsconfig: "./tsconfig.json",
                declaration: false, // No .d.ts here, handled by dts plugin
              }),
              isProd && terser(),
            ],
          },
          {
            input: "src/quickbaseClient.ts",
            output: {
              file: "dist/quickbase.d.ts",
              format: "esm",
              // Optional: sourcemap for .d.ts if needed for debugging
              // sourcemap: true,
            },
            plugins: [
              dts({
                tsconfig: "./tsconfig.json",
                // Ensure all referenced files are included
                respectExternal: true,
              }),
            ],
          },
        ].map((config) => ({
          ...config,
          onwarn(warning, warn) {
            if (
              warning.code === "PLUGIN_WARNING" &&
              warning.plugin === "typescript" &&
              warning.message.includes("TS5096")
            ) {
              return;
            }
            warn(warning);
          },
        }));
    - name: src
      type: directory
      children:
        - name: code-generation
          type: directory
          children:
            - name: definitions
              type: directory
              children:
                - name: apps.ts
                  type: file
                - name: auth.ts
                  type: file
                - name: fields.ts
                  type: file
                - name: index.ts
                  type: file
                - name: records.ts
                  type: file
                - name: relationships.ts
                  type: file
                - name: reports.ts
                  type: file
                - name: tables.ts
                  type: file
            - name: fix-spec-main.ts
              type: file
            - name: generate-unified-interface.ts
              type: file
            - name: output
              type: directory
              children:
                - name: quickbase-fixed.json
                  type: file
            - name: paths
              type: directory
              children:
                - name: apps.ts
                  type: file
                - name: auth.ts
                  type: file
                - name: fields.ts
                  type: file
                - name: index.ts
                  type: file
                - name: records.ts
                  type: file
                - name: relationships.ts
                  type: file
                - name: reports.ts
                  type: file
                - name: tables.ts
                  type: file
            - name: regenerate-client.ts
              type: file
        - name: generated
          type: directory
          children:
            - name: .openapi-generator
              type: directory
              children:
                - name: FILES
                  type: file
                - name: VERSION
                  type: file
            - name: .openapi-generator-ignore
              type: file
            - name: apis
              type: directory
              children:
                - name: AppsApi.ts
                  type: file
                - name: AuditApi.ts
                  type: file
                - name: AuthApi.ts
                  type: file
                - name: DocumentTemplatesApi.ts
                  type: file
                - name: FieldsApi.ts
                  type: file
                - name: FilesApi.ts
                  type: file
                - name: FormulasApi.ts
                  type: file
                - name: PlatformAnalyticsApi.ts
                  type: file
                - name: RecordsApi.ts
                  type: file
                - name: RelationshipsApi.ts
                  type: file
                - name: ReportsApi.ts
                  type: file
                - name: SolutionsApi.ts
                  type: file
                - name: TablesApi.ts
                  type: file
                - name: UserTokenApi.ts
                  type: file
                - name: UsersApi.ts
                  type: file
                - name: index.ts
                  type: file
            - name: index.ts
              type: file
            - name: models
              type: directory
              children:
                - name: AddMembersToGroup200Response.ts
                  type: file
                - name: AddSubgroupsToGroup200Response.ts
                  type: file
                - name: App.ts
                  type: file
                - name: AppMemoryInfo.ts
                  type: file
                - name: AppSecurityProperties.ts
                  type: file
                - name: Audit200Response.ts
                  type: file
                - name: Audit202Response.ts
                  type: file
                - name: AuditRequest.ts
                  type: file
                - name: CloneUserToken200Response.ts
                  type: file
                - name: CloneUserTokenRequest.ts
                  type: file
                - name: CopyApp200Response.ts
                  type: file
                - name: CopyAppRequest.ts
                  type: file
                - name: CopyAppRequestProperties.ts
                  type: file
                - name: CreateApp200Response.ts
                  type: file
                - name: CreateAppRequest.ts
                  type: file
                - name: CreateAppRequestVariablesInner.ts
                  type: file
                - name: CreateField200Response.ts
                  type: file
                - name: CreateFieldRequest.ts
                  type: file
                - name: CreateRelationship200Response.ts
                  type: file
                - name: CreateRelationshipRequest.ts
                  type: file
                - name: CreateTableRequest.ts
                  type: file
                - name: DeactivateUserToken200Response.ts
                  type: file
                - name: DeleteApp200Response.ts
                  type: file
                - name: DeleteAppRequest.ts
                  type: file
                - name: DeleteFields200Response.ts
                  type: file
                - name: DeleteFieldsRequest.ts
                  type: file
                - name: DeleteFile200Response.ts
                  type: file
                - name: DeleteRecords200Response.ts
                  type: file
                - name: DeleteRecordsRequest.ts
                  type: file
                - name: DeleteRelationship200Response.ts
                  type: file
                - name: DeleteTableResponse.ts
                  type: file
                - name: DenyUsers200Response.ts
                  type: file
                - name: ExchangeSsoToken200Response.ts
                  type: file
                - name: ExchangeSsoTokenRequest.ts
                  type: file
                - name: Field.ts
                  type: file
                - name: FieldPermissionsInner.ts
                  type: file
                - name: FieldProperties.ts
                  type: file
                - name: FieldUsage.ts
                  type: file
                - name: FieldUsageField.ts
                  type: file
                - name: FieldUsageUsage.ts
                  type: file
                - name: GenerateDocument200Response.ts
                  type: file
                - name: GetRelationships200Response.ts
                  type: file
                - name: GetRelationships200ResponseMetadata.ts
                  type: file
                - name: GetReport200Response.ts
                  type: file
                - name: GetTempTokenDBID200Response.ts
                  type: file
                - name: GetUsers200Response.ts
                  type: file
                - name: GetUsersRequest.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200Response.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseMetadata.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseResultsInner.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseTotals.ts
                  type: file
                - name: PlatformAnalyticEventSummaries200ResponseWhereInner.ts
                  type: file
                - name: PlatformAnalyticEventSummariesRequest.ts
                  type: file
                - name: PlatformAnalyticEventSummariesRequestWhereInner.ts
                  type: file
                - name: PlatformAnalyticReads200Response.ts
                  type: file
                - name: Record.ts
                  type: file
                - name: RecordValue.ts
                  type: file
                - name: Relationship.ts
                  type: file
                - name: RelationshipField.ts
                  type: file
                - name: RemoveMembersFromGroup200Response.ts
                  type: file
                - name: RemoveSubgroupsFromGroup200Response.ts
                  type: file
                - name: ReportRunResponse.ts
                  type: file
                - name: RunFormula200Response.ts
                  type: file
                - name: RunFormulaRequest.ts
                  type: file
                - name: RunQueryRequest.ts
                  type: file
                - name: RunQueryRequestGroupByInner.ts
                  type: file
                - name: RunQueryRequestOptions.ts
                  type: file
                - name: RunQueryRequestSortByInner.ts
                  type: file
                - name: RunQueryResponse.ts
                  type: file
                - name: RunQueryResponseFieldsInner.ts
                  type: file
                - name: RunQueryResponseMetadata.ts
                  type: file
                - name: Table.ts
                  type: file
                - name: TransferUserToken200Response.ts
                  type: file
                - name: TransferUserTokenRequest.ts
                  type: file
                - name: UndenyUsers200Response.ts
                  type: file
                - name: UpdateRelationshipRequest.ts
                  type: file
                - name: UpdateTableRequest.ts
                  type: file
                - name: Upsert200Response.ts
                  type: file
                - name: Upsert200ResponseDataInnerValue.ts
                  type: file
                - name: Upsert200ResponseMetadata.ts
                  type: file
                - name: Upsert207Response.ts
                  type: file
                - name: Upsert207ResponseMetadata.ts
                  type: file
                - name: UpsertRequest.ts
                  type: file
                - name: UsageCount.ts
                  type: file
                - name: index.ts
                  type: file
            - name: runtime.ts
              type: file
        - name: generated-unified
          type: directory
          children:
            - name: QuickbaseClient.ts
              type: file
              contents: |
                // Generated on 2025-03-12T04:58:24.127Z
                import { App, CopyApp200Response, CopyAppRequest, CreateApp200Response, CreateAppRequest, CreateField200Response, CreateFieldRequest, DeleteApp200Response, DeleteAppRequest, DeleteFields200Response, DeleteFieldsRequest, DeleteRecords200Response, DeleteRecordsRequest, DeleteTableResponse, Field, FieldUsage, GetRelationships200Response, GetTempTokenDBID200Response, ReportRunResponse, RunQueryRequest, RunQueryResponse, Table, UpdateTableRequest, Upsert200Response, Upsert207Response, UpsertRequest } from "../generated/models";

                export interface QuickbaseClient {
                  createApp: (params: { body: CreateAppRequest }) => Promise<CreateApp200Response>;
                  getApp: (params: { appId: string }) => Promise<App>;
                  deleteApp: (params: { appId: string; body: DeleteAppRequest }) => Promise<DeleteApp200Response>;
                  getAppEvents: (params: { appId: string }) => Promise<any[]>;
                  copyApp: (params: { appId: string; body: CopyAppRequest }) => Promise<CopyApp200Response>;
                  getAppTables: (params: { appId: string }) => Promise<Table[]>;
                  createTable: (params: { appId: string; body: any }) => Promise<Table>;
                  getTable: (params: { tableId: string; appId: string }) => Promise<Table>;
                  updateTable: (params: { tableId: string; appId: string; body: UpdateTableRequest }) => Promise<Table>;
                  deleteTable: (params: { tableId: string; appId: string }) => Promise<DeleteTableResponse>;
                  getRelationships: (params: { tableId: string; skip?: number }) => Promise<GetRelationships200Response>;
                  createRelationship: (params: { tableId: string; generated?: any }) => Promise<{ [key: string]: any }>;
                  updateRelationship: (params: { tableId: string; relationshipId: any; generated?: any }) => Promise<{ [key: string]: any }>;
                  deleteRelationship: (params: { tableId: string; relationshipId: any }) => Promise<{ [key: string]: any }>;
                  getTableReports: (params: { tableId: string }) => Promise<any[]>;
                  getReport: (params: { tableId: string; reportId: string }) => Promise<{ [key: string]: any }>;
                  runReport: (params: { reportId: string; generated: any }) => Promise<ReportRunResponse[]>;
                  getFields: (params: { tableId: string; includeFieldPerms?: boolean }) => Promise<Field[]>;
                  createField: (params: { tableId: string; body: CreateFieldRequest }) => Promise<CreateField200Response>;
                  deleteFields: (params: { tableId: string; body: DeleteFieldsRequest }) => Promise<DeleteFields200Response>;
                  getField: (params: { fieldId: number; tableId: string; includeFieldPerms?: boolean }) => Promise<Field>;
                  getFieldsUsage: (params: { tableId: string; skip?: number; top?: number }) => Promise<FieldUsage[]>;
                  getFieldUsage: (params: { fieldId: number; tableId: string }) => Promise<FieldUsage[]>;
                  runFormula: (params: { generated?: any }) => Promise<{ [key: string]: any }>;
                  upsert: (params: { body: UpsertRequest }) => Promise<Upsert200Response | Upsert207Response>;
                  deleteRecords: (params: { body: DeleteRecordsRequest }) => Promise<DeleteRecords200Response>;
                  runQuery: (params: { body: RunQueryRequest }) => Promise<RunQueryResponse>;
                  getTempTokenDBID: (params: { dbid: string }) => Promise<GetTempTokenDBID200Response>;
                  exchangeSsoToken: (params: { generated?: any }) => Promise<{ [key: string]: any }>;
                  cloneUserToken: (params: { generated?: any }) => Promise<{ [key: string]: any }>;
                  transferUserToken: (params: { generated?: any }) => Promise<{ [key: string]: any }>;
                  deactivateUserToken: (params: {  }) => Promise<{ [key: string]: any }>;
                  deleteUserToken: (params: {  }) => Promise<{ [key: string]: any }>;
                  downloadFile: (params: { tableId: string; recordId: number; fieldId: number; versionNumber: number }) => Promise<any>;
                  deleteFile: (params: { tableId: string; recordId: number; fieldId: number; versionNumber: number }) => Promise<{ [key: string]: any }>;
                  getUsers: (params: { accountId?: any; generated?: { [key: string]: any } }) => Promise<{ [key: string]: any }>;
                  denyUsers: (params: { accountId?: any; generated?: string[] }) => Promise<{ [key: string]: any }>;
                  denyUsersAndGroups: (params: { accountId?: any; shouldDeleteFromGroups: boolean; generated?: string[] }) => Promise<{ [key: string]: any }>;
                  undenyUsers: (params: { accountId?: any; generated?: string[] }) => Promise<{ [key: string]: any }>;
                  addMembersToGroup: (params: { gid: any; generated?: string[] }) => Promise<{ [key: string]: any }>;
                  removeMembersFromGroup: (params: { gid: any; generated?: string[] }) => Promise<{ [key: string]: any }>;
                  addManagersToGroup: (params: { gid: any; generated?: string[] }) => Promise<{ [key: string]: any }>;
                  removeManagersFromGroup: (params: { gid: any; generated?: string[] }) => Promise<{ [key: string]: any }>;
                  addSubgroupsToGroup: (params: { gid: any; generated?: string[] }) => Promise<{ [key: string]: any }>;
                  removeSubgroupsFromGroup: (params: { gid: any; generated?: string[] }) => Promise<{ [key: string]: any }>;
                  audit: (params: { generated?: any }) => Promise<{ [key: string]: any }>;
                  platformAnalyticReads: (params: { day?: string }) => Promise<{ [key: string]: any }>;
                  platformAnalyticEventSummaries: (params: { accountId?: any; generated?: any }) => Promise<any>;
                  exportSolution: (params: { solutionId: string; qBLVersion?: string }) => Promise<any>;
                  updateSolution: (params: { solutionId: string; generated?: any; xQBLErrorsAsSuccess?: boolean }) => Promise<any>;
                  createSolution: (params: { generated?: any; xQBLErrorsAsSuccess?: boolean }) => Promise<any>;
                  exportSolutionToRecord: (params: { solutionId: string; tableId: string; fieldId: number; xQBLErrorsAsSuccess?: boolean; qBLVersion?: string }) => Promise<any>;
                  createSolutionFromRecord: (params: { tableId: string; fieldId: number; recordId: number; xQBLErrorsAsSuccess?: boolean }) => Promise<any>;
                  updateSolutionToRecord: (params: { solutionId: string; tableId: string; fieldId: number; recordId: number; xQBLErrorsAsSuccess?: boolean }) => Promise<any>;
                  changesetSolution: (params: { solutionId: string; generated?: any; xQBLErrorsAsSuccess?: boolean }) => Promise<any>;
                  changesetSolutionFromRecord: (params: { solutionId: string; tableId: string; fieldId: number; recordId: number; xQBLErrorsAsSuccess?: boolean }) => Promise<any>;
                  generateDocument: (params: { templateId: any; tableId: string; recordId?: any; filename: string; accept?: string; format?: string; margin?: string; unit?: string; pageSize?: string; orientation?: string; realm?: string }) => Promise<{ [key: string]: any }>;
                }
        - name: index.ts
          type: file
        - name: log-gen.ts
          type: file
        - name: openapi-jars
          type: directory
          children:
            - name: openapi-generator-cli-7.12.0.jar
              type: file
        - name: quickbaseClient.ts
          type: file
          contents: |
            // src/quickbaseClient.ts
            import { QuickbaseClient as IQuickbaseClient } from "./generated-unified/QuickbaseClient.ts";
            import {
              Configuration,
              HTTPHeaders,
              ResponseError,
            } from "./generated/runtime.ts";
            import * as apis from "./generated/apis/index.ts";
            import { TokenCache } from "./tokenCache.ts";

            // Re-export all model types from generated/models
            export * from "./generated/models";

            const simplifyName = (name: string): string =>
              name
                .replace(/ById$/, "")
                .replace(/Api$/, "")
                .replace(/^(\w)/, (_, c) => c.toLowerCase());

            export interface QuickbaseClient extends IQuickbaseClient {}

            export interface QuickbaseConfig {
              realm: string;
              userToken?: string;
              tempToken?: string;
              useTempTokens?: boolean;
              debug?: boolean;
              fetchApi?: typeof fetch;
            }

            export interface TempTokenParams {
              appId?: string;
              tableId?: string;
              dbid?: string;
            }

            type ApiMethod<K extends keyof QuickbaseClient> = (
              requestParameters: Parameters<QuickbaseClient[K]>[0],
              initOverrides?: RequestInit
            ) => Promise<ReturnType<QuickbaseClient[K]>>;

            interface MethodInfo<K extends keyof QuickbaseClient> {
              api: any;
              method: ApiMethod<K>;
              paramMap: string[];
            }

            type MethodMap = { [K in keyof QuickbaseClient]: MethodInfo<K> };

            const getParamNames = (fn: (...args: any[]) => any): string[] =>
              fn
                .toString()
                .slice(fn.toString().indexOf("(") + 1, fn.toString().indexOf(")"))
                .split(",")
                .map((p) => p.trim().split("=")[0].trim())
                .filter((p) => p && !p.match(/^\{/) && p !== "options");

            const extractDbid = (
              params: Partial<TempTokenParams>,
              errorMessage: string
            ): string => {
              const dbid = params.dbid || params.tableId || params.appId;
              if (!dbid) {
                throw new Error(errorMessage);
              }
              return dbid;
            };

            export function quickbase(config: QuickbaseConfig): QuickbaseClient {
              const {
                realm,
                userToken,
                tempToken: initialTempToken,
                useTempTokens,
                fetchApi,
                debug,
              } = config;
              const baseUrl = `https://api.quickbase.com/v1`;

              const tokenCache = new TokenCache();

              const baseHeaders: HTTPHeaders = {
                "QB-Realm-Hostname": `${realm}.quickbase.com`,
                "Content-Type": "application/json",
              };

              if (initialTempToken) {
                baseHeaders["Authorization"] = `QB-TEMP-TOKEN ${initialTempToken}`;
              } else if (userToken && !useTempTokens) {
                baseHeaders["Authorization"] = `QB-USER-TOKEN ${userToken}`;
              }

              const defaultFetch: typeof fetch | undefined =
                typeof globalThis.window !== "undefined"
                  ? globalThis.window.fetch.bind(globalThis.window)
                  : undefined;
              const configuration = new Configuration({
                basePath: baseUrl,
                headers: { ...baseHeaders },
                fetchApi: fetchApi || defaultFetch,
                credentials: useTempTokens ? "include" : "omit",
              });

              if (!configuration.fetchApi && typeof globalThis.window === "undefined") {
                throw new Error(
                  "fetchApi must be provided in non-browser environments (e.g., Node.js)"
                );
              }

              const apiInstances = Object.fromEntries(
                Object.entries(apis)
                  .filter(([name]) => name.endsWith("Api"))
                  .map(([name, ApiClass]) => [
                    name.replace("Api", "").toLowerCase(),
                    new ApiClass(configuration),
                  ])
              );

              const methodMap = buildMethodMap();

              function buildMethodMap(): MethodMap {
                const methodMap: Partial<MethodMap> = {};
                const isValidMethod = (name: string) =>
                  !name.startsWith("_") &&
                  name !== "constructor" &&
                  !["Middleware", "Pre", "Post", "Raw"].some((s) => name.includes(s));

                for (const [apiName, api] of Object.entries(apiInstances)) {
                  Object.getOwnPropertyNames(Object.getPrototypeOf(api))
                    .filter(
                      (name) =>
                        isValidMethod(name) &&
                        typeof api[name as keyof typeof api] === "function"
                    )
                    .forEach((rawMethodName) => {
                      const simplifiedName = simplifyName(
                        rawMethodName
                      ) as keyof QuickbaseClient;
                      const method = api[rawMethodName as keyof typeof api];
                      const boundMethod = method.bind(api as any) as unknown;
                      if (typeof boundMethod === "function" && boundMethod.length <= 2) {
                        methodMap[simplifiedName] = {
                          api,
                          method: boundMethod as ApiMethod<typeof simplifiedName>,
                          paramMap: getParamNames(method),
                        };
                      }
                    });
                }
                return methodMap as MethodMap;
              }

              const fetchTempToken = async (dbid: string): Promise<string> => {
                const effectiveFetch = fetchApi || defaultFetch;
                if (!effectiveFetch) {
                  throw new Error(
                    "No fetch implementation available for fetching temp token"
                  );
                }

                const response = await effectiveFetch(
                  `https://api.quickbase.com/v1/auth/temporary/${dbid}`,
                  {
                    method: "GET",
                    headers: { ...baseHeaders },
                    credentials: "include",
                  }
                );

                if (!response.ok) {
                  const errorBody: { message?: string } = await response.json();
                  throw new Error(
                    `API Error: ${errorBody.message || "Unknown error"} (Status: ${
                      response.status
                    })`
                  );
                }

                const tokenResult = await response.json();
                const token = tokenResult.temporaryAuthorization;
                if (!token) {
                  throw new Error("No temporary token returned from API");
                }
                tokenCache.set(dbid, token);
                if (debug) {
                  console.log(
                    `Fetched and cached new token for dbid: ${dbid}`,
                    token,
                    `Expires at: ${new Date(
                      Date.now() + (4 * 60 + 50) * 1000
                    ).toISOString()}`
                  );
                }
                return token;
              };

              async function invokeMethod<K extends keyof QuickbaseClient>(
                methodName: K,
                params: Parameters<QuickbaseClient[K]>[0] & Partial<TempTokenParams>,
                retryCount: number = 0
              ): Promise<ReturnType<QuickbaseClient[K]>> {
                const methodInfo = methodMap[methodName];
                if (!methodInfo) {
                  throw new Error(`Method ${methodName} not found`);
                }

                const requestParameters =
                  methodInfo.paramMap.length === 1 &&
                  methodInfo.paramMap[0] === "requestParameters"
                    ? { requestParameters: params }
                    : params;
                let requestOptions: RequestInit = {};

                const selectedToken =
                  initialTempToken || (userToken && !useTempTokens ? userToken : undefined);

                if (methodName === "getTempTokenDBID" && useTempTokens) {
                  const dbid = extractDbid(params, "No dbid provided for getTempTokenDBID");
                  const cachedToken = tokenCache.get(dbid);
                  if (cachedToken) {
                    return { temporaryAuthorization: cachedToken } as ReturnType<
                      QuickbaseClient[K]
                    >;
                  }
                }

                let authorizationToken = selectedToken;
                if (useTempTokens && !authorizationToken) {
                  const dbid = extractDbid(
                    params,
                    `No dbid found in params for ${methodName} to fetch temp token`
                  );
                  const cachedToken = tokenCache.get(dbid);
                  authorizationToken = cachedToken || (await fetchTempToken(dbid));
                  if (methodName === "getTempTokenDBID") {
                    return { temporaryAuthorization: authorizationToken } as ReturnType<
                      QuickbaseClient[K]
                    >;
                  }
                  requestOptions.headers = {
                    ...baseHeaders,
                    Authorization: `QB-TEMP-TOKEN ${authorizationToken}`,
                  };
                } else if (authorizationToken) {
                  requestOptions.headers = {
                    ...baseHeaders,
                    Authorization: `QB-USER-TOKEN ${authorizationToken}`,
                  };
                }

                try {
                  return await methodInfo.method(requestParameters, requestOptions);
                } catch (error) {
                  if (
                    error instanceof ResponseError &&
                    error.response.status === 401 &&
                    retryCount < 1 &&
                    useTempTokens
                  ) {
                    if (debug) {
                      console.log(
                        `Authorization error for ${methodName}, refreshing token:`,
                        error.message
                      );
                    }
                    const dbid = extractDbid(
                      params,
                      `No dbid to refresh token after authorization error`
                    );
                    authorizationToken = await fetchTempToken(dbid);
                    requestOptions.headers = {
                      ...baseHeaders,
                      Authorization: `QB-TEMP-TOKEN ${authorizationToken}`,
                    };
                    if (debug) {
                      console.log(`Retrying ${methodName} with new token`);
                    }
                    return invokeMethod(methodName, params, retryCount + 1);
                  }
                  if (error instanceof ResponseError) {
                    let errorMessage = error.message;
                    try {
                      const errorBody: { message?: string } = await error.response.json();
                      if (debug) {
                        console.log(`Error response body for ${methodName}:`, errorBody);
                      }
                      errorMessage = errorBody.message || errorMessage;
                    } catch (e) {
                      // Silent fail on parse error
                    }
                    throw new Error(
                      `API Error: ${errorMessage} (Status: ${error.response.status})`
                    );
                  }
                  throw error;
                }
              }

              const proxy = new Proxy<QuickbaseClient>({} as QuickbaseClient, {
                get: (_, prop: string): ((params: any) => Promise<any>) | undefined => {
                  if (prop in methodMap) {
                    const methodName = prop as keyof QuickbaseClient;
                    return (params: Parameters<QuickbaseClient[typeof methodName]>[0]) =>
                      invokeMethod(methodName, params);
                  }
                  return undefined;
                },
              });

              return proxy;
            }
        - name: tokenCache.ts
          type: file
          contents: |
            interface CachedToken {
              token: string;
              expiresAt: number; // Timestamp in milliseconds
            }

            export class TokenCache {
              private cache: Map<string, CachedToken>;
              private readonly lifespan: number; // Token lifespan in milliseconds

              constructor(lifespan: number = 4 * 60 * 1000 + 50 * 1000) {
                // Default 4:50
                this.cache = new Map<string, CachedToken>();
                this.lifespan = lifespan;
              }

              get(dbid: string): string | undefined {
                const entry = this.cache.get(dbid);
                const now = Date.now();
                if (entry && entry.expiresAt > now) {
                  return entry.token;
                }
                return undefined; // Expired or not found
              }

              // New method to get full entry
              getEntry(dbid: string): CachedToken | undefined {
                const entry = this.cache.get(dbid);
                const now = Date.now();
                if (entry && entry.expiresAt > now) {
                  return entry;
                }
                return undefined; // Expired or not found
              }

              set(dbid: string, token: string): void {
                const now = Date.now();
                this.cache.set(dbid, {
                  token,
                  expiresAt: now + this.lifespan,
                });
              }

              dump(): [string, CachedToken][] {
                return Array.from(this.cache.entries());
              }

              // New method to clear the cache
              clear(): void {
                this.cache.clear();
              }
            }
    - name: test-artifacts
      type: directory
      children:
        - name: .last-run.json
          type: file
    - name: test-results.json
      type: file
    - name: tests
      type: directory
      children:
        - name: playwright
          type: directory
          children:
            - name: qb
              type: directory
              children:
                - name: auth
                  type: directory
                  children:
                    - name: cacheSwitching.test.ts
                      type: file
                    - name: fetchTempToken401.test.ts
                      type: file
                    - name: getAppWithUserToken.test.ts
                      type: file
                    - name: getTempToken.test.ts
                      type: file
                    - name: tokenPrefetch.test.ts
                      type: file
                    - name: tokenRenewal.test.ts
                      type: file
        - name: setup.ts
          type: file
        - name: vitest
          type: directory
          children:
            - name: qb
              type: directory
              children:
                - name: apps
                  type: directory
                  children:
                    - name: copyApp.test.ts
                      type: file
                    - name: createApp.test.ts
                      type: file
                    - name: deleteApp.test.ts
                      type: file
                    - name: getApp.test.ts
                      type: file
                - name: fields
                  type: directory
                  children:
                    - name: createField.test.ts
                      type: file
                    - name: deleteFields.test.ts
                      type: file
                    - name: getField.test.ts
                      type: file
                    - name: getFieldUsage.test.ts
                      type: file
                    - name: getFields.test.ts
                      type: file
                    - name: getFieldsUsage.test.ts
                      type: file
                - name: index.ts
                  type: file
                - name: records
                  type: directory
                  children:
                    - name: deleteRecords.test.ts
                      type: file
                    - name: runQuery.test.ts
                      type: file
                    - name: upsert.test.ts
                      type: file
                - name: tables
                  type: directory
                  children:
                    - name: createTable.test.ts
                      type: file
                    - name: deleteTable.test.ts
                      type: file
                    - name: getAppTables.test.ts
                      type: file
                    - name: getRelationships.test.ts
                      type: file
                    - name: getTable.test.ts
                      type: file
                    - name: updateTable.test.ts
                      type: file
            - name: unit
              type: directory
              children:
                - name: apps
                  type: directory
                  children:
                    - name: copyApp.test.ts
                      type: file
                    - name: createApp.test.ts
                      type: file
                    - name: deleteApp.test.ts
                      type: file
                    - name: getApp.test.ts
                      type: file
                - name: auth
                  type: directory
                  children:
                    - name: fetchTempToken401.test.ts
                      type: file
                    - name: getTempToken.test.ts
                      type: file
                    - name: retryOn401.test.ts
                      type: file
                    - name: two401s.test.ts
                      type: file
                - name: fields
                  type: directory
                  children:
                    - name: createField.test.ts
                      type: file
                    - name: deleteFields.test.ts
                      type: file
                    - name: getField.test.ts
                      type: file
                    - name: getFieldUsage.test.ts
                      type: file
                    - name: getFields.test.ts
                      type: file
                    - name: getFieldsUsage.test.ts
                      type: file
                - name: index.ts
                  type: file
                - name: records
                  type: directory
                  children:
                    - name: deleteRecords.test.ts
                      type: file
                    - name: runQuery.test.ts
                      type: file
                    - name: upsert.test.ts
                      type: file
                - name: tables
                  type: directory
                  children:
                    - name: createTable.test.ts
                      type: file
                    - name: deleteTable.test.ts
                      type: file
                    - name: getAppTables.test.ts
                      type: file
                    - name: getRelationships.test.ts
                      type: file
                    - name: getTable.test.ts
                      type: file
                    - name: updateTable.test.ts
                      type: file
    - name: text.txt
      type: file
    - name: tsconfig.json
      type: file
      contents: |-
        {
          "compilerOptions": {
            "target": "ESNext",
            "module": "ESNext",
            "moduleResolution": "bundler",
            "strict": true,
            "lib": ["ES2015", "ESNext", "DOM"],
            "types": ["node", "playwright/test"],
            "esModuleInterop": true,
            "resolveJsonModule": true,
            "allowImportingTsExtensions": true,
            "noEmit": true,
            "outDir": "dist",
            "rootDir": ".",
            "declaration": true,
            "sourceMap": true,
            "baseUrl": ".",
            "paths": {
              "@/*": ["src/*"],      // Matches Vite's @ -> src/
              "@tests/*": ["tests/*"] // Matches Vite's @tests -> tests/
            }
          },
          "include": ["src/**/*", "tests/**/*"],
          "exclude": ["node_modules", "dist", "src/generated-old"],
          "ts-node": {
            "esm": true,
            "transpileOnly": true
          }
        }
    - name: versionrc.json
      type: file
    - name: vitest.config.ts
      type: file
      contents: |
        // vitest.config.ts
        import { defineConfig } from "vitest/config";
        import path from "path";
        import dotenv from "dotenv"; // Add this import

        // Load .env variables before tests run
        dotenv.config({ path: path.resolve(__dirname, ".env") });

        export default defineConfig({
          test: {
            environment: "jsdom",
            include: ["tests/vitest/**/**/*.test.ts"],
            setupFiles: ["tests/setup.ts"], // Relative path from root
            pool: "forks",
            poolOptions: {
              forks: {
                singleFork: true, // Run tests sequentially
              },
            },
          },
          resolve: {
            alias: {
              "@": path.resolve(__dirname, "./src"), // For src/ imports
              "@tests": path.resolve(__dirname, "./tests"), // For tests/ imports
            },
          },
        });

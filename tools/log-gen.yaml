project: >-
  quickbase-js
date: >-
  3/18/2025
root: >-
  /home/drew/Projects/quickbase-js
goals:
  - >-
    A
    library
    for
    interacting
    with
    the
    QuickBase
    RESTful
    API.
  - >-
    Use
    OpenAPI
    to
    generate
    types
    and
    methods
    using
    a
    proxy.
    Validate
    with
    tests.
  - >-
    Provide
    robust
    and
    intuitive
    temporary
    token
    support
    for
    browser
    environments.
  - >-
    User
    Tokens
    support
    both
    Node.js
    and
    browser
    environments.
  - >-
    Use
    case:
    JS
    frameworks
    like
    React,
    Vue,
    and
    Angular
    hosted
    in
    QuickBase
    code
    pages.
  - >-
    Enable
    a
    flexible
    or
    native
    fetch
    in
    the
    browser.
  - >-
    Enable
    a
    flexible
    fetch
    framework
    in
    Node.js.
  - >-
    #
  - >-
    No
    manual
    updating
    methods
    when
    the
    QuickBase
    API
    changes.
  - >-
    The
    proxy
    magic
    dynamically
    maps
    generated
    methods
    and
    types.
  - >-
    #
  - >-
    TokenCache
    is
    defined
    per
    quickbaseClient
    call,
    so
    each
    instance
    has
    its
    own
    isolated
    TokenCache.
  - >-
    Each
    quickbase
    client
    instance
    has
    an
    isolated
    and
    individual
    token
    cache.
pipelineOverview:
  - >-
    What
    I’m
    Trying
    to
    Do
  - >-
    My
    approach
    is
    to
    ensure
    AppsApi.ts
    is
    generated
    with
    getAppById
    so
    QuickbaseClient.ts
    can
    map
    it
    to
    client.getApp.
    Steps
    include:
  - >-
    Fix
    fix-spec.ts:
  - >-
    Add
    tags:
    ["Apps"]
    to
    /apps/*
    endpoints
    to
    group
    them
    into
    AppsApi.ts.
  - >-
    Ensure
    all
    endpoints
    and
    models
    are
    correctly
    defined
    and
    typed.
  - >-
    Debug
    regenerate-client.ts:
  - >-
    Enhance
    logging
    to
    catch
    why
    AppsApi.ts
    isn’t
    generated.
  - >-
    Test
    if
    getAppById
    appears
    in
    another
    file
    (e.g.,
    DefaultApi.ts).
  - >-
    Update
    QuickbaseClient.ts:
  - >-
    Adjust
    imports
    to
    use
    the
    correct
    API
    class
    once
    generated.
  - >-
    Test
    and
    Iterate:
  - >-
    Run
    npm
    run
    fix-spec,
    npm
    run
    regenerate,
    and
    npm
    run
    test
    to
    verify
    AppsApi.ts
    exists
    and
    test.ts
    works.
  - >-
    The
    latest
    fix-spec.ts
    with
    tags
    aims
    to
    force
    the
    generator
    to
    create
    AppsApi.ts,
    addressing
    the
    missing
    file
    issue.
  - >-
    Relevant
    Project
    Files
  - >-
    Here’s
    a
    list
    of
    files
    that
    would
    help
    understand
    and
    resolve
    this
    problem,
    along
    with
    their
    roles:
  - >-
    src/code-generation/fix-spec.ts:
  - >-
    Role:
    Modifies
    the
    original
    QuickBase
    spec
    (e.g.,
    QuickBase_RESTful_*.json)
    to
    create
    quickbase-fixed.json
    with
    required
    endpoints
    (e.g.,
    /apps/{appId}).
  - >-
    Relevance:
    Defines
    the
    spec
    fed
    to
    the
    generator;
    errors
    here
    affect
    generation.
  - >-
    src/code-generation/quickbase-fixed.json:
  - >-
    Role:
    The
    processed
    OpenAPI
    spec
    used
    by
    regenerate-client.ts
    to
    generate
    code.
  - >-
    Relevance:
    Confirms
    if
    /apps/{appId}
    is
    correctly
    structured
    with
    operationId:
    "getAppById".
  - >-
    src/code-generation/regenerate-client.ts:
  - >-
    Role:
    Runs
    OpenAPI
    Generator
    to
    produce
    src/generated/
    files
    (APIs
    and
    models)
    and
    fixes
    .ts
    extensions
    with
    ts-morph.
  - >-
    Relevance:
    Controls
    the
    generation
    process;
    logs
    reveal
    why
    AppsApi.ts
    is
    missing.
  - >-
    src/generated/apis/AppsApi.ts
    (if
    exists):
  - >-
    Role:
    Should
    contain
    getAppById
    method
    for
    /apps/{appId}
    GET.
  - >-
    Relevance:
    Missing
    file
    is
    the
    core
    issue;
    its
    absence
    breaks
    QuickbaseClient.ts.
  - >-
    src/generated/apis/DefaultApi.ts:
  - >-
    Role:
    Default
    API
    class
    for
    untagged
    operations.
  - >-
    Relevance:
    Might
    contain
    getAppById
    if
    tags
    are
    misconfigured.
  - >-
    src/QuickbaseClient.ts:
  - >-
    Role:
    Wraps
    generated
    API
    classes
    (e.g.,
    AppsApi)
    in
    a
    Proxy
    for
    ergonomic
    calls
    (e.g.,
    client.getApp).
  - >-
    Relevance:
    Fails
    to
    import
    AppsApi.ts,
    causing
    the
    runtime
    error.
  - >-
    src/test.ts:
  - >-
    Role:
    Test
    script
    calling
    client.getApp({
    appId
    }).
  - >-
    Relevance:
    Final
    validation
    point;
    shows
    if
    the
    fix
    works.
  - >-
    .env.development:
  - >-
    Role:
    Stores
    QB_REALM,
    QB_USER_TOKEN,
    QB_APP_ID
    for
    API
    authentication.
  - >-
    Relevance:
    Ensures
    the
    API
    call
    has
    valid
    credentials
    (not
    the
    current
    issue,
    but
    critical
    for
    success).
  - >-
    src/specs/QuickBase_RESTful_API_2025-03-04T06_22_39.725Z.json
    (or
    similar):
  - >-
    Role:
    Original
    QuickBase
    API
    spec
    before
    fix-spec.ts
    processing.
  - >-
    Relevance:
    Shows
    how
    /apps/{appId}
    was
    originally
    defined,
    helping
    identify
    conflicts.
  - >-
    package.json:
  - >-
    Role:
    Defines
    scripts
    (fix-spec,
    regenerate,
    test)
    and
    dependencies
    (e.g.,
    ts-node,
    openapi-generator-cli).
  - >-
    Relevance:
    Confirms
    script
    commands
    and
    versions
    align
    with
    our
    process.
  - >-
    What
    We
    Achieved
  - >-
    Goal
    Met:
    You
    can
    now
    call
    client.getApp({
    appId:
    "buwai2zpe"
    })
    and
    get
    the
    app
    details
    {
    id:
    'buwai2zpe',
    name:
    'qb-copy'
    }.
  - >-
    Fixes
    Applied:
  - >-
    Added
    tags:
    ["Apps"]
    in
    fix-spec.ts
    to
    ensure
    AppsApi.ts
    is
    generated
    with
    getAppById.
  - >-
    Updated
    QuickbaseClient.ts
    to:
  - >-
    Use
    prototype
    methods
    via
    Object.getOwnPropertyNames.
  - >-
    Bind
    methods
    to
    preserve
    context
    with
    .bind(api).
  - >-
    Handle
    getAppById’s
    direct
    JSON
    return
    instead
    of
    a
    Response
    object.
  - >-
    Result:
    The
    ergonomic
    API
    you
    wanted
    (client.getApp)
    works
    seamlessly
    with
    the
    generated
    AppsApi.ts.
  - >-
    Why
    It
    Works
    Now
  - >-
    fix-spec.ts:
  - >-
    Correctly
    defined
    /apps/{appId}
    with
    operationId:
    "getAppById"
    and
    tags:
    ["Apps"],
    ensuring
    AppsApi.ts
    generation.
  - >-
    regenerate-client.ts:
  - >-
    Successfully
    ran
    OpenAPI
    Generator
    to
    produce
    AppsApi.ts
    with
    getAppById.
  - >-
    QuickbaseClient.ts:
  - >-
    buildMethodMap
    now
    captures
    getAppById
    and
    maps
    it
    to
    getApp.
  - >-
    invokeMethod
    passes
    {
    appId:
    'buwai2zpe'
    }
    as
    requestParameters
    and
    handles
    the
    JSON
    response
    directly.
  - >-
    test.ts:
  - >-
    Calls
    client.getApp
    and
    logs
    the
    result,
    proving
    the
    end-to-end
    flow.
tree:
  name: >-
    .
  type: >-
    directory
  children:
    - name: >-
        .env
      type: >-
        file
    - name: >-
        .gitignore
      type: >-
        file
    - name: >-
        CHANGELOG.md
      type: >-
        file
    - name: >-
        LICENSE
      type: >-
        file
    - name: >-
        README.md
      type: >-
        file
    - name: >-
        build-common.js
      type: >-
        file
    - name: >-
        build-esm.js
      type: >-
        file
    - name: >-
        build-umd.js
      type: >-
        file
    - name: >-
        dist
      type: >-
        directory
      children:
        - name: >-
            esm
          type: >-
            directory
          children:
            - name: >-
                quickbase.d.ts
              type: >-
                file
            - name: >-
                quickbase.js
              type: >-
                file
            - name: >-
                quickbase.js.map
              type: >-
                file
            - name: >-
                quickbase.min.js
              type: >-
                file
            - name: >-
                quickbase.min.js.map
              type: >-
                file
        - name: >-
            umd
          type: >-
            directory
          children:
            - name: >-
                quickbase.umd.js
              type: >-
                file
            - name: >-
                quickbase.umd.js.map
              type: >-
                file
            - name: >-
                quickbase.umd.min.js
              type: >-
                file
            - name: >-
                quickbase.umd.min.js.map
              type: >-
                file
    - name: >-
        examples
      type: >-
        directory
      children:
        - name: >-
            quicbase-jsCDN.html
          type: >-
            file
        - name: >-
            react.js
          type: >-
            file
        - name: >-
            vanillajs.html
          type: >-
            file
    - name: >-
        open-api
      type: >-
        directory
      children:
        - name: >-
            fix-spec-main.ts
          type: >-
            file
        - name: >-
            generate-override-report.ts
          type: >-
            file
        - name: >-
            generate-unified-interface.ts
          type: >-
            file
        - name: >-
            regenerate-client.ts
          type: >-
            file
        - name: >-
            schema
          type: >-
            directory
          children:
            - name: >-
                enhance-general.ts
              type: >-
                file
            - name: >-
                fix-arrays.ts
              type: >-
                file
            - name: >-
                tags
              type: >-
                directory
              children:
                - name: >-
                    apps.ts
                  type: >-
                    file
                - name: >-
                    fields.ts
                  type: >-
                    file
                - name: >-
                    groups.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    records.ts
                  type: >-
                    file
                - name: >-
                    tables.ts
                  type: >-
                    file
                - name: >-
                    users.ts
                  type: >-
                    file
        - name: >-
            types
          type: >-
            directory
          children:
            - name: >-
                spec.ts
              type: >-
                file
        - name: >-
            utils
          type: >-
            directory
          children:
            - name: >-
                generateJsDoc.ts
              type: >-
                file
            - name: >-
                infer-schema.ts
              type: >-
                file
            - name: >-
                naming.ts
              type: >-
                file
    - name: >-
        openapitools.json
      type: >-
        file
    - name: >-
        package-lock.json
      type: >-
        file
    - name: >-
        package.json
      type: >-
        file
    - name: >-
        playwright.config.ts
      type: >-
        file
    - name: >-
        rollup.config.js
      type: >-
        file
    - name: >-
        src
      type: >-
        directory
      children:
        - name: >-
            RateLimitError.ts
          type: >-
            file
        - name: >-
            ThrottleBucket.ts
          type: >-
            file
        - name: >-
            generated
          type: >-
            directory
          children:
            - name: >-
                .openapi-generator
              type: >-
                directory
              children:
                - name: >-
                    FILES
                  type: >-
                    file
                - name: >-
                    VERSION
                  type: >-
                    file
            - name: >-
                .openapi-generator-ignore
              type: >-
                file
            - name: >-
                apis
              type: >-
                directory
              children:
                - name: >-
                    AppsApi.ts
                  type: >-
                    file
                - name: >-
                    AuditApi.ts
                  type: >-
                    file
                - name: >-
                    AuthApi.ts
                  type: >-
                    file
                - name: >-
                    DocumentTemplatesApi.ts
                  type: >-
                    file
                - name: >-
                    FieldsApi.ts
                  type: >-
                    file
                - name: >-
                    FilesApi.ts
                  type: >-
                    file
                - name: >-
                    FormulasApi.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticsApi.ts
                  type: >-
                    file
                - name: >-
                    RecordsApi.ts
                  type: >-
                    file
                - name: >-
                    ReportsApi.ts
                  type: >-
                    file
                - name: >-
                    SolutionsApi.ts
                  type: >-
                    file
                - name: >-
                    TablesApi.ts
                  type: >-
                    file
                - name: >-
                    UserTokenApi.ts
                  type: >-
                    file
                - name: >-
                    UsersApi.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
            - name: >-
                index.ts
              type: >-
                file
            - name: >-
                models
              type: >-
                directory
              children:
                - name: >-
                    AddManagersToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddManagersToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    AddMembersToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddMembersToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    AddSubgroupsToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddSubgroupsToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    Audit200Response.ts
                  type: >-
                    file
                - name: >-
                    Audit202Response.ts
                  type: >-
                    file
                - name: >-
                    AuditRequest.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200ResponseInnerChangesInnerInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution404Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CloneUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    CloneUserTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    CopyApp200Response.ts
                  type: >-
                    file
                - name: >-
                    CopyAppRequest.ts
                  type: >-
                    file
                - name: >-
                    CopyAppRequestProperties.ts
                  type: >-
                    file
                - name: >-
                    CreateApp200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateAppRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateField200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateFieldRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateFieldRequestProperties.ts
                  type: >-
                    file
                - name: >-
                    CreateRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateRelationshipRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInnerCreatedResourcesInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInnerCreatedResourcesInnerAppsInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CreateTable200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateTableRequest.ts
                  type: >-
                    file
                - name: >-
                    DeactivateUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteApp200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteAppRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteFields200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteFieldsRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteFile200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteRecords200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteRecordsRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteTable200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersAndGroups200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersAndGroupsRequest.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    DownloadFile200Response.ts
                  type: >-
                    file
                - name: >-
                    ExchangeSsoToken200Response.ts
                  type: >-
                    file
                - name: >-
                    ExchangeSsoTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution404Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    GenerateDocument200Response.ts
                  type: >-
                    file
                - name: >-
                    GetApp200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppEvents200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppTables200Response.ts
                  type: >-
                    file
                - name: >-
                    GetField200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFieldUsage200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFields200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFieldsUsage200Response.ts
                  type: >-
                    file
                - name: >-
                    GetRelationships200Response.ts
                  type: >-
                    file
                - name: >-
                    GetReport200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTable200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTableReports200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTempTokenDBID200Response.ts
                  type: >-
                    file
                - name: >-
                    GetUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    GetUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    Permission.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200Response.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseMetadata.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseTotals.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseWhereInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummariesRequest.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummariesRequestWhereInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticReads200Response.ts
                  type: >-
                    file
                - name: >-
                    Record.ts
                  type: >-
                    file
                - name: >-
                    RecordValue.ts
                  type: >-
                    file
                - name: >-
                    RemoveManagersFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveManagersFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RemoveMembersFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveMembersFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RemoveSubgroupsFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveSubgroupsFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RunFormula200Response.ts
                  type: >-
                    file
                - name: >-
                    RunFormulaRequest.ts
                  type: >-
                    file
                - name: >-
                    RunQuery200Response.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequest.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestGroupByInner.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestOptions.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestSortByInner.ts
                  type: >-
                    file
                - name: >-
                    RunReport200Response.ts
                  type: >-
                    file
                - name: >-
                    TransferUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    TransferUserTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    UndenyUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    UndenyUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateApp200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateAppRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateField200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateFieldRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateRelationshipRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200ResponseInnerCreatedResourcesInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    UpdateTable200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateTableRequest.ts
                  type: >-
                    file
                - name: >-
                    Upsert200Response.ts
                  type: >-
                    file
                - name: >-
                    Upsert207Response.ts
                  type: >-
                    file
                - name: >-
                    Upsert400Response.ts
                  type: >-
                    file
                - name: >-
                    UpsertRequest.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
            - name: >-
                runtime.ts
              type: >-
                file
              contents: >
                /*
                tslint:disable
                */

                /*
                eslint-disable
                */

                /**
                 * Quick Base API
                 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
                 *
                 * The version of the OpenAPI document: 1.0.0
                 * 
                 *
                 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
                 * https://openapi-generator.tech
                 * Do not edit the class manually.
                 */


                export
                const
                BASE_PATH
                =
                "https://api.quickbase.com/v1".replace(/\/+$/,
                "");


                export
                interface
                ConfigurationParameters
                {
                    basePath?: string; // override base path
                    fetchApi?: FetchAPI; // override for fetch implementation
                    middleware?: Middleware[]; // middleware to apply before/after fetch requests
                    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
                    username?: string; // parameter for basic security
                    password?: string; // parameter for basic security
                    apiKey?: string | Promise<string> | ((name: string) => string | Promise<string>); // parameter for apiKey security
                    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
                    headers?: HTTPHeaders; //header params we want to use on every request
                    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
                }


                export
                class
                Configuration
                {
                    constructor(private configuration: ConfigurationParameters = {}) {}

                    set config(configuration: Configuration) {
                        this.configuration = configuration;
                    }

                    get basePath(): string {
                        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
                    }

                    get fetchApi(): FetchAPI | undefined {
                        return this.configuration.fetchApi;
                    }

                    get middleware(): Middleware[] {
                        return this.configuration.middleware || [];
                    }

                    get queryParamsStringify(): (params: HTTPQuery) => string {
                        return this.configuration.queryParamsStringify || querystring;
                    }

                    get username(): string | undefined {
                        return this.configuration.username;
                    }

                    get password(): string | undefined {
                        return this.configuration.password;
                    }

                    get apiKey(): ((name: string) => string | Promise<string>) | undefined {
                        const apiKey = this.configuration.apiKey;
                        if (apiKey) {
                            return typeof apiKey === 'function' ? apiKey : () => apiKey;
                        }
                        return undefined;
                    }

                    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
                        const accessToken = this.configuration.accessToken;
                        if (accessToken) {
                            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
                        }
                        return undefined;
                    }

                    get headers(): HTTPHeaders | undefined {
                        return this.configuration.headers;
                    }

                    get credentials(): RequestCredentials | undefined {
                        return this.configuration.credentials;
                    }
                }


                export
                const
                DefaultConfig
                =
                new
                Configuration();


                /**
                 * This is the base class for all generated API classes.
                 */
                export
                class
                BaseAPI
                {

                    private static readonly jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
                    private middleware: Middleware[];

                    constructor(protected configuration = DefaultConfig) {
                        this.middleware = configuration.middleware;
                    }

                    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
                        const next = this.clone<T>();
                        next.middleware = next.middleware.concat(...middlewares);
                        return next;
                    }

                    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
                        const middlewares = preMiddlewares.map((pre) => ({ pre }));
                        return this.withMiddleware<T>(...middlewares);
                    }

                    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
                        const middlewares = postMiddlewares.map((post) => ({ post }));
                        return this.withMiddleware<T>(...middlewares);
                    }

                    /**
                     * Check if the given MIME is a JSON MIME.
                     * JSON MIME examples:
                     *   application/json
                     *   application/json; charset=UTF8
                     *   APPLICATION/JSON
                     *   application/vnd.company+json
                     * @param mime - MIME (Multipurpose Internet Mail Extensions)
                     * @return True if the given MIME is JSON, false otherwise.
                     */
                    protected isJsonMime(mime: string | null | undefined): boolean {
                        if (!mime) {
                            return false;
                        }
                        return BaseAPI.jsonRegex.test(mime);
                    }

                    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
                        const { url, init } = await this.createFetchParams(context, initOverrides);
                        const response = await this.fetchApi(url, init);
                        if (response && (response.status >= 200 && response.status < 300)) {
                            return response;
                        }
                        throw new ResponseError(response, 'Response returned an error code');
                    }

                    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {
                        let url = this.configuration.basePath + context.path;
                        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                            // only add the querystring to the URL if there are query parameters.
                            // this is done to avoid urls ending with a "?" character which buggy webservers
                            // do not handle correctly sometimes.
                            url += '?' + this.configuration.queryParamsStringify(context.query);
                        }

                        const headers = Object.assign({}, this.configuration.headers, context.headers);
                        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

                        const initOverrideFn =
                            typeof initOverrides === "function"
                                ? initOverrides
                                : async () => initOverrides;

                        const initParams = {
                            method: context.method,
                            headers,
                            body: context.body,
                            credentials: this.configuration.credentials,
                        };

                        const overriddenInit: RequestInit = {
                            ...initParams,
                            ...(await initOverrideFn({
                                init: initParams,
                                context,
                            }))
                        };

                        let body: any;
                        if (isFormData(overriddenInit.body)
                            || (overriddenInit.body instanceof URLSearchParams)
                            || isBlob(overriddenInit.body)) {
                          body = overriddenInit.body;
                        } else if (this.isJsonMime(headers['Content-Type'])) {
                          body = JSON.stringify(overriddenInit.body);
                        } else {
                          body = overriddenInit.body;
                        }

                        const init: RequestInit = {
                            ...overriddenInit,
                            body
                        };

                        return { url, init };
                    }

                    private fetchApi = async (url: string, init: RequestInit) => {
                        let fetchParams = { url, init };
                        for (const middleware of this.middleware) {
                            if (middleware.pre) {
                                fetchParams = await middleware.pre({
                                    fetch: this.fetchApi,
                                    ...fetchParams,
                                }) || fetchParams;
                            }
                        }
                        let response: Response | undefined = undefined;
                        try {
                            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
                        } catch (e) {
                            for (const middleware of this.middleware) {
                                if (middleware.onError) {
                                    response = await middleware.onError({
                                        fetch: this.fetchApi,
                                        url: fetchParams.url,
                                        init: fetchParams.init,
                                        error: e,
                                        response: response ? response.clone() : undefined,
                                    }) || response;
                                }
                            }
                            if (response === undefined) {
                              if (e instanceof Error) {
                                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
                              } else {
                                throw e;
                              }
                            }
                        }
                        for (const middleware of this.middleware) {
                            if (middleware.post) {
                                response = await middleware.post({
                                    fetch: this.fetchApi,
                                    url: fetchParams.url,
                                    init: fetchParams.init,
                                    response: response.clone(),
                                }) || response;
                            }
                        }
                        return response;
                    }

                    /**
                     * Create a shallow clone of `this` by constructing a new instance
                     * and then shallow cloning data members.
                     */
                    private clone<T extends BaseAPI>(this: T): T {
                        const constructor = this.constructor as any;
                        const next = new constructor(this.configuration);
                        next.middleware = this.middleware.slice();
                        return next;
                    }
                };


                function
                isBlob(value:
                any):
                value
                is
                Blob
                {
                    return typeof Blob !== 'undefined' && value instanceof Blob;
                }


                function
                isFormData(value:
                any):
                value
                is
                FormData
                {
                    return typeof FormData !== "undefined" && value instanceof FormData;
                }


                export
                class
                ResponseError
                extends
                Error
                {
                    override name: "ResponseError" = "ResponseError";
                    constructor(public response: Response, msg?: string) {
                        super(msg);
                    }
                }


                export
                class
                FetchError
                extends
                Error
                {
                    override name: "FetchError" = "FetchError";
                    constructor(public cause: Error, msg?: string) {
                        super(msg);
                    }
                }


                export
                class
                RequiredError
                extends
                Error
                {
                    override name: "RequiredError" = "RequiredError";
                    constructor(public field: string, msg?: string) {
                        super(msg);
                    }
                }


                export
                const
                COLLECTION_FORMATS
                =
                {
                    csv: ",",
                    ssv: " ",
                    tsv: "\t",
                    pipes: "|",
                };


                export
                type
                FetchAPI
                =
                WindowOrWorkerGlobalScope['fetch'];


                export
                type
                Json
                =
                any;

                export
                type
                HTTPMethod
                =
                'GET'
                |
                'POST'
                |
                'PUT'
                |
                'PATCH'
                |
                'DELETE'
                |
                'OPTIONS'
                |
                'HEAD';

                export
                type
                HTTPHeaders
                =
                {
                [key:
                string]:
                string
                };

                export
                type
                HTTPQuery
                =
                {
                [key:
                string]:
                string
                |
                number
                |
                null
                |
                boolean
                |
                Array<string
                |
                number
                |
                null
                |
                boolean>
                |
                Set<string
                |
                number
                |
                null
                |
                boolean>
                |
                HTTPQuery
                };

                export
                type
                HTTPBody
                =
                Json
                |
                FormData
                |
                URLSearchParams;

                export
                type
                HTTPRequestInit
                =
                {
                headers?:
                HTTPHeaders;
                method:
                HTTPMethod;
                credentials?:
                RequestCredentials;
                body?:
                HTTPBody
                };

                export
                type
                ModelPropertyNaming
                =
                'camelCase'
                |
                'snake_case'
                |
                'PascalCase'
                |
                'original';


                export
                type
                InitOverrideFunction
                =
                (requestContext:
                {
                init:
                HTTPRequestInit,
                context:
                RequestOpts
                })
                =>
                Promise<RequestInit>


                export
                interface
                FetchParams
                {
                    url: string;
                    init: RequestInit;
                }


                export
                interface
                RequestOpts
                {
                    path: string;
                    method: HTTPMethod;
                    headers: HTTPHeaders;
                    query?: HTTPQuery;
                    body?: HTTPBody;
                }


                export
                function
                querystring(params:
                HTTPQuery,
                prefix:
                string
                =
                ''):
                string
                {
                    return Object.keys(params)
                        .map(key => querystringSingleKey(key, params[key], prefix))
                        .filter(part => part.length > 0)
                        .join('&');
                }


                function
                querystringSingleKey(key:
                string,
                value:
                string
                |
                number
                |
                null
                |
                undefined
                |
                boolean
                |
                Array<string
                |
                number
                |
                null
                |
                boolean>
                |
                Set<string
                |
                number
                |
                null
                |
                boolean>
                |
                HTTPQuery,
                keyPrefix:
                string
                =
                ''):
                string
                {
                    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
                    if (value instanceof Array) {
                        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
                            .join(`&${encodeURIComponent(fullKey)}=`);
                        return `${encodeURIComponent(fullKey)}=${multiValue}`;
                    }
                    if (value instanceof Set) {
                        const valueAsArray = Array.from(value);
                        return querystringSingleKey(key, valueAsArray, keyPrefix);
                    }
                    if (value instanceof Date) {
                        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
                    }
                    if (value instanceof Object) {
                        return querystring(value as HTTPQuery, fullKey);
                    }
                    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
                }


                export
                function
                exists(json:
                any,
                key:
                string)
                {
                    const value = json[key];
                    return value !== null && value !== undefined;
                }


                export
                function
                mapValues(data:
                any,
                fn:
                (item:
                any)
                =>
                any)
                {
                  return Object.keys(data).reduce(
                    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
                    {}
                  );
                }


                export
                function
                canConsumeForm(consumes:
                Consume[]):
                boolean
                {
                    for (const consume of consumes) {
                        if ('multipart/form-data' === consume.contentType) {
                            return true;
                        }
                    }
                    return false;
                }


                export
                interface
                Consume
                {
                    contentType: string;
                }


                export
                interface
                RequestContext
                {
                    fetch: FetchAPI;
                    url: string;
                    init: RequestInit;
                }


                export
                interface
                ResponseContext
                {
                    fetch: FetchAPI;
                    url: string;
                    init: RequestInit;
                    response: Response;
                }


                export
                interface
                ErrorContext
                {
                    fetch: FetchAPI;
                    url: string;
                    init: RequestInit;
                    error: unknown;
                    response?: Response;
                }


                export
                interface
                Middleware
                {
                    pre?(context: RequestContext): Promise<FetchParams | void>;
                    post?(context: ResponseContext): Promise<Response | void>;
                    onError?(context: ErrorContext): Promise<Response | void>;
                }


                export
                interface
                ApiResponse<T>
                {
                    raw: Response;
                    value(): Promise<T>;
                }


                export
                interface
                ResponseTransformer<T>
                {
                    (json: any): T;
                }


                export
                class
                JSONApiResponse<T>
                {
                    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

                    async value(): Promise<T> {
                        return this.transformer(await this.raw.json());
                    }
                }


                export
                class
                VoidApiResponse
                {
                    constructor(public raw: Response) {}

                    async value(): Promise<void> {
                        return undefined;
                    }
                }


                export
                class
                BlobApiResponse
                {
                    constructor(public raw: Response) {}

                    async value(): Promise<Blob> {
                        return await this.raw.blob();
                    };
                }


                export
                class
                TextApiResponse
                {
                    constructor(public raw: Response) {}

                    async value(): Promise<string> {
                        return await this.raw.text();
                    };
                }
        - name: >-
            generated-unified
          type: >-
            directory
          children:
            - name: >-
                QuickbaseClient.ts
              type: >-
                file
            - name: >-
                missing-types-report.json
              type: >-
                file
        - name: >-
            index.ts
          type: >-
            file
        - name: >-
            invokeMethod.ts
          type: >-
            file
          contents: >
            //
            src/invokeMethod.ts

            import
            {
            QuickbaseClient
            }
            from
            "./quickbaseClient";

            import
            {
            ResponseError
            }
            from
            "./generated/runtime";

            import
            {
            ThrottleBucket
            }
            from
            "./ThrottleBucket";

            import
            {
            RateLimitError
            }
            from
            "./RateLimitError";

            import
            {
            GetTempTokenDBID200Response
            }
            from
            "./generated/models";


            export
            type
            ApiMethod<K
            extends
            keyof
            QuickbaseClient>
            =
            (
              requestParameters: Parameters<QuickbaseClient[K]>[0],
              initOverrides?: RequestInit
            )
            =>
            Promise<ReturnType<QuickbaseClient[K]>>;


            export
            interface
            MethodInfo<K
            extends
            keyof
            QuickbaseClient>
            {
              api: any;
              method: ApiMethod<K>;
              paramMap: string[];
              httpMethod: string;
            }


            export
            interface
            TempTokenParams
            {
              appId?: string;
              tableId?: string;
              dbid?: string;
            }


            export
            interface
            TokenCache
            {
              get: (dbid: string) => string | undefined;
              set: (dbid: string, token: string) => void;
            }


            export
            async
            function
            invokeMethod<K
            extends
            keyof
            QuickbaseClient>(
              methodName: K,
              params: Parameters<QuickbaseClient[K]>[0] & Partial<TempTokenParams>,
              methodMap: { [P in keyof QuickbaseClient]: MethodInfo<P> },
              baseHeaders: Record<string, string>,
              tokenCache: TokenCache,
              fetchTempToken: (dbid: string) => Promise<string>,
              transformDates: (obj: any, convertStringsToDates: boolean) => any,
              initialTempToken: string | undefined,
              userToken: string | undefined,
              useTempTokens: boolean | undefined,
              debug: boolean | undefined,
              convertDates: boolean,
              retryCount: number = 0,
              throttleBucket: ThrottleBucket | null = null,
              maxRetries: number = 3,
              retryDelay: number = 1000
            ):
            Promise<ReturnType<QuickbaseClient[K]>>
            {
              const methodInfo = methodMap[methodName];
              if (!methodInfo) throw new Error(`Method ${methodName} not found`);

              const hasBody = "body" in params && params.body !== undefined;
              const body = hasBody ? (params as any).body : undefined;
              const restParams: any = hasBody
                ? Object.fromEntries(
                    Object.entries(params).filter(([key]) => key !== "body")
                  )
                : { ...params };

              const requestParameters: any = {
                ...restParams,
                ...(hasBody ? { generated: body } : {}),
              };

              let requestOptions: RequestInit = {
                credentials: "omit",
                method: methodInfo.httpMethod,
                ...(hasBody ? { body } : {}),
              };

              const selectedToken =
                initialTempToken || (userToken && !useTempTokens ? userToken : undefined);
              let authorizationToken = selectedToken;

              if (methodName === "getTempTokenDBID" && useTempTokens) {
                const dbid = extractDbid(params, "No dbid provided for getTempTokenDBID");
                const cachedToken = tokenCache.get(dbid);
                if (cachedToken) {
                  return Promise.resolve({
                    temporaryAuthorization: cachedToken,
                  } as GetTempTokenDBID200Response as ReturnType<QuickbaseClient[K]>);
                }
              }

              if (useTempTokens && !authorizationToken) {
                const dbid = extractDbid(
                  params,
                  `No dbid found in params for ${methodName} to fetch temp token`
                );
                const cachedToken = tokenCache.get(dbid);
                authorizationToken = cachedToken || (await fetchTempToken(dbid));
                if (methodName === "getTempTokenDBID") {
                  return Promise.resolve({
                    temporaryAuthorization: authorizationToken,
                  } as GetTempTokenDBID200Response as ReturnType<QuickbaseClient[K]>);
                }
              }
              requestOptions.headers = authorizationToken
                ? {
                    ...baseHeaders,
                    Authorization: useTempTokens
                      ? `QB-TEMP-TOKEN ${authorizationToken}`
                      : `QB-USER-TOKEN ${authorizationToken}`,
                  }
                : baseHeaders;

              if (debug) {
                console.log(`[${methodName}] requestParameters:`, requestParameters);
                console.log(`[${methodName}] requestOptions:`, requestOptions);
              }

              async function processResponse(
                rawResponse: any
              ): Promise<ReturnType<QuickbaseClient[K]>> {
                if (debug) console.log(`[${methodName}] rawResponse:`, rawResponse);

                if (rawResponse instanceof Response) {
                  const contentType = rawResponse.headers
                    .get("Content-Type")
                    ?.toLowerCase();
                  if (debug) console.log(`[${methodName}] contentType:`, contentType);

                  if (contentType?.includes("application/octet-stream")) {
                    return (await rawResponse.arrayBuffer()) as ReturnType<
                      QuickbaseClient[K]
                    >;
                  }
                  if (
                    contentType?.includes("application/x-yaml") ||
                    contentType?.includes("text/yaml")
                  ) {
                    return (await rawResponse.text()) as ReturnType<QuickbaseClient[K]>;
                  }
                  if (contentType?.includes("application/json")) {
                    const jsonResponse = await rawResponse.json();
                    return transformDates(jsonResponse, convertDates) as ReturnType<
                      QuickbaseClient[K]
                    >;
                  }
                  return rawResponse as ReturnType<QuickbaseClient[K]>;
                }

                if (rawResponse && typeof rawResponse.value === "function") {
                  const response = await rawResponse.value();
                  if (debug)
                    console.log(`[${methodName}] Resolved JSONApiResponse:`, response);
                  return transformDates(response, convertDates) as ReturnType<
                    QuickbaseClient[K]
                  >;
                }

                const transformed = transformDates(rawResponse, convertDates);
                if (debug)
                  console.log(`[${methodName}] Transformed non-Response:`, transformed);
                return transformed as ReturnType<QuickbaseClient[K]>;
              }

              async function withRetries(
                fn: () => Promise<ReturnType<QuickbaseClient[K]>>,
                options: {
                  maxAttempts: number;
                  shouldRetry: (error: any) => boolean;
                  onRetry?: (error: any, attempt: number) => Promise<void>;
                  delay?: (attempt: number, error: any) => number;
                }
              ): Promise<ReturnType<QuickbaseClient[K]>> {
                let attempt = 0;
                while (true) {
                  try {
                    if (throttleBucket) {
                      if (debug) console.log(`[${methodName}] Awaiting throttle bucket`);
                      await throttleBucket.acquire();
                      if (debug) console.log(`[${methodName}] Throttle bucket acquired`);
                    }
                    return await fn();
                  } catch (error) {
                    console.log(`[${methodName}] Caught error:`, error);
                    console.log(
                      `[${methodName}] instanceof ResponseError:`,
                      error instanceof ResponseError
                    );
                    console.log(
                      `[${methodName}] Response status:`,
                      (error as any).response?.status
                    );
                    const effectiveError =
                      error instanceof Object &&
                      "cause" in error &&
                      error.cause instanceof ResponseError
                        ? error.cause
                        : error instanceof ResponseError
                        ? error
                        : error;
                    console.log(`[${methodName}] Effective error:`, effectiveError);
                    console.log(
                      `[${methodName}] Effective instanceof ResponseError:`,
                      effectiveError instanceof ResponseError
                    );
                    console.log(
                      `[${methodName}] Effective response status:`,
                      (effectiveError as any).response?.status
                    );

                    attempt++;
                    if (
                      !options.shouldRetry(effectiveError) ||
                      attempt >= options.maxAttempts
                    ) {
                      let errorMessage =
                        effectiveError instanceof ResponseError
                          ? effectiveError.message
                          : String(error);
                      console.log(`[${methodName}] No retry, throwing:`, errorMessage);
                      if (
                        effectiveError instanceof ResponseError &&
                        effectiveError.response
                      ) {
                        try {
                          const errorBody = await effectiveError.response.json();
                          if (debug)
                            console.log(`[${methodName}] Error response body:`, errorBody);
                          errorMessage = errorBody?.message || errorMessage;
                        } catch (e) {
                          if (debug)
                            console.log(`[${methodName}] Failed to parse error body:`, e);
                        }
                        throw new Error(
                          `API Error: ${errorMessage} (Status: ${effectiveError.response.status})`
                        );
                      }
                      throw new Error(`API Error: ${errorMessage} (Status: unknown)`);
                    }
                    if (options.onRetry) {
                      console.log(`[${methodName}] Retrying, attempt:`, attempt);
                      await options.onRetry(effectiveError, attempt);
                    }
                    const delayMs = options.delay
                      ? options.delay(attempt, effectiveError)
                      : retryDelay * Math.pow(2, attempt - 1);
                    if (debug)
                      console.log(
                        `[${methodName}] Retrying after ${delayMs}ms (attempt ${attempt}/${
                          options.maxAttempts - 1
                        })`
                      );
                    await new Promise((resolve) => setTimeout(resolve, delayMs));
                  }
                }
              }

              const mainPromise = withRetries(
                () =>
                  methodInfo
                    .method(requestParameters, requestOptions)
                    .then(processResponse),
                {
                  maxAttempts: (useTempTokens ?? false) || userToken ? 2 : 1,
                  shouldRetry: (error) =>
                    error instanceof ResponseError &&
                    error.response?.status === 401 &&
                    ((useTempTokens ?? false) ||
                      (!!userToken && !(useTempTokens ?? false))),
                  onRetry: async (error) => {
                    if (error instanceof ResponseError && error.response?.status === 401) {
                      if (useTempTokens ?? false) {
                        if (debug)
                          console.log(
                            `Authorization error for ${methodName} (temp token), refreshing token:`,
                            error.message
                          );
                        const dbid = extractDbid(
                          params,
                          `No dbid to refresh token after authorization error`
                        );
                        try {
                          authorizationToken = await fetchTempToken(dbid);
                        } catch (fetchError) {
                          const fetchErrorMessage =
                            fetchError instanceof ResponseError && fetchError.response
                              ? (await fetchError.response.json())?.message ||
                                "Unauthorized"
                              : String(fetchError);
                          throw new Error(
                            `API Error: ${fetchErrorMessage} (Status: ${
                              fetchError instanceof ResponseError &&
                              fetchError.response?.status
                                ? fetchError.response.status
                                : "unknown"
                            })`
                          );
                        }
                        requestOptions.headers = {
                          ...baseHeaders,
                          Authorization: `QB-TEMP-TOKEN ${authorizationToken}`,
                        };
                      } else if (userToken) {
                        if (debug)
                          console.log(
                            `Authorization error for ${methodName} (user token), retrying with same token:`,
                            error.message
                          );
                      }
                      if (debug)
                        console.log(
                          `Retrying ${methodName} with ${
                            useTempTokens ? "temp" : "user"
                          } token`
                        );
                    }
                  },
                }
              );

              return mainPromise.catch((error: unknown) => {
                let effectiveError: unknown = error;
                if (
                  error instanceof Object &&
                  "cause" in error &&
                  error.cause instanceof ResponseError
                ) {
                  effectiveError = error.cause;
                } else if (error instanceof ResponseError) {
                  effectiveError = error;
                }

                if (
                  effectiveError instanceof ResponseError &&
                  effectiveError.response?.status === 429
                ) {
                  return withRetries(() => Promise.reject(error), {
                    maxAttempts: maxRetries + 1,
                    shouldRetry: (err) =>
                      err instanceof ResponseError && err.response?.status === 429,
                    delay: (attempt, err) => {
                      const headers =
                        err instanceof ResponseError && err.response
                          ? err.response.headers
                          : new Headers();
                      const retryAfter = headers.get("Retry-After");
                      return retryAfter
                        ? parseInt(retryAfter, 10) * 1000
                        : retryDelay * Math.pow(2, attempt - 1);
                    },
                  });
                }
                throw effectiveError;
              });
            }


            function
            extractDbid(
              params: Partial<TempTokenParams>,
              errorMessage: string
            ):
            string
            {
              const dbid = params.dbid || params.tableId || params.appId;
              if (!dbid) throw new Error(errorMessage);
              return dbid;
            }
        - name: >-
            quickbaseClient.ts
          type: >-
            file
        - name: >-
            tokenCache.ts
          type: >-
            file
        - name: >-
            utils.ts
          type: >-
            file
    - name: >-
        test-artifacts
      type: >-
        directory
      children:
        - name: >-
            .last-run.json
          type: >-
            file
        - name: >-
            test-results.json
          type: >-
            file
    - name: >-
        test-esm.js
      type: >-
        file
    - name: >-
        test-results.json
      type: >-
        file
    - name: >-
        test-umd.js
      type: >-
        file
    - name: >-
        test.ts
      type: >-
        file
    - name: >-
        tests
      type: >-
        directory
      children:
        - name: >-
            playwright
          type: >-
            directory
          children:
            - name: >-
                qb
              type: >-
                directory
              children:
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        cacheSwitching.test.ts
                      type: >-
                        file
                    - name: >-
                        fetchTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithUserToken.test.ts
                      type: >-
                        file
                    - name: >-
                        getTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        tempTokenPrefetch.test.ts
                      type: >-
                        file
                    - name: >-
                        tempTokenRenewal.test.ts
                      type: >-
                        file
        - name: >-
            setup.ts
          type: >-
            file
          contents: >
            //
            @tests/setup.ts

            import
            {
            vi
            }
            from
            "vitest";

            import
            {
            quickbase
            }
            from
            "../src/quickbaseClient.ts";

            import
            type
            {
            QuickbaseConfig
            }
            from
            "../src/quickbaseClient.ts";

            import
            dotenv
            from
            "dotenv";


            //
            Load
            environment
            variables
            from
            .env
            file

            dotenv.config({
            path:
            "./.env"
            });
            //
            Assumes
            .env
            is
            at
            project
            root


            export
            const
            mockFetch
            =
            vi.fn();


            export
            const
            QB_REALM
            =
            process.env.QB_REALM
            ||
            "test-realm";

            export
            const
            QB_USER_TOKEN
            =
              process.env.QB_USER_TOKEN || "user-token-1234567890";
            export
            const
            QB_APP_ID
            =
            process.env.QB_APP_ID
            ||
            "app-id-1234567890";

            export
            const
            QB_TABLE_ID_1
            =
              process.env.QB_TABLE_ID_1 || "table-id-1-1234567890";
            export
            const
            QB_TABLE_ID_2
            =
              process.env.QB_TABLE_ID_2 || "table-id-2-1234567890";

            //
            Mock
            env
            variables
            for
            consistency,
            using
            .env
            values
            if
            available

            vi.stubEnv("QB_REALM",
            QB_REALM);

            vi.stubEnv("QB_USER_TOKEN",
            QB_USER_TOKEN);

            vi.stubEnv("QB_APP_ID",
            QB_APP_ID);

            vi.stubEnv("QB_TABLE_ID_1",
            QB_TABLE_ID_1);

            vi.stubEnv("QB_TABLE_ID_2",
            QB_TABLE_ID_2);


            export
            const
            createClient
            =
            (
              fetchApi?: any,
              config: Partial<QuickbaseConfig> = {}
            )
            =>
            {
              // Use loaded env vars with fallbacks for safety
              const realm = QB_REALM;
              const userToken = QB_USER_TOKEN;

              const client = quickbase({
                realm,
                userToken,
                debug: true,
                fetchApi,
                throttle: { rate: 10, burst: 10 }, // Throttle at 10 req/s with 10 burst capacity
                ...config, // Allow overrides if provided
              });
              console.log("[createClient] Config:", {
                realm,
                userToken,
                debug: true,
                throttle: { rate: 10, burst: 10 },
                ...config,
              });
              console.log("[createClient] Returning:", client);
              return client;
            };
        - name: >-
            vitest
          type: >-
            directory
          children:
            - name: >-
                qb
              type: >-
                directory
              children:
                - name: >-
                    apps
                  type: >-
                    directory
                  children:
                    - name: >-
                        copyApp.test.ts
                      type: >-
                        file
                    - name: >-
                        createApp.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppEvents.test.ts
                      type: >-
                        file
                    - name: >-
                        updateApp.test.ts
                      type: >-
                        file
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        retryUserToken401.test.ts
                      type: >-
                        file
                - name: >-
                    fields
                  type: >-
                    directory
                  children:
                    - name: >-
                        createField.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getField.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        getFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldsUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        updateField.test.ts
                      type: >-
                        file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    records
                  type: >-
                    directory
                  children:
                    - name: >-
                        deleteRecords.test.ts
                      type: >-
                        file
                    - name: >-
                        runQuery.test.ts
                      type: >-
                        file
                    - name: >-
                        upsert.test.ts
                      type: >-
                        file
                - name: >-
                    tables
                  type: >-
                    directory
                  children:
                    - name: >-
                        createRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        createTable.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteTable.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppTables.test.ts
                      type: >-
                        file
                    - name: >-
                        getRelationships.test.ts
                      type: >-
                        file
                    - name: >-
                        getTable.test.ts
                      type: >-
                        file
                    - name: >-
                        updateRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        updateTable.test.ts
                      type: >-
                        file
            - name: >-
                unit
              type: >-
                directory
              children:
                - name: >-
                    apps
                  type: >-
                    directory
                  children:
                    - name: >-
                        copyApp.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/apps/copyApp.test.ts


                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_APP_ID,
                          QB_REALM,
                          QB_USER_TOKEN,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                        CopyAppRequest,
                        CopyApp200Response
                        }
                        from
                        "@/generated/models";


                        describe("QuickbaseClient
                        Unit
                        -
                        copyApp",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                          });

                          it("initializes without errors", () => {
                            client = createClient(mockFetch, { debug: true });
                            expect(client).toBeDefined();
                          });

                          it("has copyApp method", () => {
                            client = createClient(mockFetch, { debug: true });
                            expect(typeof client.copyApp).toBe("function");
                          });

                          it("calls copyApp successfully with user token and dates as Date objects", async () => {
                            client = createClient(mockFetch, { debug: true }); // convertDates defaults to true

                            const request: CopyAppRequest = {
                              name: "Copied App",
                              description: "A copy of the original app",
                              properties: {
                                keepData: false,
                                excludeFiles: true,
                                usersAndRoles: false,
                                assignUserToken: true,
                              },
                            };

                            const mockResponse: CopyApp200Response = {
                              id: "bpqe82s1",
                              name: "Copied App",
                              description: "A copy of the original app",
                              created: new Date("2025-03-11T10:00:00Z"), // Expect Date object
                              updated: new Date("2025-03-11T10:00:00Z"), // Expect Date object
                              dateFormat: "MM-DD-YYYY",
                              timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                              hasEveryoneOnTheInternet: false,
                              ancestorId: "buwai2zpe",
                              dataClassification: "None",
                              variables: [],
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.copyApp({ appId: QB_APP_ID, body: request });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}/copy`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "omit",
                                body: JSON.stringify(request),
                              })
                            );
                          });

                          it("calls copyApp successfully with user token and dates as strings", async () => {
                            client = createClient(mockFetch, { debug: true, convertDates: false });

                            const request: CopyAppRequest = {
                              name: "Copied App",
                              description: "A copy of the original app",
                              properties: {
                                keepData: false,
                                excludeFiles: true,
                                usersAndRoles: false,
                                assignUserToken: true,
                              },
                            };

                            const mockResponse = {
                              id: "bpqe82s1",
                              name: "Copied App",
                              description: "A copy of the original app",
                              created: "2025-03-11T10:00:00Z", // Expect string
                              updated: "2025-03-11T10:00:00Z", // Expect string
                              dateFormat: "MM-DD-YYYY",
                              timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                              hasEveryoneOnTheInternet: false,
                              ancestorId: "buwai2zpe",
                              dataClassification: "None",
                              variables: [],
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.copyApp({ appId: QB_APP_ID, body: request });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}/copy`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "omit",
                                body: JSON.stringify(request),
                              })
                            );
                          });

                          it("calls copyApp successfully with temp token and dates as Date objects", async () => {
                            client = createClient(mockFetch, { useTempTokens: true, debug: true });

                            const request: CopyAppRequest = {
                              name: "Copied App with Temp Token",
                              description: "A copy using temp token",
                              properties: {
                                keepData: true,
                                excludeFiles: false,
                                usersAndRoles: true,
                                assignUserToken: false,
                              },
                            };

                            const mockResponse: CopyApp200Response = {
                              id: "bpqe82s2",
                              name: "Copied App with Temp Token",
                              description: "A copy using temp token",
                              created: new Date("2025-03-11T11:00:00Z"), // Expect Date object
                              updated: new Date("2025-03-11T11:00:00Z"), // Expect Date object
                              dateFormat: "MM-DD-YYYY",
                              timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                              hasEveryoneOnTheInternet: true,
                              ancestorId: QB_APP_ID,
                              dataClassification: "None",
                              variables: [],
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "temp_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const result = await client.copyApp({ appId: QB_APP_ID, body: request });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(2);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "include",
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}/copy`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: "QB-TEMP-TOKEN temp_token",
                                  "Content-Type": "application/json",
                                }),
                                credentials: "omit",
                                body: JSON.stringify(request),
                              })
                            );
                          });

                          it("calls copyApp successfully with temp token and dates as strings", async () => {
                            client = createClient(mockFetch, {
                              useTempTokens: true,
                              debug: true,
                              convertDates: false,
                            });

                            const request: CopyAppRequest = {
                              name: "Copied App with Temp Token",
                              description: "A copy using temp token",
                              properties: {
                                keepData: true,
                                excludeFiles: false,
                                usersAndRoles: true,
                                assignUserToken: false,
                              },
                            };

                            const mockResponse = {
                              id: "bpqe82s2",
                              name: "Copied App with Temp Token",
                              description: "A copy using temp token",
                              created: "2025-03-11T11:00:00Z", // Expect string
                              updated: "2025-03-11T11:00:00Z", // Expect string
                              dateFormat: "MM-DD-YYYY",
                              timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                              hasEveryoneOnTheInternet: true,
                              ancestorId: QB_APP_ID,
                              dataClassification: "None",
                              variables: [],
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "temp_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const result = await client.copyApp({ appId: QB_APP_ID, body: request });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(2);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "include",
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}/copy`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: "QB-TEMP-TOKEN temp_token",
                                  "Content-Type": "application/json",
                                }),
                                credentials: "omit",
                                body: JSON.stringify(request),
                              })
                            );
                          });

                          it("retries successfully after 401 with temp token and dates as Date objects", async () => {
                            client = createClient(mockFetch, { useTempTokens: true, debug: true });

                            const request: CopyAppRequest = {
                              name: "Retry Copied App",
                              description: "Retry after 401",
                              properties: {
                                keepData: false,
                                excludeFiles: true,
                                usersAndRoles: false,
                                assignUserToken: true,
                              },
                            };

                            const mockResponse: CopyApp200Response = {
                              id: "bpqe82s3",
                              name: "Retry Copied App",
                              description: "Retry after 401",
                              created: new Date("2025-03-11T12:00:00Z"), // Expect Date object
                              updated: new Date("2025-03-11T12:00:00Z"), // Expect Date object
                              dateFormat: "MM-DD-YYYY",
                              timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                              hasEveryoneOnTheInternet: false,
                              ancestorId: QB_APP_ID,
                              dataClassification: "None",
                              variables: [],
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve({ temporaryAuthorization: "initial_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: false,
                                status: 401,
                                json: () => Promise.resolve({ message: "Unauthorized" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "new_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const result = await client.copyApp({ appId: QB_APP_ID, body: request });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(4);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_APP_ID}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}/copy`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN initial_token",
                                }),
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              3,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_APP_ID}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              4,
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}/copy`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN new_token",
                                }),
                              })
                            );
                          });

                          it("retries successfully after 401 with temp token and dates as strings", async () => {
                            client = createClient(mockFetch, {
                              useTempTokens: true,
                              debug: true,
                              convertDates: false,
                            });

                            const request: CopyAppRequest = {
                              name: "Retry Copied App",
                              description: "Retry after 401",
                              properties: {
                                keepData: false,
                                excludeFiles: true,
                                usersAndRoles: false,
                                assignUserToken: true,
                              },
                            };

                            const mockResponse = {
                              id: "bpqe82s3",
                              name: "Retry Copied App",
                              description: "Retry after 401",
                              created: "2025-03-11T12:00:00Z", // Expect string
                              updated: "2025-03-11T12:00:00Z", // Expect string
                              dateFormat: "MM-DD-YYYY",
                              timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                              hasEveryoneOnTheInternet: false,
                              ancestorId: QB_APP_ID,
                              dataClassification: "None",
                              variables: [],
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve({ temporaryAuthorization: "initial_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: false,
                                status: 401,
                                json: () => Promise.resolve({ message: "Unauthorized" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "new_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const result = await client.copyApp({ appId: QB_APP_ID, body: request });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(4);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_APP_ID}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}/copy`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN initial_token",
                                }),
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              3,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_APP_ID}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              4,
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}/copy`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN new_token",
                                }),
                              })
                            );
                          });

                          it("handles 400 error for invalid request", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const request: CopyAppRequest = {
                              name: "",
                              description: "Invalid request",
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 400,
                              json: () => Promise.resolve({ message: "Name is required" }),
                            });

                            await expect(
                              client.copyApp({ appId: QB_APP_ID, body: request })
                            ).rejects.toThrow("API Error: Name is required (Status: 400)");

                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}/copy`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "omit",
                                body: JSON.stringify(request),
                              })
                            );
                          });
                        });
                    - name: >-
                        createApp.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/apps/createApp.test.ts


                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_REALM,
                          QB_USER_TOKEN,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                        CreateAppRequest,
                        CreateApp200Response
                        }
                        from
                        "@/generated/models";


                        describe("QuickbaseClient
                        Unit
                        -
                        createApp",
                        ()
                        =>
                        {
                          console.log(
                            "Running updated createApp.test.ts - Version with full request expectation"
                          );

                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                          });

                          it("initializes without errors", () => {
                            client = createClient(mockFetch, { debug: true });
                            expect(client).toBeDefined();
                          });

                          it("has createApp method", () => {
                            client = createClient(mockFetch, { debug: true });
                            expect(typeof client.createApp).toBe("function");
                          });

                          it("calls createApp successfully with user token and dates as Date objects", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const request: CreateAppRequest = {
                              name: "New App",
                              description: "A new app for testing",
                              assignToken: true,
                            };

                            const mockResponse: CreateApp200Response = {
                              id: "new-app-id",
                              name: "New App",
                              description: "A new app for testing",
                              created: new Date("2025-03-11T10:00:00Z"),
                              updated: new Date("2025-03-11T10:00:00Z"),
                              dateFormat: "MM-DD-YYYY",
                              timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                              hasEveryoneOnTheInternet: false,
                              variables: [],
                              dataClassification: "None",
                              memoryInfo: { estMemory: 0, estMemoryInclDependentApps: 0 },
                              securityProperties: {
                                allowClone: false,
                                allowExport: true,
                                enableAppTokens: true,
                                hideFromPublic: false,
                                mustBeRealmApproved: false,
                                useIPFilter: false,
                              },
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.createApp({ body: request });

                            expect(result).toEqual(mockResponse);
                            const callArgs = mockFetch.mock.calls[0];
                            const body = JSON.parse(callArgs[1].body as string);
                            console.log("Date objects test - Expected request:", request);
                            console.log("Date objects test - Actual body:", body);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: expect.any(String), // Ensure it’s a string, we’ll check content below
                                credentials: "omit",
                              })
                            );
                            expect(body).toEqual(request); // Moved outside toHaveBeenCalledWith
                          });

                          it("calls createApp successfully with user token and dates as strings", async () => {
                            client = createClient(mockFetch, { debug: true, convertDates: false });

                            const request: CreateAppRequest = {
                              name: "New App",
                              description: "A new app for testing",
                              assignToken: true,
                            };

                            const mockResponse = {
                              id: "new-app-id",
                              name: "New App",
                              description: "A new app for testing",
                              created: "2025-03-11T10:00:00Z",
                              updated: "2025-03-11T10:00:00Z",
                              dateFormat: "MM-DD-YYYY",
                              timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                              hasEveryoneOnTheInternet: false,
                              variables: [],
                              dataClassification: "None",
                              memoryInfo: { estMemory: 0, estMemoryInclDependentApps: 0 },
                              securityProperties: {
                                allowClone: false,
                                allowExport: true,
                                enableAppTokens: true,
                                hideFromPublic: false,
                                mustBeRealmApproved: false,
                                useIPFilter: false,
                              },
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.createApp({ body: request });

                            expect(result).toEqual(mockResponse);
                            const callArgs = mockFetch.mock.calls[0];
                            const body = JSON.parse(callArgs[1].body as string);
                            console.log("Strings test - Expected request:", request);
                            console.log("Strings test - Actual body:", body);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: expect.any(String), // Ensure it’s a string, we’ll check content below
                                credentials: "omit",
                              })
                            );
                            expect(body).toEqual(request); // Moved outside toHaveBeenCalledWith
                          });

                          it("handles 400 error for invalid request", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const request: CreateAppRequest = {
                              name: "",
                            };

                            mockFetch.mockImplementationOnce(() =>
                              Promise.resolve({
                                ok: false,
                                status: 400,
                                json: () => Promise.resolve({ message: "Name is required" }),
                              })
                            );

                            await expect(client.createApp({ body: request })).rejects.toThrow(
                              "API Error: Name is required (Status: 400)"
                            );

                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                                credentials: "omit",
                              })
                            );
                          });
                        });
                    - name: >-
                        deleteApp.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/apps/deleteApp.test.ts


                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_APP_ID,
                          QB_REALM,
                          QB_USER_TOKEN,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                        DeleteAppRequest,
                        DeleteApp200Response
                        }
                        from
                        "@/generated/models";


                        describe("QuickbaseClient
                        Unit
                        -
                        deleteApp",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                          });

                          it("initializes without errors", () => {
                            client = createClient(mockFetch, { debug: true });
                            expect(client).toBeDefined();
                          });

                          it("has deleteApp method", () => {
                            client = createClient(mockFetch, { debug: true });
                            expect(typeof client.deleteApp).toBe("function");
                          });

                          it("calls deleteApp successfully with user token", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const request: DeleteAppRequest = {
                              name: "App to Delete",
                            };

                            const mockResponse: DeleteApp200Response = {
                              deletedAppId: QB_APP_ID,
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.deleteApp({ appId: QB_APP_ID, body: request });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "DELETE",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                              })
                            );
                          });

                          it("calls deleteApp successfully with temp token", async () => {
                            client = createClient(mockFetch, { useTempTokens: true, debug: true });

                            const request: DeleteAppRequest = {
                              name: "App to Delete with Temp Token",
                            };

                            const mockResponse: DeleteApp200Response = {
                              deletedAppId: QB_APP_ID,
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "temp_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const result = await client.deleteApp({ appId: QB_APP_ID, body: request });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(2);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "include",
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "DELETE",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: "QB-TEMP-TOKEN temp_token",
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                              })
                            );
                          });

                          it("retries successfully after 401 with temp token", async () => {
                            client = createClient(mockFetch, { useTempTokens: true, debug: true });

                            const request: DeleteAppRequest = {
                              name: "Retry Delete App",
                            };

                            const mockResponse: DeleteApp200Response = {
                              deletedAppId: QB_APP_ID,
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve({ temporaryAuthorization: "initial_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: false,
                                status: 401,
                                json: () => Promise.resolve({ message: "Unauthorized" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "new_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const result = await client.deleteApp({ appId: QB_APP_ID, body: request });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(4);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_APP_ID}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN initial_token",
                                }),
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              3,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_APP_ID}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              4,
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN new_token",
                                }),
                              })
                            );
                          });

                          it("handles 400 error for invalid request", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const request: DeleteAppRequest = {
                              name: "Wrong Name",
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 400,
                              json: () => Promise.resolve({ message: "Invalid application name" }),
                            });

                            await expect(
                              client.deleteApp({ appId: QB_APP_ID, body: request })
                            ).rejects.toThrow("API Error: Invalid application name (Status: 400)");

                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "DELETE",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                              })
                            );
                          });
                        });
                    - name: >-
                        getApp.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/apps/getApp.test.ts


                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_APP_ID,
                          QB_REALM,
                          QB_USER_TOKEN,
                        }
                        from
                        "@tests/setup.ts";


                        describe("QuickbaseClient
                        Unit
                        -
                        getApp",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                          });

                          it("initializes without errors", () => {
                            client = createClient(mockFetch, { debug: true });
                            expect(client).toBeDefined();
                          });

                          it("has getApp method", () => {
                            client = createClient(mockFetch, { debug: true });
                            expect(typeof client.getApp).toBe("function");
                          });

                          it("calls getApp successfully with dates as Date objects", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const mockResponse = {
                              id: QB_APP_ID,
                              name: "qb-copy",
                              created: new Date("2025-02-13T18:22:33Z"), // Expect Date object
                              updated: new Date("2025-03-04T04:25:51Z"), // Expect Date object
                              description: "",
                              timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                              dateFormat: "MM-DD-YYYY",
                              hasEveryoneOnTheInternet: false,
                              memoryInfo: { estMemory: 0, estMemoryInclDependentApps: 0 },
                              securityProperties: {
                                allowClone: false,
                                allowExport: true,
                                enableAppTokens: true,
                                hideFromPublic: false,
                                mustBeRealmApproved: false,
                                useIPFilter: false,
                              },
                              ancestorId: undefined,
                              variables: undefined,
                              dataClassification: undefined,
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.getApp({ appId: QB_APP_ID });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: undefined,
                                credentials: "omit",
                              })
                            );
                          });

                          it("calls getApp successfully with dates as strings", async () => {
                            client = createClient(mockFetch, { debug: true, convertDates: false });

                            const mockResponse = {
                              id: QB_APP_ID,
                              name: "qb-copy",
                              created: "2025-02-13T18:22:33Z", // Expect string
                              updated: "2025-03-04T04:25:51Z", // Expect string
                              description: "",
                              timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                              dateFormat: "MM-DD-YYYY",
                              hasEveryoneOnTheInternet: false,
                              memoryInfo: { estMemory: 0, estMemoryInclDependentApps: 0 },
                              securityProperties: {
                                allowClone: false,
                                allowExport: true,
                                enableAppTokens: true,
                                hideFromPublic: false,
                                mustBeRealmApproved: false,
                                useIPFilter: false,
                              },
                              ancestorId: undefined,
                              variables: undefined,
                              dataClassification: undefined,
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.getApp({ appId: QB_APP_ID });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: undefined,
                                credentials: "omit",
                              })
                            );
                          });
                        });
                    - name: >-
                        getAppEvents.test.ts
                      type: >-
                        file
                      contents: >
                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_APP_ID,
                          QB_REALM,
                          QB_USER_TOKEN,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                        GetAppEvents200Response
                        }
                        from
                        "@/generated/models";


                        describe("QuickbaseClient
                        Unit
                        -
                        getAppEvents",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                          });

                          it("initializes and has getAppEvents method", () => {
                            client = createClient(mockFetch, { debug: true });
                            expect(client).toBeDefined();
                            expect(typeof client.getAppEvents).toBe("function");
                          });

                          it("fetches app events successfully with user token", async () => {
                            client = createClient(mockFetch, {
                              realm: QB_REALM,
                              userToken: QB_USER_TOKEN,
                              debug: true,
                            });

                            const mockResponse: GetAppEvents200Response = [
                              {
                                type: "qb-action",
                                owner: {
                                  email: "jsmith@quickbase.com",
                                  id: "123456.ab1s",
                                  name: "Juliet Smith",
                                  userName: "jsmith",
                                },
                                isActive: true,
                                tableId: "bqwriv8bw",
                                name: "Quick Base Action",
                              },
                              {
                                type: "webhook",
                                owner: {
                                  email: "tanderson@quickbase.com",
                                  id: "654321.ab1s",
                                  name: "Thomas A. Anderson",
                                  userName: "tanderson",
                                },
                                isActive: false,
                                tableId: "bqwriv8bw",
                                name: "Webhook",
                              },
                              {
                                type: "email-notification",
                                owner: {
                                  email: "jsmith@quickbase.com",
                                  id: "123456.ab1s",
                                  name: "Juliet Smith",
                                  userName: "jsmith",
                                },
                                isActive: false,
                                tableId: "bqwriv8bw",
                                name: "Notification",
                              },
                              {
                                type: "subscription",
                                owner: {
                                  email: "tanderson@quickbase.com",
                                  id: "654321.ab1s",
                                  name: "Thomas A. Anderson",
                                  userName: "tanderson",
                                },
                                isActive: true,
                                tableId: "bqwriv8bw",
                                name: "Subscription",
                              },
                              {
                                type: "reminder",
                                owner: {
                                  email: "jsmith@quickbase.com",
                                  id: "123456.ab1s",
                                  name: "Juliet Smith",
                                  userName: "jsmith",
                                },
                                isActive: true,
                                tableId: "bqwriv8bw",
                                name: "Reminder",
                              },
                              {
                                type: "automation",
                                owner: {
                                  email: "tanderson@quickbase.com",
                                  id: "654321.ab1s",
                                  name: "Thomas A. Anderson",
                                  userName: "tanderson",
                                },
                                isActive: true,
                                tableId: "bqwriv8bw",
                                url: "https://realm.quickbase.com/ui/automation/qb/db/bqwria893/automations/70eecab9-634f-42d9-9037-9340a1a9e8ce",
                              },
                            ];

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.getAppEvents({ appId: QB_APP_ID });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}/events`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "omit",
                              })
                            );
                          });

                          it("fetches app events successfully with temp token", async () => {
                            client = createClient(mockFetch, {
                              realm: QB_REALM,
                              useTempTokens: true,
                              debug: true,
                            });

                            const mockResponse: GetAppEvents200Response = [
                              {
                                type: "webhook",
                                owner: {
                                  email: "tanderson@quickbase.com",
                                  id: "654321.ab1s",
                                  name: "Thomas A. Anderson",
                                  userName: "tanderson",
                                },
                                isActive: false,
                                tableId: "bqwriv8bw",
                                name: "Webhook",
                              },
                            ];

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "temp_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const result = await client.getAppEvents({ appId: QB_APP_ID });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(2);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "include",
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}/events`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: "QB-TEMP-TOKEN temp_token",
                                  "Content-Type": "application/json",
                                }),
                                credentials: "omit",
                              })
                            );
                          });
                        });
                    - name: >-
                        updateApp.test.ts
                      type: >-
                        file
                      contents: >
                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach,
                        vi
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_APP_ID,
                          QB_REALM,
                          QB_USER_TOKEN,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                        UpdateAppRequest,
                        UpdateApp200Response
                        }
                        from
                        "@/generated/models";


                        describe("QuickbaseClient
                        Unit
                        -
                        updateApp",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                          });

                          it("initializes without errors and has updateApp method", () => {
                            client = createClient(mockFetch, { debug: true });
                            expect(client).toBeDefined();
                            expect(typeof client.updateApp).toBe("function");
                          });

                          it("updates app successfully with user token and dates as Date objects", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const request: UpdateAppRequest = {
                              name: "Updated Testing App",
                              description: "Updated description",
                              variables: [
                                { name: "Project End Date", value: "7-16-2025" },
                                { name: "Project Manager Email", value: "p.diaz@company.com" },
                              ],
                              securityProperties: {
                                allowClone: true,
                                allowExport: true,
                                enableAppTokens: true,
                                hideFromPublic: true,
                                mustBeRealmApproved: false,
                                useIPFilter: false,
                              },
                            };

                            const mockResponse: UpdateApp200Response = {
                              id: QB_APP_ID,
                              name: "Updated Testing App",
                              description: "Updated description",
                              created: new Date("2020-03-27T18:34:12Z"),
                              updated: new Date("2025-03-17T12:00:00Z"),
                              dateFormat: "MM-DD-YYYY",
                              timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                              hasEveryoneOnTheInternet: true,
                              ancestorId: "bqhskthaq",
                              variables: request.variables,
                              securityProperties: request.securityProperties,
                              memoryInfo: { estMemory: 1, estMemoryInclDependentApps: 2 },
                              dataClassification: "Confidential",
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.updateApp({ appId: QB_APP_ID, body: request });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                                credentials: "omit",
                              })
                            );
                          });

                          it("updates app successfully with temp token and dates as strings", async () => {
                            client = createClient(mockFetch, {
                              useTempTokens: true,
                              debug: true,
                              convertDates: false,
                            });

                            const request: UpdateAppRequest = {
                              name: "Updated Temp App",
                              description: "Temp token update",
                              variables: [{ name: "Var1", value: "Value1" }],
                            };

                            const mockResponse = {
                              id: QB_APP_ID,
                              name: "Updated Temp App",
                              description: "Temp token update",
                              created: "2020-03-27T18:34:12Z",
                              updated: "2025-03-17T12:00:00Z",
                              dateFormat: "MM-DD-YYYY",
                              timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                              hasEveryoneOnTheInternet: false,
                              ancestorId: "bqhskthaq",
                              variables: request.variables,
                              securityProperties: {
                                allowClone: false,
                                allowExport: false,
                                enableAppTokens: false,
                                hideFromPublic: false,
                                mustBeRealmApproved: true,
                                useIPFilter: true,
                              },
                              memoryInfo: { estMemory: 1, estMemoryInclDependentApps: 2 },
                              dataClassification: "None",
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "temp_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const result = await client.updateApp({ appId: QB_APP_ID, body: request });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(2);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "include",
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: "QB-TEMP-TOKEN temp_token",
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                                credentials: "omit",
                              })
                            );
                          });

                          it("retries successfully after 401 with temp token", async () => {
                            client = createClient(mockFetch, { useTempTokens: true, debug: true });

                            const request: UpdateAppRequest = {
                              name: "Retry Update App",
                              description: "Retry after 401",
                            };

                            const mockResponse: UpdateApp200Response = {
                              id: QB_APP_ID,
                              name: "Retry Update App",
                              description: "Retry after 401",
                              created: new Date("2020-03-27T18:34:12Z"),
                              updated: new Date("2025-03-17T12:00:00Z"),
                              dateFormat: "MM-DD-YYYY",
                              timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                              hasEveryoneOnTheInternet: false,
                              ancestorId: "bqhskthaq",
                              variables: [],
                              securityProperties: {
                                allowClone: false,
                                allowExport: false,
                                enableAppTokens: false,
                                hideFromPublic: false,
                                mustBeRealmApproved: true,
                                useIPFilter: true,
                              },
                              memoryInfo: { estMemory: 1, estMemoryInclDependentApps: 2 },
                              dataClassification: "Confidential",
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve({ temporaryAuthorization: "initial_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: false,
                                status: 401,
                                json: () => Promise.resolve({ message: "Unauthorized" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "new_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const consoleSpy = vi.spyOn(console, "log");
                            const result = await client.updateApp({ appId: QB_APP_ID, body: request });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(4);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_APP_ID}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN initial_token",
                                }),
                                body: JSON.stringify(request),
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              3,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_APP_ID}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              4,
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN new_token",
                                }),
                                body: JSON.stringify(request),
                              })
                            );
                            expect(consoleSpy).toHaveBeenCalledWith(
                              "Authorization error for updateApp (temp token), refreshing token:",
                              expect.any(String)
                            );
                            expect(consoleSpy).toHaveBeenCalledWith(
                              "Retrying updateApp with temp token"
                            );
                            consoleSpy.mockRestore();
                          });

                          it("handles 400 error for invalid request", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const request: UpdateAppRequest = {
                              name: "", // Invalid: empty name
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 400,
                              json: () => Promise.resolve({ message: "Name is required" }),
                            });

                            await expect(
                              client.updateApp({ appId: QB_APP_ID, body: request })
                            ).rejects.toThrow("API Error: Name is required (Status: 400)");

                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                                credentials: "omit",
                              })
                            );
                          });

                          it("handles edge case with more than 10 variables", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const tooManyVariables = Array(11)
                              .fill(null)
                              .map((_, i) => ({ name: `Var${i}`, value: `Value${i}` }));
                            const request: UpdateAppRequest = {
                              name: "Test App",
                              variables: tooManyVariables,
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 400,
                              json: () =>
                                Promise.resolve({ message: "Maximum of 10 variables allowed" }),
                            });

                            await expect(
                              client.updateApp({ appId: QB_APP_ID, body: request })
                            ).rejects.toThrow(
                              "API Error: Maximum of 10 variables allowed (Status: 400)"
                            );

                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "POST",
                                body: JSON.stringify(request),
                              })
                            );
                          });

                          it("handles empty variables and security properties", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const request: UpdateAppRequest = {
                              name: "Empty Test App",
                              variables: [],
                              securityProperties: {},
                            };

                            const mockResponse: UpdateApp200Response = {
                              id: QB_APP_ID,
                              name: "Empty Test App",
                              description: "",
                              created: new Date("2020-03-27T18:34:12Z"),
                              updated: new Date("2025-03-17T12:00:00Z"),
                              dateFormat: "MM-DD-YYYY",
                              timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                              hasEveryoneOnTheInternet: true,
                              ancestorId: "bqhskthaq",
                              variables: [],
                              securityProperties: {
                                allowClone: false,
                                allowExport: false,
                                enableAppTokens: false,
                                hideFromPublic: false,
                                mustBeRealmApproved: true,
                                useIPFilter: true,
                              },
                              memoryInfo: { estMemory: 1, estMemoryInclDependentApps: 2 },
                              dataClassification: "Confidential",
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.updateApp({ appId: QB_APP_ID, body: request });

                            expect(result).toEqual(mockResponse);
                            expect(result.variables).toEqual([]);
                            expect(result.securityProperties).toBeDefined();
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/apps/${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "POST",
                                body: JSON.stringify(request),
                              })
                            );
                          });
                        });
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        fetchTempToken401.test.ts
                      type: >-
                        file
                      contents: >
                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach,
                        vi
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_REALM,
                          QB_TABLE_ID_1,
                        }
                        from
                        "@tests/setup.ts";


                        describe("QuickbaseClient
                        Unit
                        -
                        401
                        with
                        fetchTempToken
                        401",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            client = createClient(mockFetch, { useTempTokens: true, debug: true });
                          });

                          it("fails without infinite loop when fetchTempToken returns 401 after initial 401", async () => {
                            const mockToken = "initial_token";
                            let callCount = 0;

                            mockFetch.mockImplementation((url) => {
                              callCount++;
                              if (url.includes("auth/temporary") && callCount === 1) {
                                return Promise.resolve({
                                  ok: true,
                                  status: 200,
                                  json: () => Promise.resolve({ temporaryAuthorization: mockToken }),
                                });
                              }
                              if (url.includes("fields") && callCount === 2) {
                                return Promise.resolve({
                                  ok: false,
                                  status: 401,
                                  json: () => Promise.resolve({ message: "Unauthorized" }),
                                });
                              }
                              if (url.includes("auth/temporary") && callCount === 3) {
                                return Promise.resolve({
                                  ok: false,
                                  status: 401,
                                  json: () => Promise.resolve({ message: "Temp token fetch failed" }),
                                });
                              }
                              return Promise.reject(new Error(`Unexpected fetch call: ${url}`));
                            });

                            const consoleSpy = vi.spyOn(console, "log");

                            await expect(client.getFields({ tableId: QB_TABLE_ID_1 })).rejects.toThrow(
                              "API Error: Temp token fetch failed (Status: 401)"
                            );

                            expect(mockFetch).toHaveBeenCalledTimes(3);

                            expect(consoleSpy).toHaveBeenCalledWith(
                              "Authorization error for getFields (temp token), refreshing token:",
                              expect.any(String)
                            );

                            consoleSpy.mockRestore();
                          });
                        });
                    - name: >-
                        getTempToken.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/auth/getTempTokenDBID.test.ts

                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_REALM,
                          QB_TABLE_ID_1,
                        }
                        from
                        "@tests/setup.ts";


                        describe("QuickbaseClient
                        Unit
                        -
                        getTempTokenDBID",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            client = createClient(mockFetch, { useTempTokens: true, debug: false });
                          });

                          it("initializes without errors", () => {
                            expect(client).toBeDefined();
                          });

                          it("has getTempTokenDBID method", () => {
                            expect(typeof client.getTempTokenDBID).toBe("function");
                          });

                          it("fetches and caches temp token on first call", async () => {
                            const mockToken = "b123xyz_temp_token";

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve({ temporaryAuthorization: mockToken }),
                            });

                            const result = await client.getTempTokenDBID({ dbid: QB_TABLE_ID_1 });
                            expect(result).toEqual({ temporaryAuthorization: mockToken });
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/auth/temporary/${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "include",
                              })
                            );
                          });

                          it("reuses cached temp token on second call", async () => {
                            const mockToken = "b123xyz_temp_token";

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve({ temporaryAuthorization: mockToken }),
                            });

                            const firstResult = await client.getTempTokenDBID({ dbid: QB_TABLE_ID_1 });
                            expect(firstResult).toEqual({ temporaryAuthorization: mockToken });
                            expect(mockFetch).toHaveBeenCalledTimes(1);

                            mockFetch.mockClear();
                            const secondResult = await client.getTempTokenDBID({ dbid: QB_TABLE_ID_1 });
                            expect(secondResult).toEqual({ temporaryAuthorization: mockToken });
                            expect(mockFetch).not.toHaveBeenCalled();
                          });

                          it("handles API error", async () => {
                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 401,
                              json: () => Promise.resolve({ message: "Unauthorized" }),
                            });

                            await expect(
                              client.getTempTokenDBID({ dbid: QB_TABLE_ID_1 })
                            ).rejects.toSatisfy((error: Error) => {
                              expect(error).toBeInstanceOf(Error);
                              expect(error.message).toBe("API Error: Unauthorized (Status: 401)");
                              return true;
                            });
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/auth/temporary/${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "include",
                              })
                            );
                          });
                        });
                    - name: >-
                        retryTempToken401.test.ts
                      type: >-
                        file
                      contents: >
                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach,
                        vi
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_REALM,
                          QB_TABLE_ID_1,
                        }
                        from
                        "@tests/setup.ts";


                        describe("QuickbaseClient
                        Unit
                        -
                        Temp
                        Token
                        Retry
                        on
                        401",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            client = createClient(mockFetch, { useTempTokens: true, debug: true });
                          });

                          it("creates a new token on 401 and retries successfully", async () => {
                            const mockToken = "new_token_456";
                            const mockFields = [{ id: 1, label: "Field1" }];
                            let callCount = 0;

                            mockFetch.mockImplementation((url) => {
                              callCount++;
                              if (url.includes("auth/temporary") && callCount === 1) {
                                return Promise.resolve({
                                  ok: true,
                                  status: 200,
                                  json: () => Promise.resolve({ temporaryAuthorization: mockToken }),
                                });
                              }
                              if (url.includes("fields") && callCount === 2) {
                                return Promise.resolve({
                                  ok: false,
                                  status: 401,
                                  json: () => Promise.resolve({ message: "Unauthorized" }),
                                });
                              }
                              if (url.includes("auth/temporary") && callCount === 3) {
                                return Promise.resolve({
                                  ok: true,
                                  status: 200,
                                  json: () =>
                                    Promise.resolve({ temporaryAuthorization: mockToken + "_retry" }),
                                });
                              }
                              if (url.includes("fields") && callCount === 4) {
                                return Promise.resolve({
                                  ok: true,
                                  status: 200,
                                  json: () => Promise.resolve(mockFields),
                                });
                              }
                              return Promise.reject(new Error(`Unexpected fetch call: ${url}`));
                            });

                            const consoleSpy = vi.spyOn(console, "log");

                            const result = await client.getFields({ tableId: QB_TABLE_ID_1 });

                            expect(result).toEqual(mockFields);
                            expect(mockFetch).toHaveBeenCalledTimes(4);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_TABLE_ID_1}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/fields?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                }),
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              3,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_TABLE_ID_1}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              4,
                              `https://api.quickbase.com/v1/fields?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                }),
                              })
                            );

                            const tokenLogs = consoleSpy.mock.calls.filter((call) =>
                              call[0].includes("Fetched and cached new token")
                            );
                            expect(tokenLogs).toContainEqual([
                              `Fetched and cached new token for dbid: ${QB_TABLE_ID_1}`,
                              mockToken,
                            ]);
                            expect(tokenLogs).toContainEqual([
                              `Fetched and cached new token for dbid: ${QB_TABLE_ID_1}`,
                              mockToken + "_retry",
                            ]);

                            expect(consoleSpy).toHaveBeenCalledWith(
                              "Authorization error for getFields (temp token), refreshing token:",
                              expect.any(String)
                            );
                            expect(consoleSpy).toHaveBeenCalledWith(
                              "Retrying getFields with temp token"
                            );

                            consoleSpy.mockRestore();
                          });
                        });
                    - name: >-
                        retryTempTokenTwo401.test.ts
                      type: >-
                        file
                      contents: >
                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach,
                        vi
                        }
                        from
                        "vitest";

                        import
                        {
                        createClient,
                        mockFetch
                        }
                        from
                        "@tests/setup.ts";


                        describe("QuickbaseClient
                        -
                        Two
                        Temp
                        Token
                        401s
                        in
                        a
                        Row",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            client = createClient(mockFetch, { useTempTokens: true, debug: true });
                          });

                          it("logs an error after two 401s in a row", async () => {
                            const mockDbid = "mockDbid123";
                            const mockToken = "new_token_456";
                            let callCount = 0;

                            mockFetch.mockImplementation((url) => {
                              callCount++;
                              if (url.includes("auth/temporary") && callCount === 1) {
                                return Promise.resolve({
                                  ok: true,
                                  status: 200,
                                  json: () => Promise.resolve({ temporaryAuthorization: mockToken }),
                                });
                              }
                              if (url.includes("fields") && callCount === 2) {
                                return Promise.resolve({
                                  ok: false,
                                  status: 401,
                                  json: () => Promise.resolve({ message: "Unauthorized" }),
                                });
                              }
                              if (url.includes("auth/temporary") && callCount === 3) {
                                return Promise.resolve({
                                  ok: true,
                                  status: 200,
                                  json: () =>
                                    Promise.resolve({ temporaryAuthorization: mockToken + "_retry" }),
                                });
                              }
                              if (url.includes("fields") && callCount === 4) {
                                return Promise.resolve({
                                  ok: false,
                                  status: 401,
                                  json: () => Promise.resolve({ message: "Unauthorized again" }),
                                });
                              }
                              return Promise.reject(new Error(`Unexpected fetch call: ${url}`));
                            });

                            const consoleSpy = vi.spyOn(console, "log");

                            await expect(client.getFields({ tableId: mockDbid })).rejects.toThrow(
                              "API Error: Unauthorized again (Status: 401)"
                            );

                            expect(mockFetch).toHaveBeenCalledTimes(4);

                            const tokenLogs = consoleSpy.mock.calls.filter((call) =>
                              call[0].includes("Fetched and cached new token")
                            );
                            expect(tokenLogs).toContainEqual([
                              "Fetched and cached new token for dbid: mockDbid123",
                              mockToken,
                            ]);
                            expect(tokenLogs).toContainEqual([
                              "Fetched and cached new token for dbid: mockDbid123",
                              mockToken + "_retry",
                            ]);

                            expect(consoleSpy).toHaveBeenCalledWith(
                              "Authorization error for getFields (temp token), refreshing token:",
                              expect.any(String)
                            );
                            expect(consoleSpy).toHaveBeenCalledWith(
                              "Retrying getFields with temp token"
                            );

                            consoleSpy.mockRestore();
                          });
                        });
                    - name: >-
                        retryUserToken401.test.ts
                      type: >-
                        file
                      contents: >
                        import
                        {
                        describe,
                        it,
                        vi,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                        quickbase,
                        QuickbaseClient
                        }
                        from
                        "../../../../src/quickbaseClient";

                        import
                        {
                        ResponseError
                        }
                        from
                        "../../../../src/generated/runtime";


                        describe("QuickbaseClient
                        Integration
                        -
                        User
                        Token
                        Retry
                        on
                        401",
                        ()
                        =>
                        {
                          let client: QuickbaseClient;
                          const mockFetch = vi.fn();

                          beforeEach(() => {
                            const config = {
                              realm: process.env.QB_REALM || "builderprogram-dbradford6815",
                              userToken: "mock-user-token",
                              debug: true,
                              fetchApi: mockFetch,
                            };
                            console.log("[quickbaseTest] Config:", config);
                            client = quickbase(config);
                          });

                          it("retries on transient 401 with user token and succeeds", async () => {
                            const consoleSpy = vi.spyOn(console, "log");

                            mockFetch
                              .mockImplementationOnce(() => {
                                const response = new Response(null, {
                                  status: 401,
                                  statusText: "Unauthorized",
                                });
                                console.log("[mockFetch] Throwing 401 ResponseError");
                                return Promise.reject(new ResponseError(response));
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: async () => [{ id: 1, label: "Mock Field", fieldType: "text" }],
                              });

                            const fields = await client.getFields({ tableId: "mock-table-id" });

                            expect(fields).toBeInstanceOf(Array);
                            expect(fields.length).toBeGreaterThan(0);
                            expect(fields[0]).toHaveProperty("id");
                            expect(fields[0]).toHaveProperty("label");

                            expect(consoleSpy).toHaveBeenCalledWith(
                              "Authorization error for getFields (user token), retrying with same token:",
                              "" // Matches empty ResponseError message from mock
                            );
                            expect(consoleSpy).toHaveBeenCalledWith(
                              "Retrying getFields with user token"
                            );
                            expect(mockFetch).toHaveBeenCalledTimes(2);

                            consoleSpy.mockRestore();
                          });
                        });
                - name: >-
                    fields
                  type: >-
                    directory
                  children:
                    - name: >-
                        createField.test.ts
                      type: >-
                        file
                      contents: >
                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach,
                        vi
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_REALM,
                          QB_USER_TOKEN,
                          QB_TABLE_ID_1,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                        CreateFieldRequest,
                        CreateField200Response
                        }
                        from
                        "@/generated/models";


                        describe("QuickbaseClient
                        Unit
                        -
                        createField",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                          });

                          it("initializes without errors and has createField method", () => {
                            client = createClient(mockFetch, { debug: true });
                            expect(client).toBeDefined();
                            expect(typeof client.createField).toBe("function");
                          });

                          it("creates a field successfully with user token", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const request: CreateFieldRequest = {
                              label: "TestField",
                              fieldType: "text",
                              fieldHelp: "A test field",
                              addToForms: true,
                              permissions: [
                                { role: "Viewer", permissionType: "View", roleId: 10 },
                                { role: "Administrator", permissionType: "Modify", roleId: 12 },
                              ],
                            };

                            const mockResponse: CreateField200Response = {
                              id: 100,
                              label: "TestField",
                              fieldType: "text",
                              mode: "",
                              noWrap: false,
                              bold: false,
                              required: false,
                              appearsByDefault: true,
                              findEnabled: true,
                              unique: false,
                              doesDataCopy: false,
                              fieldHelp: "A test field",
                              audited: false,
                              properties: {
                                primaryKey: false,
                                foreignKey: false,
                                numLines: 1,
                                maxLength: 0,
                                appendOnly: false,
                                allowHTML: false,
                                allowMentions: false,
                                sortAsGiven: false,
                                carryChoices: true,
                                allowNewChoices: false,
                                formula: "",
                                defaultValue: "",
                              },
                              permissions: [
                                { permissionType: "View", role: "Viewer", roleId: 10 },
                                { permissionType: "Modify", role: "Administrator", roleId: 12 },
                              ],
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.createField({
                              tableId: QB_TABLE_ID_1,
                              body: request,
                            });

                            expect(result).toEqual(mockResponse);
                            const callArgs = mockFetch.mock.calls[0];
                            console.log("Raw fetch call (user token):", callArgs);
                            const receivedBody = JSON.parse(callArgs[1].body as string);
                            expect(receivedBody).toEqual(request);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                              })
                            );
                          });

                          it("creates a field successfully with temp token", async () => {
                            client = createClient(mockFetch, { useTempTokens: true, debug: true });

                            const request: CreateFieldRequest = {
                              label: "TempField",
                              fieldType: "numeric",
                              addToForms: false,
                            };

                            const mockResponse: CreateField200Response = {
                              id: 101,
                              label: "TempField",
                              fieldType: "numeric",
                              mode: "",
                              noWrap: false,
                              bold: false,
                              required: false,
                              appearsByDefault: true,
                              findEnabled: true,
                              unique: false,
                              doesDataCopy: false,
                              fieldHelp: "",
                              audited: false,
                              properties: {
                                primaryKey: false,
                                foreignKey: false,
                                numLines: 1,
                                maxLength: 0,
                                appendOnly: false,
                                allowHTML: false,
                                allowMentions: false,
                                sortAsGiven: false,
                                carryChoices: true,
                                allowNewChoices: false,
                                formula: "",
                                defaultValue: "",
                              },
                              permissions: [],
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "temp_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const result = await client.createField({
                              tableId: QB_TABLE_ID_1,
                              body: request,
                            });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(2);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "include",
                              })
                            );
                            const callArgs = mockFetch.mock.calls[1];
                            console.log("Raw fetch call (temp token):", callArgs);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/fields?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: "QB-TEMP-TOKEN temp_token",
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                              })
                            );
                          });

                          it("retries successfully after 401 with temp token", async () => {
                            client = createClient(mockFetch, { useTempTokens: true, debug: true });

                            const request: CreateFieldRequest = {
                              label: "RetryField",
                              fieldType: "checkbox",
                            };

                            const mockResponse: CreateField200Response = {
                              id: 102,
                              label: "RetryField",
                              fieldType: "checkbox",
                              mode: "",
                              noWrap: false,
                              bold: false,
                              required: false,
                              appearsByDefault: true,
                              findEnabled: true,
                              unique: false,
                              doesDataCopy: false,
                              fieldHelp: "",
                              audited: false,
                              properties: {
                                primaryKey: false,
                                foreignKey: false,
                                numLines: 1,
                                maxLength: 0,
                                appendOnly: false,
                                allowHTML: false,
                                allowMentions: false,
                                sortAsGiven: false,
                                carryChoices: true,
                                allowNewChoices: false,
                                formula: "",
                                defaultValue: "",
                              },
                              permissions: [],
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve({ temporaryAuthorization: "initial_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: false,
                                status: 401,
                                json: () => Promise.resolve({ message: "Unauthorized" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "new_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const consoleSpy = vi.spyOn(console, "log");
                            const result = await client.createField({
                              tableId: QB_TABLE_ID_1,
                              body: request,
                            });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(4);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_TABLE_ID_1}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/fields?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN initial_token",
                                }),
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              3,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_TABLE_ID_1}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              4,
                              `https://api.quickbase.com/v1/fields?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN new_token",
                                }),
                              })
                            );
                            expect(consoleSpy).toHaveBeenCalledWith(
                              "Authorization error for createField (temp token), refreshing token:",
                              expect.any(String)
                            );
                            expect(consoleSpy).toHaveBeenCalledWith(
                              "Retrying createField with temp token"
                            );
                            consoleSpy.mockRestore();
                          });

                          it("handles 400 error for invalid request", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const request: CreateFieldRequest = {
                              label: "", // Invalid: label is required
                              fieldType: "text",
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 400,
                              json: () => Promise.resolve({ message: "Label is required" }),
                            });

                            await expect(
                              client.createField({ tableId: QB_TABLE_ID_1, body: request })
                            ).rejects.toThrow("API Error: Label is required (Status: 400)");

                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                              })
                            );
                          });

                          it("handles 401 with failed temp token retry", async () => {
                            client = createClient(mockFetch, { useTempTokens: true, debug: true });

                            const request: CreateFieldRequest = {
                              label: "FailField",
                              fieldType: "text",
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve({ temporaryAuthorization: "initial_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: false,
                                status: 401,
                                json: () => Promise.resolve({ message: "Unauthorized" }),
                              })
                              .mockResolvedValueOnce({
                                ok: false,
                                status: 401,
                                json: () => Promise.resolve({ message: "Temp token fetch failed" }),
                              });

                            const consoleSpy = vi.spyOn(console, "log");
                            await expect(
                              client.createField({ tableId: QB_TABLE_ID_1, body: request })
                            ).rejects.toThrow("API Error: Temp token fetch failed (Status: 401)");

                            expect(mockFetch).toHaveBeenCalledTimes(3);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_TABLE_ID_1}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/fields?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN initial_token",
                                }),
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              3,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_TABLE_ID_1}`,
                              expect.any(Object)
                            );
                            expect(consoleSpy).toHaveBeenCalledWith(
                              "Authorization error for createField (temp token), refreshing token:",
                              expect.any(String)
                            );
                            consoleSpy.mockRestore();
                          });
                        });
                    - name: >-
                        deleteFields.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/fields/deleteFields.test.ts

                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_REALM,
                          QB_USER_TOKEN,
                          QB_TABLE_ID_1,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                          DeleteFieldsRequest,
                          DeleteFields200Response,
                        }
                        from
                        "@/generated/models";


                        describe("QuickbaseClient
                        Unit
                        -
                        deleteFields",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                          });

                          it("initializes without errors and has deleteFields method", () => {
                            client = createClient(mockFetch, { debug: true });
                            expect(client).toBeDefined();
                            expect(typeof client.deleteFields).toBe("function");
                          });

                          it("deletes fields successfully with user token", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const request: DeleteFieldsRequest = {
                              fieldIds: [6, 7, 8],
                            };

                            const mockResponse: DeleteFields200Response = {
                              deletedFieldIds: [6, 7, 8],
                              errors: [],
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.deleteFields({
                              tableId: QB_TABLE_ID_1,
                              body: request,
                            });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "DELETE",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                                credentials: "omit",
                              })
                            );
                          });

                          it("handles partial success with errors", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const request: DeleteFieldsRequest = {
                              fieldIds: [6, 7, 8],
                            };

                            const mockResponse: DeleteFields200Response = {
                              deletedFieldIds: [6, 8],
                              errors: ["Error found with fid: 7"],
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.deleteFields({
                              tableId: QB_TABLE_ID_1,
                              body: request,
                            });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "DELETE",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                                credentials: "omit",
                              })
                            );
                          });

                          it("handles 400 error for invalid request", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const request: DeleteFieldsRequest = {
                              fieldIds: [], // Invalid: empty fieldIds array
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 400,
                              json: () =>
                                Promise.resolve({
                                  message: "Invalid input",
                                  description: "Field IDs list cannot be empty.",
                                }),
                            });

                            await expect(
                              client.deleteFields({ tableId: QB_TABLE_ID_1, body: request })
                            ).rejects.toThrow("API Error: Invalid input (Status: 400)");

                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "DELETE",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                                credentials: "omit",
                              })
                            );
                          });
                        });
                    - name: >-
                        getField.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/fields/getField.test.ts

                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_REALM,
                          QB_USER_TOKEN,
                          QB_TABLE_ID_1,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                        Field
                        }
                        from
                        "@/generated/models";


                        describe("QuickbaseClient
                        Unit
                        -
                        getField",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            client = createClient(mockFetch, { debug: true });
                          });

                          it("initializes without errors and has getField method", () => {
                            expect(client).toBeDefined();
                            expect(typeof client.getField).toBe("function");
                          });

                          it("calls getField successfully with user token", async () => {
                            const mockResponse: Field = {
                              id: 123,
                              label: "Field1",
                              fieldType: "text",
                              mode: "",
                              noWrap: false,
                              bold: false,
                              required: false,
                              appearsByDefault: false,
                              findEnabled: false,
                              unique: false,
                              doesDataCopy: false,
                              fieldHelp: "field help",
                              audited: false,
                              properties: {
                                primaryKey: false,
                                foreignKey: false,
                                numLines: 1,
                                maxLength: 0,
                                appendOnly: false,
                                allowHTML: false,
                                allowMentions: false,
                                sortAsGiven: false,
                                carryChoices: true,
                                allowNewChoices: false,
                                formula: "",
                                defaultValue: "",
                              },
                              permissions: [
                                { permissionType: "View", role: "Viewer", roleId: 10 },
                                { permissionType: "None", role: "Participant", roleId: 11 },
                                { permissionType: "Modify", role: "Administrator", roleId: 12 },
                              ],
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.getField({
                              fieldId: 123,
                              tableId: QB_TABLE_ID_1,
                              includeFieldPerms: true,
                            });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields/123?tableId=${QB_TABLE_ID_1}&includeFieldPerms=true`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                              })
                            );
                          });

                          it("calls getField successfully with temp token", async () => {
                            client = createClient(mockFetch, { useTempTokens: true, debug: true });

                            const mockResponse: Field = {
                              id: 123,
                              label: "Field1",
                              fieldType: "text",
                              mode: "",
                              noWrap: false,
                              bold: false,
                              required: false,
                              appearsByDefault: false,
                              findEnabled: false,
                              unique: false,
                              doesDataCopy: false,
                              fieldHelp: "field help",
                              audited: false,
                              properties: {
                                primaryKey: false,
                                foreignKey: false,
                                numLines: 1,
                                maxLength: 0,
                                appendOnly: false,
                                allowHTML: false,
                                allowMentions: false,
                                sortAsGiven: false,
                                carryChoices: true,
                                allowNewChoices: false,
                                formula: "",
                                defaultValue: "",
                              },
                              permissions: [],
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "temp_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const result = await client.getField({
                              fieldId: 123,
                              tableId: QB_TABLE_ID_1,
                            });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(2);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "include",
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/fields/123?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: "QB-TEMP-TOKEN temp_token",
                                  "Content-Type": "application/json",
                                }),
                              })
                            );
                          });

                          it("handles 404 error for non-existent field", async () => {
                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 404,
                              json: () => Promise.resolve({ message: "Field not found" }),
                            });

                            await expect(
                              client.getField({ fieldId: 999, tableId: QB_TABLE_ID_1 })
                            ).rejects.toThrow("API Error: Field not found (Status: 404)");

                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields/999?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                              })
                            );
                          });
                        });
                    - name: >-
                        getFieldUsage.test.ts
                      type: >-
                        file
                      contents: >
                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_REALM,
                          QB_USER_TOKEN,
                          QB_TABLE_ID_1,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                        FieldUsage
                        }
                        from
                        "@/generated/models";


                        describe("QuickbaseClient
                        Unit
                        -
                        getFieldUsage",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            client = createClient(mockFetch, { realm: QB_REALM, debug: true });
                          });

                          it("initializes without errors and has getFieldUsage method", () => {
                            expect(client).toBeDefined();
                            expect(typeof client.getFieldUsage).toBe("function");
                          });

                          it("calls getFieldUsage successfully with user token", async () => {
                            const mockResponse: FieldUsage = {
                              field: {
                                id: 6,
                                name: "name",
                                type: "text",
                              },
                              usage: {
                                actions: { count: 0 },
                                appHomePages: { count: 0 },
                                dashboards: { count: 2 },
                                defaultReports: { count: 1 },
                                exactForms: { count: 0 },
                                fields: { count: 0 },
                                forms: { count: 1 },
                                notifications: { count: 0 },
                                personalReports: { count: 0 },
                                pipelines: { count: 1 },
                                relationships: { count: 0 },
                                reminders: { count: 0 },
                                reports: { count: 2 },
                                roles: { count: 2 },
                                tableImports: { count: 2 },
                                tableRules: { count: 1 },
                                webhooks: { count: 0 },
                              },
                            };

                            mockFetch.mockResolvedValueOnce(
                              new Response(JSON.stringify([mockResponse]), {
                                status: 200,
                                statusText: "OK",
                                headers: { "Content-Type": "application/json" },
                              })
                            );

                            const result = await client.getFieldUsage({
                              fieldId: 6,
                              tableId: QB_TABLE_ID_1,
                            });

                            expect(result).toBeInstanceOf(Array);
                            expect(result).toHaveLength(1);
                            const fieldUsage = result[0];

                            expect(fieldUsage).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields/usage/6?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                              })
                            );
                            expect(fieldUsage.field.id).toBe(6);
                            expect(fieldUsage.field.name).toBe("name");
                            expect(fieldUsage.usage.dashboards.count).toBe(2);
                          });

                          it("handles 404 error for non-existent field", async () => {
                            mockFetch.mockResolvedValueOnce(
                              new Response(JSON.stringify({ message: "Field not found" }), {
                                status: 404,
                                statusText: "Not Found",
                                headers: { "Content-Type": "application/json" },
                              })
                            );

                            await expect(
                              client.getFieldUsage({
                                fieldId: 999,
                                tableId: QB_TABLE_ID_1,
                              })
                            ).rejects.toThrow("API Error: Field not found (Status: 404)");

                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields/usage/999?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                              })
                            );
                          });

                          it("handles persistent 401 error for field usage retrieval", async () => {
                            // Simulate a persistent 401 error (initial and retry attempts fail)
                            mockFetch
                              .mockResolvedValueOnce(
                                new Response(JSON.stringify({ message: "Unauthorized" }), {
                                  status: 401,
                                  statusText: "Unauthorized",
                                  headers: { "Content-Type": "application/json" },
                                })
                              )
                              .mockResolvedValueOnce(
                                new Response(JSON.stringify({ message: "Unauthorized" }), {
                                  status: 401,
                                  statusText: "Unauthorized",
                                  headers: { "Content-Type": "application/json" },
                                })
                              );

                            await expect(
                              client.getFieldUsage({
                                fieldId: 6,
                                tableId: QB_TABLE_ID_1,
                              })
                            ).rejects.toThrow("API Error: Unauthorized (Status: 401)");

                            expect(mockFetch).toHaveBeenCalledTimes(2); // Initial call + 1 retry
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/fields/usage/6?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/fields/usage/6?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                              })
                            );
                          });
                        });
                    - name: >-
                        getFields.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/fields/getFields.test.ts

                        import
                        {
                        describe,
                        it,
                        expect
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_REALM,
                          QB_USER_TOKEN,
                          QB_TABLE_ID_1,
                        }
                        from
                        "@tests/setup.ts";


                        describe("QuickbaseClient
                        Unit
                        -
                        getFields",
                        ()
                        =>
                        {
                          it("calls getFields successfully", async () => {
                            mockFetch.mockImplementation((url: string, options: any) => {
                              console.log("Mock fetch for getFields:", url, options);
                              return Promise.resolve({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve([
                                    {
                                      id: 1,
                                      label: "Field1",
                                      fieldType: "text",
                                      noWrap: false,
                                      bold: false,
                                      required: false,
                                      appearsByDefault: false,
                                      findEnabled: false,
                                      unique: false,
                                      doesDataCopy: false,
                                      fieldHelp: "field help",
                                      audited: false,
                                      properties: {
                                        primaryKey: false,
                                        foreignKey: false,
                                        numLines: 1,
                                        maxLength: 0,
                                        appendOnly: false,
                                        allowHTML: false,
                                        allowMentions: false,
                                        sortAsGiven: false,
                                        carryChoices: true,
                                        allowNewChoices: false,
                                        formula: "",
                                        defaultValue: "",
                                      },
                                      permissions: [
                                        { permissionType: "View", role: "Viewer", roleId: 10 },
                                        { permissionType: "None", role: "Participant", roleId: 11 },
                                        { permissionType: "Modify", role: "Administrator", roleId: 12 },
                                      ],
                                    },
                                  ]),
                              } as Response);
                            });

                            const client = createClient(mockFetch, { debug: true }); // Add debug: true for consistency
                            const result = await client.getFields({
                              tableId: QB_TABLE_ID_1,
                              includeFieldPerms: true,
                            });
                            console.log("getFields response:", result);
                            expect(result).toEqual(
                              expect.arrayContaining([
                                expect.objectContaining({
                                  id: 1,
                                  label: "Field1",
                                  fieldType: "text",
                                  noWrap: false,
                                  bold: false,
                                  required: false,
                                  appearsByDefault: false,
                                  findEnabled: false,
                                  unique: false,
                                  doesDataCopy: false,
                                  fieldHelp: "field help",
                                  audited: false,
                                  properties: expect.objectContaining({
                                    primaryKey: false,
                                    foreignKey: false,
                                    numLines: 1,
                                    maxLength: 0,
                                    appendOnly: false,
                                    allowHTML: false,
                                    allowMentions: false,
                                    sortAsGiven: false,
                                    carryChoices: true,
                                    allowNewChoices: false,
                                    formula: "",
                                    defaultValue: "",
                                  }),
                                  permissions: expect.arrayContaining([
                                    expect.objectContaining({
                                      permissionType: "View",
                                      role: "Viewer",
                                      roleId: 10,
                                    }),
                                    expect.objectContaining({
                                      permissionType: "None",
                                      role: "Participant",
                                      roleId: 11,
                                    }),
                                    expect.objectContaining({
                                      permissionType: "Modify",
                                      role: "Administrator",
                                      roleId: 12,
                                    }),
                                  ]),
                                }),
                              ])
                            );
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields?tableId=${QB_TABLE_ID_1}&includeFieldPerms=true`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                }),
                              })
                            );
                          });
                        });
                    - name: >-
                        getFieldsUsage.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/fields/getFieldsUsage.test.ts

                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_REALM,
                          QB_TABLE_ID_1,
                          QB_USER_TOKEN,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                        FieldUsage
                        }
                        from
                        "@/generated/models";


                        describe("QuickbaseClient
                        Unit
                        -
                        getFieldsUsage",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            client = createClient(mockFetch, { debug: true });
                          });

                          it("initializes without errors and has getFieldsUsage method", () => {
                            expect(client).toBeDefined();
                            expect(typeof client.getFieldsUsage).toBe("function");
                          });

                          it("calls getFieldsUsage successfully with user token", async () => {
                            const mockResponse: FieldUsage[] = [
                              {
                                field: {
                                  id: 6,
                                  name: "name",
                                  type: "Text",
                                },
                                usage: {
                                  actions: { count: 0 },
                                  appHomePages: { count: 0 },
                                  dashboards: { count: 2 },
                                  defaultReports: { count: 1 },
                                  exactForms: { count: 0 },
                                  fields: { count: 0 },
                                  forms: { count: 1 },
                                  notifications: { count: 0 },
                                  personalReports: { count: 0 },
                                  pipelines: { count: 1 },
                                  relationships: { count: 0 },
                                  reminders: { count: 0 },
                                  reports: { count: 2 },
                                  roles: { count: 2 },
                                  tableImports: { count: 3 },
                                  tableRules: { count: 1 },
                                  webhooks: { count: 0 },
                                },
                              },
                            ];

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.getFieldsUsage({
                              tableId: QB_TABLE_ID_1,
                            });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields/usage?tableId=${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                              })
                            );
                          });

                          it("calls getFieldsUsage with skip and top parameters", async () => {
                            const mockResponse: FieldUsage[] = [
                              {
                                field: {
                                  id: 7,
                                  name: "priority",
                                  type: "Text",
                                },
                                usage: {
                                  actions: { count: 1 },
                                  appHomePages: { count: 0 },
                                  dashboards: { count: 0 },
                                  defaultReports: { count: 0 },
                                  exactForms: { count: 0 },
                                  fields: { count: 1 },
                                  forms: { count: 0 },
                                  notifications: { count: 0 },
                                  personalReports: { count: 0 },
                                  pipelines: { count: 0 },
                                  relationships: { count: 0 },
                                  reminders: { count: 0 },
                                  reports: { count: 1 },
                                  roles: { count: 1 },
                                  tableImports: { count: 0 },
                                  tableRules: { count: 0 },
                                  webhooks: { count: 0 },
                                },
                              },
                            ];

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.getFieldsUsage({
                              tableId: QB_TABLE_ID_1,
                              skip: 1,
                              top: 1,
                            });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields/usage?tableId=${QB_TABLE_ID_1}&skip=1&top=1`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                              })
                            );
                          });

                          it("handles 404 error for non-existent table", async () => {
                            const nonExistentTableId = "nonexistent_dbid";

                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 404,
                              json: () => Promise.resolve({ message: "Table not found" }),
                            });

                            await expect(
                              client.getFieldsUsage({ tableId: nonExistentTableId })
                            ).rejects.toThrow("API Error: Table not found (Status: 404)");

                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields/usage?tableId=${nonExistentTableId}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                              })
                            );
                          });
                        });
                    - name: >-
                        updateField.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/fields/updateField.test.ts

                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_APP_ID,
                          QB_REALM,
                          QB_USER_TOKEN,
                          QB_TABLE_ID_1,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                        UpdateFieldRequest,
                        UpdateField200Response
                        }
                        from
                        "@/generated/models";


                        describe("QuickbaseClient
                        Unit
                        -
                        updateField",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                          });

                          it("initializes and has updateField method", () => {
                            client = createClient(mockFetch, { debug: true });
                            expect(client).toBeDefined();
                            expect(typeof client.updateField).toBe("function");
                          });

                          it("updates field successfully with user token", async () => {
                            client = createClient(mockFetch, {
                              realm: QB_REALM,
                              userToken: QB_USER_TOKEN,
                              debug: true,
                            });

                            const tableId = QB_TABLE_ID_1;
                            const fieldId = 123;

                            const request: UpdateFieldRequest = {
                              label: "Field1",
                              // fieldType omitted as it’s not allowed in updates
                              noWrap: false,
                              bold: false,
                              required: true,
                              appearsByDefault: false,
                              findEnabled: false,
                              unique: true,
                              fieldHelp: "field help",
                              addToForms: true,
                              properties: {
                                numLines: 1,
                                maxLength: 50,
                                appendOnly: true,
                                sortAsGiven: false,
                                allowMentions: false,
                                comments: "Updated field settings",
                                doesTotal: false,
                                defaultValue: "Initial text",
                                choices: ["Option1", "Option2"], // Still valid for properties
                              },
                              permissions: [
                                { role: "Viewer", permissionType: "View", roleId: 10 },
                                { role: "Participant", permissionType: "None", roleId: 11 },
                                { role: "Administrator", permissionType: "Modify", roleId: 12 },
                              ],
                            };

                            const mockResponse: UpdateField200Response = {
                              id: fieldId,
                              label: "Field1",
                              fieldType: "text", // Returned by API, not updated
                              mode: "",
                              noWrap: false,
                              bold: false,
                              required: true,
                              appearsByDefault: false,
                              findEnabled: false,
                              unique: true,
                              doesDataCopy: false,
                              fieldHelp: "field help",
                              audited: false,
                              properties: {
                                numLines: 1,
                                maxLength: 50,
                                appendOnly: true,
                                sortAsGiven: false,
                                allowMentions: false,
                                comments: "Updated field settings",
                                doesTotal: false,
                                defaultValue: "Initial text",
                                choices: ["Option1", "Option2"],
                                allowHTML: false,
                                carryChoices: true,
                                allowNewChoices: false,
                                formula: "",
                              },
                              permissions: [
                                { permissionType: "View", role: "Viewer", roleId: 10 },
                                { permissionType: "None", role: "Participant", roleId: 11 },
                                { permissionType: "Modify", role: "Administrator", roleId: 12 },
                              ],
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.updateField({
                              fieldId,
                              tableId,
                              body: request,
                            });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields/${fieldId}?tableId=${tableId}`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                                credentials: "omit",
                              })
                            );
                          });

                          it("updates field successfully with temp token", async () => {
                            client = createClient(mockFetch, {
                              realm: QB_REALM,
                              useTempTokens: true,
                              debug: true,
                            });

                            const tableId = QB_TABLE_ID_1;
                            const fieldId = 123;

                            const request: UpdateFieldRequest = {
                              label: "Field1",
                              // fieldType omitted as it’s not allowed in updates
                              required: true,
                              unique: true,
                              properties: {
                                numLines: 1,
                                maxLength: 0,
                                choices: ["Yes", "No"],
                                allowNewChoices: true,
                                defaultValue: "No",
                              },
                            };

                            const mockResponse: UpdateField200Response = {
                              id: fieldId,
                              label: "Field1",
                              fieldType: "text-multiple-choice", // Returned by API, not updated
                              mode: "",
                              noWrap: false,
                              bold: false,
                              required: true,
                              appearsByDefault: false,
                              findEnabled: false,
                              unique: true,
                              doesDataCopy: false,
                              fieldHelp: "",
                              audited: false,
                              properties: {
                                numLines: 1,
                                maxLength: 0,
                                choices: ["Yes", "No"],
                                allowNewChoices: true,
                                defaultValue: "No",
                                appendOnly: false,
                                allowHTML: false,
                                allowMentions: false,
                                sortAsGiven: false,
                                carryChoices: true,
                                formula: "",
                              },
                              permissions: [
                                { permissionType: "View", role: "Viewer", roleId: 10 },
                                { permissionType: "None", role: "Participant", roleId: 11 },
                                { permissionType: "Modify", role: "Administrator", roleId: 12 },
                              ],
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "temp_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const result = await client.updateField({
                              fieldId,
                              tableId,
                              body: request,
                            });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(2);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${tableId}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "include",
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/fields/${fieldId}?tableId=${tableId}`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: "QB-TEMP-TOKEN temp_token",
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                                credentials: "omit",
                              })
                            );
                          });

                          it("handles 400 error for invalid field update", async () => {
                            client = createClient(mockFetch, {
                              realm: QB_REALM,
                              userToken: QB_USER_TOKEN,
                              debug: true,
                            });

                            const tableId = QB_TABLE_ID_1;
                            const fieldId = 999;

                            const request: UpdateFieldRequest = {
                              label: "InvalidField",
                              // fieldType omitted as it’s not allowed in updates
                              required: true,
                              properties: {
                                numLines: 1,
                                decimalPlaces: 2,
                                currencySymbol: "$",
                              },
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 400,
                              json: () => Promise.resolve({ message: "Invalid field ID" }),
                            });

                            await expect(
                              client.updateField({ fieldId, tableId, body: request })
                            ).rejects.toThrow("API Error: Invalid field ID (Status: 400)");

                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/fields/${fieldId}?tableId=${tableId}`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                                credentials: "omit",
                              })
                            );
                          });
                        });
                - name: >-
                    formulas
                  type: >-
                    directory
                  children: []
                - name: >-
                    index.ts
                  type: >-
                    file
                  contents: >
                    //
                    tests/vitest/unit/index.ts

                    //
                    Apps

                    export
                    *
                    from
                    "./apps/copyApp.test.ts";

                    export
                    *
                    from
                    "./apps/createApp.test.ts";

                    export
                    *
                    from
                    "./apps/deleteApp.test.ts";

                    export
                    *
                    from
                    "./apps/getApp.test.ts";


                    //
                    Auth

                    export
                    *
                    from
                    "./auth/fetchTempToken401.test.ts";

                    export
                    *
                    from
                    "./auth/getTempToken.test.ts";

                    export
                    *
                    from
                    "./auth/retryOn401.test.ts";

                    export
                    *
                    from
                    "./auth/retryTempTokenTwo401.test.ts";


                    //
                    Fields

                    export
                    *
                    from
                    "./fields/getFields.test.ts";

                    export
                    *
                    from
                    "./fields/getField.test.ts";

                    export
                    *
                    from
                    "./fields/createField.test.ts";

                    export
                    *
                    from
                    "./fields/deleteFields.test.ts";

                    export
                    *
                    from
                    "./fields/getFieldsUsage.test.ts";

                    export
                    *
                    from
                    "./fields/getFieldUsage.test.ts";


                    //
                    Records

                    export
                    *
                    from
                    "./records/deleteRecords.test.ts";

                    export
                    *
                    from
                    "./records/runQuery.test.ts";

                    export
                    *
                    from
                    "./records/upsert.test.ts";


                    //
                    Tables

                    export
                    *
                    from
                    "./tables/createTable.test.ts";

                    export
                    *
                    from
                    "./tables/deleteTable.test.ts";

                    export
                    *
                    from
                    "./tables/getAppTables.test.ts";

                    export
                    *
                    from
                    "./tables/getRelationships.test.ts";

                    export
                    *
                    from
                    "./tables/getTable.test.ts";

                    export
                    *
                    from
                    "./tables/updateTable.test.ts";

                    export
                    *
                    from
                    "./tables/createRelationship.test.ts";
                - name: >-
                    rateLimit.test.ts
                  type: >-
                    file
                  contents: >
                    //
                    tests/vitest/unit/rateLimit.test.ts

                    import
                    {
                    describe,
                    it,
                    expect,
                    beforeEach
                    }
                    from
                    "vitest";

                    import
                    {
                      createClient,
                      mockFetch,
                      QB_APP_ID,
                      QB_REALM,
                      QB_USER_TOKEN,
                    }
                    from
                    "@tests/setup.ts";

                    import
                    {
                    RateLimitError
                    }
                    from
                    "@/RateLimitError";

                    import
                    {
                    GetApp200Response
                    }
                    from
                    "@/generated/models";


                    describe("QuickbaseClient
                    Unit
                    -
                    Rate
                    Limit
                    Handling",
                    ()
                    =>
                    {
                      let client: ReturnType<typeof createClient>;

                      beforeEach(() => {
                        mockFetch.mockClear();
                      });

                      it("succeeds after retrying on 429 Too Many Requests", async () => {
                        client = createClient(mockFetch, {
                          realm: QB_REALM,
                          userToken: QB_USER_TOKEN,
                          debug: true,
                          maxRetries: 2,
                          retryDelay: 100,
                          throttle: { rate: 10, burst: 10 },
                        });

                        const appId = QB_APP_ID;

                        const mockResponse: GetApp200Response = {
                          id: appId,
                          name: "TestApp",
                          created: "2025-01-01T00:00:00Z",
                          updated: "2025-01-02T00:00:00Z",
                          description: "Test app",
                          timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                          dateFormat: "MM-DD-YYYY",
                          hasEveryoneOnTheInternet: false,
                          memoryInfo: { estMemory: 0, estMemoryInclDependentApps: 0 },
                          securityProperties: {
                            allowClone: false,
                            allowExport: true,
                            enableAppTokens: true,
                            hideFromPublic: false,
                            mustBeRealmApproved: false,
                            useIPFilter: false,
                          },
                        };

                        mockFetch
                          .mockResolvedValueOnce({
                            ok: false,
                            status: 429,
                            headers: new Headers({ "Retry-After": "1" }),
                            json: () => Promise.resolve({ message: "Too Many Requests" }),
                          })
                          .mockResolvedValueOnce({
                            ok: true,
                            status: 200,
                            json: () => Promise.resolve(mockResponse),
                          });

                        const result = await client.getApp({ appId });

                        expect(result).toEqual({
                          ...mockResponse,
                          created: new Date("2025-01-01T00:00:00Z"),
                          updated: new Date("2025-01-02T00:00:00Z"),
                        });
                        expect(mockFetch).toHaveBeenCalledTimes(2);
                        expect(mockFetch).toHaveBeenNthCalledWith(
                          1,
                          `https://api.quickbase.com/v1/apps/${appId}`,
                          expect.objectContaining({
                            method: "GET",
                            headers: expect.objectContaining({
                              "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                              Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                              "Content-Type": "application/json",
                            }),
                            credentials: "omit",
                          })
                        );
                        expect(mockFetch).toHaveBeenNthCalledWith(
                          2,
                          `https://api.quickbase.com/v1/apps/${appId}`,
                          expect.objectContaining({
                            method: "GET",
                            headers: expect.objectContaining({
                              "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                              Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                              "Content-Type": "application/json",
                            }),
                            credentials: "omit",
                          })
                        );
                      });

                      it("throws RateLimitError after max retries on 429", async () => {
                        client = createClient(mockFetch, {
                          realm: QB_REALM,
                          userToken: QB_USER_TOKEN,
                          debug: true,
                          maxRetries: 1,
                          retryDelay: 100,
                          throttle: { rate: 10, burst: 10 },
                        });

                        const appId = QB_APP_ID;

                        mockFetch
                          .mockResolvedValueOnce({
                            ok: false,
                            status: 429,
                            headers: new Headers({ "Retry-After": "1" }),
                            json: () => Promise.resolve({ message: "Too Many Requests" }),
                          })
                          .mockResolvedValueOnce({
                            ok: false,
                            status: 429,
                            headers: new Headers({ "Retry-After": "1" }),
                            json: () => Promise.resolve({ message: "Too Many Requests" }),
                          });

                        await expect(client.getApp({ appId })).rejects.toMatchObject({
                          name: "RateLimitError",
                          message: "API Error: Too Many Requests (Status: 429)",
                          status: 429,
                          retryAfter: 1,
                        });

                        expect(mockFetch).toHaveBeenCalledTimes(2);
                      });

                      it("respects throttle limits without exceeding rate", async () => {
                        client = createClient(mockFetch, {
                          realm: QB_REALM,
                          userToken: QB_USER_TOKEN,
                          debug: true,
                          throttle: { rate: 5, burst: 5 },
                        });

                        const appId = QB_APP_ID;

                        const mockResponse: GetApp200Response = {
                          id: appId,
                          name: "TestApp",
                          created: "2025-01-01T00:00:00Z",
                          updated: "2025-01-02T00:00:00Z",
                          description: "Test app",
                          timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                          dateFormat: "MM-DD-YYYY",
                          hasEveryoneOnTheInternet: false,
                          memoryInfo: { estMemory: 0, estMemoryInclDependentApps: 0 },
                          securityProperties: {
                            allowClone: false,
                            allowExport: true,
                            enableAppTokens: true,
                            hideFromPublic: false,
                            mustBeRealmApproved: false,
                            useIPFilter: false,
                          },
                        };

                        mockFetch.mockResolvedValue({
                          ok: true,
                          status: 200,
                          json: () => Promise.resolve(mockResponse),
                        });

                        const startTime = Date.now();
                        await Promise.all([
                          client.getApp({ appId }),
                          client.getApp({ appId }),
                          client.getApp({ appId }),
                          client.getApp({ appId }),
                          client.getApp({ appId }),
                          client.getApp({ appId }), // 6th call triggers throttle
                        ]);
                        const endTime = Date.now();
                        const durationMs = endTime - startTime;

                        expect(mockFetch).toHaveBeenCalledTimes(6);
                        expect(durationMs).toBeGreaterThanOrEqual(200);
                        expect(durationMs).toBeLessThan(1000);
                      });
                    });
                - name: >-
                    records
                  type: >-
                    directory
                  children:
                    - name: >-
                        deleteRecords.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/records/deleteRecords.test.ts

                        import
                        {
                        describe,
                        expect,
                        test,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_REALM,
                          QB_USER_TOKEN,
                          QB_TABLE_ID_1,
                        }
                        from
                        "@tests/setup.ts";


                        describe("QuickbaseClient
                        Unit
                        -
                        deleteRecords",
                        ()
                        =>
                        {
                          let qb: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            qb = createClient(mockFetch, { debug: true }); // Use debug: true for consistency with other tests
                          });

                          test("sends correct DELETE request and handles success", async () => {
                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve({ numberDeleted: 1 }),
                            });

                            const result = await qb.deleteRecords({
                              body: {
                                from: QB_TABLE_ID_1,
                                where: "{3.EX.'5'}", // Simulate deleting Record ID 5
                              },
                            });

                            expect(mockFetch).toHaveBeenCalledWith(
                              "https://api.quickbase.com/v1/records",
                              expect.objectContaining({
                                method: "DELETE",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify({ from: QB_TABLE_ID_1, where: "{3.EX.'5'}" }),
                              })
                            );
                            expect(result).toEqual({ numberDeleted: 1 });
                          });

                          test("handles no records deleted", async () => {
                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve({ numberDeleted: 0 }),
                            });

                            const result = await qb.deleteRecords({
                              body: {
                                from: QB_TABLE_ID_1,
                                where: "{3.EX.'999999'}", // Non-existent Record ID
                              },
                            });

                            expect(mockFetch).toHaveBeenCalledWith(
                              "https://api.quickbase.com/v1/records",
                              expect.objectContaining({
                                method: "DELETE",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify({
                                  from: QB_TABLE_ID_1,
                                  where: "{3.EX.'999999'}",
                                }),
                              })
                            );
                            expect(result).toEqual({ numberDeleted: 0 });
                          });

                          test("throws error on API failure", async () => {
                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 400,
                              json: () => Promise.resolve({ message: "Invalid query" }),
                            });

                            await expect(() =>
                              qb.deleteRecords({
                                body: {
                                  from: QB_TABLE_ID_1,
                                  where: "{3.EX.'invalid'}",
                                },
                              })
                            ).rejects.toThrow("API Error: Invalid query (Status: 400)");

                            expect(mockFetch).toHaveBeenCalledWith(
                              "https://api.quickbase.com/v1/records",
                              expect.objectContaining({
                                method: "DELETE",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify({
                                  from: QB_TABLE_ID_1,
                                  where: "{3.EX.'invalid'}",
                                }),
                              })
                            );
                          });
                        });
                    - name: >-
                        runQuery.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/records/runQuery.test.ts

                        import
                        {
                        describe,
                        test,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_REALM,
                          QB_USER_TOKEN,
                          QB_TABLE_ID_1,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                        RunQueryRequest,
                        RunQueryResponse
                        }
                        from
                        "@/generated";


                        describe("QuickbaseClient
                        Unit
                        -
                        runQuery",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            client = createClient(mockFetch, { debug: true });
                          });

                          test("sends correct POST request and handles successful query response", async () => {
                            const queryRequest: RunQueryRequest = {
                              from: QB_TABLE_ID_1,
                              select: [3, 6, 7],
                              where: "{6.EX.'Task 1'}",
                              sortBy: [{ fieldId: 6, order: "ASC" }],
                              groupBy: [{ fieldId: 7, grouping: "equal-values" }],
                              options: { skip: 0, top: 100, compareWithAppLocalTime: false },
                            };

                            const mockResponse: RunQueryResponse = {
                              data: [
                                { "3": { value: 1 }, "6": { value: "Task 1" }, "7": { value: "High" } },
                              ],
                              fields: [
                                { id: 3, label: "Record ID#", type: "recordid" },
                                { id: 6, label: "Task Name", type: "text" },
                                { id: 7, label: "Priority", type: "text" },
                              ],
                              metadata: {
                                numFields: 3,
                                numRecords: 1,
                                skip: 0,
                                top: 100,
                                totalRecords: 1,
                              },
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.runQuery({ body: queryRequest });

                            expect(mockFetch).toHaveBeenCalledWith(
                              "https://api.quickbase.com/v1/records/query",
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(queryRequest),
                              })
                            );

                            expect(result).toEqual(mockResponse);
                          });

                          test("handles API error with invalid query", async () => {
                            const invalidQueryRequest: RunQueryRequest = {
                              from: QB_TABLE_ID_1,
                              select: [3],
                              where: "{999.EX.'Invalid'}",
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 400,
                              json: () => Promise.resolve({ message: "Invalid query" }),
                            });

                            await expect(
                              client.runQuery({ body: invalidQueryRequest })
                            ).rejects.toThrow("API Error: Invalid query (Status: 400)");

                            expect(mockFetch).toHaveBeenCalledWith(
                              "https://api.quickbase.com/v1/records/query",
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(invalidQueryRequest),
                              })
                            );
                          });
                        });
                    - name: >-
                        upsert.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/records/upsert.test.ts

                        import
                        {
                        describe,
                        expect,
                        test,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_REALM,
                          QB_USER_TOKEN,
                          QB_TABLE_ID_1,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                        vi
                        }
                        from
                        "vitest";


                        //
                        Note:
                        Type
                        augmentation
                        moved
                        to
                        src/types.d.ts

                        describe("QuickbaseClient
                        Unit
                        -
                        upsert",
                        ()
                        =>
                        {
                          beforeEach(() => {
                            vi.resetModules(); // Reset module cache
                            mockFetch.mockClear();
                          });

                          test("sends correct POST request and handles successful upsert", async () => {
                            const qb = createClient(mockFetch, { debug: true });

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () =>
                                Promise.resolve({
                                  data: [{ id: 1, "6": { value: "value1" } }],
                                  metadata: {
                                    createdRecordIds: [1],
                                    updatedRecordIds: [],
                                    unchangedRecordIds: [],
                                    totalNumberOfRecordsProcessed: 1,
                                  },
                                }),
                            });

                            console.log("[Test] Calling qb.upsert with:", {
                              body: { to: QB_TABLE_ID_1, data: [{ "6": { value: "value1" } }] },
                            });
                            const result = await qb.upsert({
                              body: { to: QB_TABLE_ID_1, data: [{ "6": { value: "value1" } }] },
                            });

                            console.log("[Test] mockFetch calls:", mockFetch.mock.calls);
                            expect(mockFetch).toHaveBeenCalledWith(
                              "https://api.quickbase.com/v1/records",
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: expect.any(String), // Allow any string, check content below
                                credentials: "omit",
                              })
                            );
                            const callArgs = mockFetch.mock.calls[0];
                            const receivedBody = JSON.parse(callArgs[1].body as string);
                            expect(receivedBody).toEqual({
                              to: QB_TABLE_ID_1,
                              data: [{ "6": { value: "value1" } }],
                            });

                            expect(result).toEqual({
                              data: [{ id: 1, "6": { value: "value1" } }],
                              metadata: {
                                createdRecordIds: [1],
                                updatedRecordIds: [],
                                unchangedRecordIds: [],
                                totalNumberOfRecordsProcessed: 1,
                              },
                            });
                          });

                          test("handles API error with invalid data", async () => {
                            const qb = createClient(mockFetch, { debug: true });

                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 400,
                              json: () => Promise.resolve({ message: "Invalid data format" }),
                            });

                            await expect(
                              qb.upsert({
                                body: { to: QB_TABLE_ID_1, data: [{ "999": { value: "invalid" } }] },
                              })
                            ).rejects.toThrow("API Error: Invalid data format (Status: 400)");

                            expect(mockFetch).toHaveBeenCalledWith(
                              "https://api.quickbase.com/v1/records",
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: expect.any(String),
                                credentials: "omit",
                              })
                            );
                            const callArgs = mockFetch.mock.calls[0];
                            const receivedBody = JSON.parse(callArgs[1].body as string);
                            expect(receivedBody).toEqual({
                              to: QB_TABLE_ID_1,
                              data: [{ "999": { value: "invalid" } }],
                            });
                          });

                          test("handles upsert with temp token", async () => {
                            const qb = createClient(mockFetch, { useTempTokens: true, debug: true });

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "temp-token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve({
                                    data: [{ id: 2, "7": { value: "value2" } }],
                                    metadata: {
                                      createdRecordIds: [2],
                                      updatedRecordIds: [],
                                      unchangedRecordIds: [],
                                      totalNumberOfRecordsProcessed: 1,
                                    },
                                  }),
                              });

                            const result = await qb.upsert({
                              body: { to: QB_TABLE_ID_1, data: [{ "7": { value: "value2" } }] },
                              dbid: QB_TABLE_ID_1, // Use QB_TABLE_ID_1 as dbid for temp token
                            } as any); // Temporary type assertion until types.d.ts is applied

                            expect(mockFetch).toHaveBeenCalledTimes(2);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_TABLE_ID_1}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "include",
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              "https://api.quickbase.com/v1/records",
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: "QB-TEMP-TOKEN temp-token",
                                  "Content-Type": "application/json",
                                }),
                                body: expect.any(String),
                                credentials: "omit",
                              })
                            );
                            const callArgs = mockFetch.mock.calls[1];
                            const receivedBody = JSON.parse(callArgs[1].body as string);
                            expect(receivedBody).toEqual({
                              to: QB_TABLE_ID_1,
                              data: [{ "7": { value: "value2" } }],
                            });

                            expect(result).toEqual({
                              data: [{ id: 2, "7": { value: "value2" } }],
                              metadata: {
                                createdRecordIds: [2],
                                updatedRecordIds: [],
                                unchangedRecordIds: [],
                                totalNumberOfRecordsProcessed: 1,
                              },
                            });
                          });

                          test("sends correct POST request with data fields", async () => {
                            const qb = createClient(mockFetch, { debug: true });

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () =>
                                Promise.resolve({
                                  data: [{ id: 1, "6": { value: "value1" } }],
                                  metadata: {
                                    createdRecordIds: [1],
                                    updatedRecordIds: [],
                                    unchangedRecordIds: [],
                                    totalNumberOfRecordsProcessed: 1,
                                  },
                                }),
                            });

                            const result = await qb.upsert({
                              body: { to: QB_TABLE_ID_1, data: [{ "6": { value: "value1" } }] },
                            });

                            expect(mockFetch).toHaveBeenCalledWith(
                              "https://api.quickbase.com/v1/records",
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: expect.any(String),
                                credentials: "omit",
                              })
                            );
                            const callArgs = mockFetch.mock.calls[0];
                            const receivedBody = JSON.parse(callArgs[1].body as string);
                            expect(receivedBody).toEqual({
                              to: QB_TABLE_ID_1,
                              data: [{ "6": { value: "value1" } }],
                            });

                            if (result.data && result.data.length > 0) {
                              expect((result.data[0]["6"] as { value: any }).value).toBe("value1");
                            } else {
                              throw new Error("Expected data array to have at least one element");
                            }
                          });
                        });
                - name: >-
                    tables
                  type: >-
                    directory
                  children:
                    - name: >-
                        createRelationship.test.ts
                      type: >-
                        file
                      contents: >
                        import
                        {
                        describe,
                        it,
                        expect,
                        vi,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_TABLE_ID_1,
                          QB_TABLE_ID_2,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                          CreateRelationship200Response,
                          CreateRelationshipRequest,
                        }
                        from
                        "/home/drew/Projects/quickbase-js/src/generated/models";


                        describe("QuickbaseClient
                        Unit
                        -
                        createRelationship",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            client = createClient(mockFetch, { debug: true });
                          });

                          it("initializes without errors", () => {
                            expect(client).toBeDefined();
                          });

                          it("has createRelationship method", () => {
                            expect(typeof client.createRelationship).toBe("function");
                          });

                          it("sends correct request and handles successful response", async () => {
                            const mockResponse: CreateRelationship200Response = {
                              id: 6,
                              foreignKeyField: {
                                id: 6,
                                label: "my relationship field",
                                type: "numeric",
                              },
                              lookupFields: [
                                { id: 7, label: "Field 1", type: "text" },
                                { id: 8, label: "Field 2", type: "text" },
                                { id: 9, label: "Field 3", type: "text" },
                              ],
                              isCrossApp: false,
                              parentTableId: QB_TABLE_ID_1,
                              childTableId: QB_TABLE_ID_2,
                              summaryFields: [
                                { id: 10, label: "my first summary field", type: "numeric" },
                                { id: 11, label: "my second summary field", type: "numeric" },
                              ],
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const requestBody: CreateRelationshipRequest = {
                              parentTableId: QB_TABLE_ID_1,
                              foreignKeyField: { label: "my relationship field" },
                              lookupFieldIds: [1, 2, 3],
                              summaryFields: [
                                {
                                  summaryFid: 3,
                                  label: "my first summary field",
                                  accumulationType: "AVG",
                                  where: "{'3'.EX.1}",
                                },
                                {
                                  summaryFid: 4,
                                  label: "my second summary field",
                                  accumulationType: "SUM",
                                },
                              ],
                            };

                            const tableId = QB_TABLE_ID_2;

                            const result = await client.createRelationship({
                              tableId,
                              body: requestBody,
                            });

                            expect(mockFetch).toHaveBeenCalledTimes(1);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_2}/relationship`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "Content-Type": "application/json",
                                  "QB-Realm-Hostname": "builderprogram-dbradford6815.quickbase.com",
                                  Authorization:
                                    "QB-USER-TOKEN b9f3pk_q4jd_0_b4qu5eebyvuix3xs57ysd7zn3",
                                }),
                                body: JSON.stringify(requestBody),
                              })
                            );
                            expect(result).toEqual(mockResponse);
                            expect(result.id).toBe(6);
                            expect(result.parentTableId).toBe(QB_TABLE_ID_1);
                            expect(result.childTableId).toBe(QB_TABLE_ID_2);
                            expect(result.foreignKeyField).toBeDefined();
                            if (result.foreignKeyField) {
                              expect(result.foreignKeyField.label).toBe("my relationship field");
                            }
                            expect(result.lookupFields).toHaveLength(3);
                            expect(result.summaryFields).toBeDefined();
                            if (result.summaryFields) {
                              expect(result.summaryFields).toHaveLength(2);
                              expect(result.summaryFields[0].label).toBe("my first summary field");
                              expect(result.summaryFields[1].label).toBe("my second summary field");
                            }
                          });

                          it("handles error from TablesApi", async () => {
                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 400,
                              json: () => Promise.resolve({ message: "Invalid request payload" }),
                            });

                            const requestBody: CreateRelationshipRequest = {
                              parentTableId: QB_TABLE_ID_1,
                              foreignKeyField: { label: "my relationship field" },
                              lookupFieldIds: [1, 2, 3],
                              summaryFields: [
                                { summaryFid: 3, label: "invalid", accumulationType: "INVALID" },
                              ],
                            };

                            const tableId = QB_TABLE_ID_2;

                            await expect(
                              client.createRelationship({
                                tableId,
                                body: requestBody,
                              })
                            ).rejects.toThrow("API Error: Invalid request payload (Status: 400)");

                            expect(mockFetch).toHaveBeenCalledTimes(1);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_2}/relationship`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "Content-Type": "application/json",
                                  "QB-Realm-Hostname": "builderprogram-dbradford6815.quickbase.com",
                                  Authorization:
                                    "QB-USER-TOKEN b9f3pk_q4jd_0_b4qu5eebyvuix3xs57ysd7zn3",
                                }),
                                body: JSON.stringify(requestBody),
                              })
                            );
                          });

                          it("handles response with undefined foreignKeyField and summaryFields", async () => {
                            const mockResponse: CreateRelationship200Response = {
                              id: 6,
                              foreignKeyField: undefined,
                              lookupFields: [
                                { id: 7, label: "Field 1", type: "text" },
                                { id: 8, label: "Field 2", type: "text" },
                                { id: 9, label: "Field 3", type: "text" },
                              ],
                              isCrossApp: false,
                              parentTableId: QB_TABLE_ID_1,
                              childTableId: QB_TABLE_ID_2,
                              summaryFields: undefined,
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const requestBody: CreateRelationshipRequest = {
                              parentTableId: QB_TABLE_ID_1,
                              foreignKeyField: undefined,
                              lookupFieldIds: [1, 2, 3],
                              summaryFields: undefined,
                            };

                            const tableId = QB_TABLE_ID_2;

                            const result = await client.createRelationship({
                              tableId,
                              body: requestBody,
                            });

                            expect(mockFetch).toHaveBeenCalledTimes(1);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_2}/relationship`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "Content-Type": "application/json",
                                  "QB-Realm-Hostname": "builderprogram-dbradford6815.quickbase.com",
                                  Authorization:
                                    "QB-USER-TOKEN b9f3pk_q4jd_0_b4qu5eebyvuix3xs57ysd7zn3",
                                }),
                                body: JSON.stringify(requestBody),
                              })
                            );
                            expect(result).toEqual(mockResponse);
                            expect(result.id).toBe(6);
                            expect(result.parentTableId).toBe(QB_TABLE_ID_1);
                            expect(result.childTableId).toBe(QB_TABLE_ID_2);
                            expect(result.foreignKeyField).toBeUndefined();
                            expect(result.lookupFields).toHaveLength(3);
                            expect(result.summaryFields).toBeUndefined();
                          });
                        });
                    - name: >-
                        createTable.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/records/createTable.test.ts

                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_APP_ID,
                          QB_REALM,
                          QB_USER_TOKEN,
                        }
                        from
                        "@tests/setup.ts";


                        describe("QuickbaseClient
                        Unit
                        -
                        createTable",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            client = createClient(mockFetch, { debug: true });
                          });

                          it("calls createTable successfully with user token", async () => {
                            const mockBody = {
                              name: "TestTable",
                              description: "Unit test table",
                              singleRecordName: "Test",
                              pluralRecordName: "Tests",
                            };
                            const mockResponse = {
                              id: "newly-created-table-id-1234567890", // Changed from "buya8h9iz"
                              name: "TestTable",
                              alias: "_DBID_TESTTABLE",
                              description: "Unit test table",
                              created: new Date("2025-03-10T21:00:00.000Z"),
                              updated: new Date("2025-03-10T21:00:00.000Z"),
                              nextRecordId: 1,
                              nextFieldId: 6,
                              defaultSortFieldId: 2,
                              defaultSortOrder: "DESC",
                              keyFieldId: 3,
                              singleRecordName: "Test",
                              pluralRecordName: "Tests",
                              sizeLimit: "500 MB",
                              spaceUsed: "0 KB",
                              spaceRemaining: "500 MB",
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const response = await client.createTable({
                              appId: QB_APP_ID,
                              body: mockBody,
                            });
                            expect(response).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(1);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables?appId=${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "Content-Type": "application/json",
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                }),
                                body: JSON.stringify(mockBody),
                              })
                            );
                          });
                        });
                    - name: >-
                        deleteRelationship.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/tables/deleteRelationship.test.ts


                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_TABLE_ID_2, // Child table
                        }
                        from
                        "@tests/setup.ts";


                        describe("QuickbaseClient
                        Unit
                        -
                        deleteRelationship",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            client = createClient(mockFetch, { debug: true });
                          });

                          it("initializes without errors", () => {
                            expect(client).toBeDefined();
                          });

                          it("has deleteRelationship method", () => {
                            expect(typeof client.deleteRelationship).toBe("function");
                          });

                          it("sends correct DELETE request and handles successful response", async () => {
                            // Mock response for a successful deletion
                            const mockResponse = {
                              deletedRelationshipId: 6, // Matches the relationshipId
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const tableId = QB_TABLE_ID_2; // Child table
                            const relationshipId = 6; // Example relationship ID (foreign key field ID)

                            const result = await client.deleteRelationship({
                              tableId,
                              relationshipId,
                            });

                            // Verify the fetch call
                            expect(mockFetch).toHaveBeenCalledTimes(1);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_2}/relationship/6`,
                              expect.objectContaining({
                                method: "DELETE",
                                headers: expect.objectContaining({
                                  "Content-Type": "application/json",
                                  "QB-Realm-Hostname": "builderprogram-dbradford6815.quickbase.com",
                                  Authorization:
                                    "QB-USER-TOKEN b9f3pk_q4jd_0_b4qu5eebyvuix3xs57ysd7zn3",
                                }),
                              })
                            );

                            // Verify the response
                            expect(result).toEqual(mockResponse);
                            expect(result.deletedRelationshipId).toBe(6);
                          });

                          it("handles error when relationship is not found", async () => {
                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 404,
                              json: () => Promise.resolve({ message: "Relationship not found" }),
                            });

                            const tableId = QB_TABLE_ID_2;
                            const relationshipId = 999; // Non-existent relationship ID

                            await expect(
                              client.deleteRelationship({
                                tableId,
                                relationshipId,
                              })
                            ).rejects.toThrow("API Error: Relationship not found (Status: 404)");

                            expect(mockFetch).toHaveBeenCalledTimes(1);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_2}/relationship/999`,
                              expect.objectContaining({
                                method: "DELETE",
                                headers: expect.objectContaining({
                                  "Content-Type": "application/json",
                                  "QB-Realm-Hostname": "builderprogram-dbradford6815.quickbase.com",
                                  Authorization:
                                    "QB-USER-TOKEN b9f3pk_q4jd_0_b4qu5eebyvuix3xs57ysd7zn3",
                                }),
                              })
                            );
                          });
                        });
                    - name: >-
                        deleteTable.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/records/deleteTable.test.ts

                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_APP_ID,
                          QB_TABLE_ID_1,
                          QB_REALM,
                          QB_USER_TOKEN,
                        }
                        from
                        "@tests/setup.ts";


                        describe("QuickbaseClient
                        Unit
                        -
                        deleteTable",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            client = createClient(mockFetch, { debug: true });
                          });

                          it("calls deleteTable successfully with user token", async () => {
                            const mockResponse = {
                              deletedTableId: QB_TABLE_ID_1,
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const response = await client.deleteTable({
                              tableId: QB_TABLE_ID_1,
                              appId: QB_APP_ID,
                            });
                            expect(response).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(1);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_1}?appId=${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "DELETE",
                                headers: expect.objectContaining({
                                  "Content-Type": "application/json",
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                }),
                              })
                            );
                          });

                          it("handles 404 error for non-existent table", async () => {
                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 404,
                              json: () =>
                                Promise.resolve({
                                  message: "Invalid DBID",
                                  description: "Table not found in app.",
                                }),
                            });

                            await expect(
                              client.deleteTable({ tableId: QB_TABLE_ID_1, appId: QB_APP_ID })
                            ).rejects.toThrow("API Error: Invalid DBID (Status: 404)");
                            expect(mockFetch).toHaveBeenCalledTimes(1);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_1}?appId=${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "DELETE",
                                headers: expect.objectContaining({
                                  "Content-Type": "application/json",
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                }),
                              })
                            );
                          });
                        });
                    - name: >-
                        getAppTables.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/tables/getAppTables.test.ts

                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_APP_ID,
                          QB_REALM,
                          QB_USER_TOKEN,
                        }
                        from
                        "@tests/setup.ts";


                        describe("QuickbaseClient
                        Unit
                        -
                        getAppTables",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            client = createClient(mockFetch, { debug: true }); // Add debug: true for consistency
                          });

                          it("calls getAppTables successfully", async () => {
                            mockFetch.mockImplementation((url: string, options: any) => {
                              console.log("Mock fetch for getAppTables:", url, options);
                              return Promise.resolve({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve([
                                    {
                                      id: "buwai2zr4",
                                      name: "Root",
                                      alias: "_DBID_ROOT",
                                      description: "",
                                      created: new Date("2025-02-13T18:22:33.000Z"),
                                      updated: new Date("2025-02-13T18:22:34.000Z"),
                                      nextRecordId: 1,
                                      nextFieldId: 6,
                                      defaultSortFieldId: 2,
                                      defaultSortOrder: "DESC",
                                      keyFieldId: 3,
                                      singleRecordName: "Root",
                                      pluralRecordName: "Roots",
                                      sizeLimit: "500 MB",
                                      spaceUsed: "0 KB",
                                      spaceRemaining: "500 MB",
                                    },
                                  ]),
                              } as Response);
                            });

                            const result = await client.getAppTables({ appId: QB_APP_ID });
                            console.log("getAppTables response:", result);
                            expect(result).toEqual(
                              expect.arrayContaining([
                                expect.objectContaining({
                                  id: "buwai2zr4",
                                  name: "Root",
                                  alias: "_DBID_ROOT",
                                  description: "",
                                  created: new Date("2025-02-13T18:22:33.000Z"),
                                  updated: new Date("2025-02-13T18:22:34.000Z"),
                                  nextRecordId: 1,
                                  nextFieldId: 6,
                                  defaultSortFieldId: 2,
                                  defaultSortOrder: "DESC",
                                  keyFieldId: 3,
                                  singleRecordName: "Root",
                                  pluralRecordName: "Roots",
                                  sizeLimit: "500 MB",
                                  spaceUsed: "0 KB",
                                  spaceRemaining: "500 MB",
                                }),
                              ])
                            );
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables?appId=${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                              })
                            );
                          });
                        });
                    - name: >-
                        getRelationships.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/relationships/getRelationships.test.ts

                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_REALM,
                          QB_USER_TOKEN,
                          QB_TABLE_ID_1,
                          QB_TABLE_ID_2,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                        GetRelationships200Response
                        }
                        from
                        "/home/drew/Projects/quickbase-js/src/generated/models";


                        describe("QuickbaseClient
                        Unit
                        -
                        getRelationships",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            client = createClient(mockFetch, { debug: true }); // Consistent with output
                          });

                          it("initializes without errors", () => {
                            expect(client).toBeDefined();
                          });

                          it("has getRelationships method", () => {
                            expect(typeof client.getRelationships).toBe("function");
                          });

                          it("sends correct GET request and handles successful response", async () => {
                            const mockResponse: GetRelationships200Response = {
                              metadata: {
                                numRelationships: 1,
                                skip: 0,
                                totalRelationships: 1,
                              },
                              relationships: [
                                {
                                  id: 6,
                                  parentTableId: QB_TABLE_ID_1, // Parent table
                                  childTableId: QB_TABLE_ID_2, // Child table
                                  foreignKeyField: {
                                    id: 6,
                                    label: "Related record",
                                    type: "numeric",
                                  },
                                  isCrossApp: false,
                                  lookupFields: [
                                    {
                                      id: 3,
                                      label: "Name",
                                      type: "text",
                                    },
                                  ],
                                  summaryFields: [
                                    {
                                      id: 8,
                                      label: "my summary field",
                                      type: "numeric",
                                    },
                                  ],
                                },
                              ],
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.getRelationships({
                              tableId: QB_TABLE_ID_2,
                              skip: 0,
                            });

                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_2}/relationships?skip=0`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                              })
                            );

                            expect(result).toEqual(mockResponse);
                            expect(result.metadata.numRelationships).toBe(1);
                            expect(result.relationships).toHaveLength(1);
                            expect(result.relationships[0].id).toBe(6);
                            expect(result.relationships[0].foreignKeyField.label).toBe(
                              "Related record"
                            );
                          });

                          it("handles request without skip parameter", async () => {
                            const mockResponse: GetRelationships200Response = {
                              metadata: {
                                numRelationships: 1,
                                skip: 0,
                                totalRelationships: 1,
                              },
                              relationships: [
                                {
                                  id: 6,
                                  parentTableId: QB_TABLE_ID_1,
                                  childTableId: QB_TABLE_ID_2,
                                  foreignKeyField: {
                                    id: 6,
                                    label: "Related record",
                                    type: "numeric",
                                  },
                                  isCrossApp: false,
                                  lookupFields: [],
                                  summaryFields: [],
                                },
                              ],
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.getRelationships({
                              tableId: QB_TABLE_ID_2, // Corrected from QB_TABLE_ID_1
                            });

                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_2}/relationships`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                              })
                            );

                            expect(result).toEqual(mockResponse);
                          });

                          it("handles API error response", async () => {
                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 404,
                              json: () => Promise.resolve({ message: "Table not found" }),
                            });

                            await expect(
                              client.getRelationships({
                                tableId: QB_TABLE_ID_2, // Corrected from QB_TABLE_ID_1
                                skip: 0,
                              })
                            ).rejects.toThrow("API Error: Table not found (Status: 404)");

                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_2}/relationships?skip=0`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                              })
                            );
                          });

                          it("retries with temp token after 401", async () => {
                            const mockResponse: GetRelationships200Response = {
                              metadata: {
                                numRelationships: 1,
                                skip: 0,
                                totalRelationships: 1,
                              },
                              relationships: [
                                {
                                  id: 6,
                                  parentTableId: QB_TABLE_ID_1,
                                  childTableId: QB_TABLE_ID_2,
                                  foreignKeyField: {
                                    id: 6,
                                    label: "Related record",
                                    type: "numeric",
                                  },
                                  isCrossApp: false,
                                },
                              ],
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve({ temporaryAuthorization: "initial_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: false,
                                status: 401,
                                json: () => Promise.resolve({ message: "Unauthorized" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "new_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const tempClient = createClient(mockFetch, {
                              useTempTokens: true,
                              debug: true,
                            });
                            const result = await tempClient.getRelationships({
                              tableId: QB_TABLE_ID_2,
                              skip: 0,
                            });

                            expect(mockFetch).toHaveBeenCalledTimes(4);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_TABLE_ID_2}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_2}/relationships?skip=0`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN initial_token",
                                }),
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              3,
                              `https://api.quickbase.com/v1/auth/temporary/${QB_TABLE_ID_2}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              4,
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_2}/relationships?skip=0`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN new_token",
                                }),
                              })
                            );

                            expect(result).toEqual(mockResponse);
                          });
                        });
                    - name: >-
                        getTable.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/tables/getTable.test.ts

                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_APP_ID,
                          QB_TABLE_ID_1,
                          QB_REALM,
                          QB_USER_TOKEN,
                        }
                        from
                        "@tests/setup.ts";


                        describe("QuickbaseClient
                        Unit
                        -
                        getTable",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                          });

                          it("calls getTable successfully with user token", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const mockResponse = {
                              id: QB_TABLE_ID_1,
                              name: "Root",
                              alias: "_DBID_ROOT",
                              description: "",
                              created: new Date("2025-02-13T18:22:33.000Z"),
                              updated: new Date("2025-02-13T18:22:34.000Z"),
                              nextRecordId: 1,
                              nextFieldId: 6,
                              defaultSortFieldId: 2,
                              defaultSortOrder: "DESC",
                              keyFieldId: 3,
                              singleRecordName: "Root",
                              pluralRecordName: "Roots",
                              sizeLimit: "500 MB",
                              spaceUsed: "0 KB",
                              spaceRemaining: "500 MB",
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const response = await client.getTable({
                              tableId: QB_TABLE_ID_1,
                              appId: QB_APP_ID,
                            });
                            expect(response).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_1}?appId=${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                }),
                              })
                            );
                          });

                          it("calls getTable successfully with temp token", async () => {
                            client = createClient(mockFetch, { debug: true, useTempTokens: true });

                            const mockResponse = {
                              id: QB_TABLE_ID_1,
                              name: "Root",
                              alias: "_DBID_ROOT",
                              description: "",
                              created: new Date("2025-02-13T18:22:33.000Z"),
                              updated: new Date("2025-02-13T18:22:34.000Z"),
                              nextRecordId: 1,
                              nextFieldId: 6,
                              defaultSortFieldId: 2,
                              defaultSortOrder: "DESC",
                              keyFieldId: 3,
                              singleRecordName: "Root",
                              pluralRecordName: "Roots",
                              sizeLimit: "500 MB",
                              spaceUsed: "0 KB",
                              spaceRemaining: "500 MB",
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "temp_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const response = await client.getTable({
                              tableId: QB_TABLE_ID_1,
                              appId: QB_APP_ID,
                            });
                            expect(response).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(2);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/auth/temporary/${QB_TABLE_ID_1}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_1}?appId=${QB_APP_ID}`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: "QB-TEMP-TOKEN temp_token",
                                }),
                              })
                            );
                          });

                          it("retries successfully after 401 with temp token", async () => {
                            client = createClient(mockFetch, { debug: true, useTempTokens: true });

                            const mockResponse = {
                              id: QB_TABLE_ID_1,
                              name: "Root",
                              alias: "_DBID_ROOT",
                              description: "",
                              created: new Date("2025-02-13T18:22:33.000Z"),
                              updated: new Date("2025-02-13T18:22:34.000Z"),
                              nextRecordId: 1,
                              nextFieldId: 6,
                              defaultSortFieldId: 2,
                              defaultSortOrder: "DESC",
                              keyFieldId: 3,
                              singleRecordName: "Root",
                              pluralRecordName: "Roots",
                              sizeLimit: "500 MB",
                              spaceUsed: "0 KB",
                              spaceRemaining: "500 MB",
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve({ temporaryAuthorization: "initial_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: false,
                                status: 401,
                                json: () => Promise.resolve({ message: "Unauthorized" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "new_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const response = await client.getTable({
                              tableId: QB_TABLE_ID_1,
                              appId: QB_APP_ID,
                            });
                            expect(response).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(4);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_1}?appId=${QB_APP_ID}`,
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN new_token",
                                }),
                              })
                            );
                          });

                          it("handles 401 with failed temp token retry", async () => {
                            client = createClient(mockFetch, { debug: true, useTempTokens: true });

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve({ temporaryAuthorization: "initial_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: false,
                                status: 401,
                                json: () => Promise.resolve({ message: "Unauthorized" }),
                              })
                              .mockResolvedValueOnce({
                                ok: false,
                                status: 401,
                                json: () =>
                                  Promise.resolve({ message: "Unauthorized in fetchTempToken" }),
                              });

                            await expect(
                              client.getTable({ tableId: QB_TABLE_ID_1, appId: QB_APP_ID })
                            ).rejects.toThrow(
                              "API Error: Unauthorized in fetchTempToken (Status: 401)"
                            );
                            expect(mockFetch).toHaveBeenCalledTimes(3);
                          });

                          it("handles 404 Not Found", async () => {
                            client = createClient(mockFetch, { debug: true });

                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 404,
                              json: () => Promise.resolve({ message: "Table not found" }),
                            });

                            await expect(
                              client.getTable({ tableId: QB_TABLE_ID_1, appId: QB_APP_ID })
                            ).rejects.toThrow("API Error: Table not found (Status: 404)");
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_1}?appId=${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                }),
                              })
                            );
                          });
                        });
                    - name: >-
                        updateRelationship.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/tables/updateRelationship.test.ts


                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach,
                        vi
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_REALM,
                          QB_USER_TOKEN,
                          QB_TABLE_ID_1,
                        }
                        from
                        "@tests/setup.ts";

                        import
                        {
                          UpdateRelationshipRequest,
                          UpdateRelationship200Response,
                        }
                        from
                        "@/generated/models";


                        describe("QuickbaseClient
                        Unit
                        -
                        updateRelationship",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                          });

                          it("initializes without errors and has updateRelationship method", () => {
                            client = createClient(mockFetch, { debug: true });
                            expect(client).toBeDefined();
                            expect(typeof client.updateRelationship).toBe("function");
                          });

                          it("updates relationship successfully with user token", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const tableId = QB_TABLE_ID_1;
                            const relationshipId = 6;

                            const request: UpdateRelationshipRequest = {
                              lookupFieldIds: [4, 5, 6],
                              summaryFields: [
                                {
                                  summaryFid: 3,
                                  label: "my summary field",
                                  accumulationType: "COUNT",
                                  where: "{'3'.EX.'1'}",
                                },
                              ],
                            };

                            const mockResponse: UpdateRelationship200Response = {
                              id: relationshipId,
                              parentTableId: "bck7gp3q2",
                              childTableId: tableId,
                              foreignKeyField: {
                                id: relationshipId,
                                label: "Related record",
                                type: "numeric",
                              },
                              isCrossApp: false,
                              lookupFields: [
                                { id: 4, label: "Field 4", type: "text" },
                                { id: 5, label: "Field 5", type: "numeric" },
                                { id: 6, label: "Field 6", type: "date" },
                              ],
                              summaryFields: [{ id: 8, label: "my summary field", type: "numeric" }],
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: true,
                              status: 200,
                              json: () => Promise.resolve(mockResponse),
                            });

                            const result = await client.updateRelationship({
                              tableId,
                              relationshipId,
                              body: request,
                            });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${tableId}/relationship/${relationshipId}`, // Changed to singular
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                                credentials: "omit",
                              })
                            );
                          });

                          it("updates relationship successfully with temp token", async () => {
                            client = createClient(mockFetch, { useTempTokens: true, debug: true });

                            const tableId = QB_TABLE_ID_1;
                            const relationshipId = 6;

                            const request: UpdateRelationshipRequest = {
                              lookupFieldIds: [7],
                              summaryFields: [
                                {
                                  summaryFid: 0,
                                  label: "Count of Records",
                                  accumulationType: "COUNT",
                                  where: "{'3'.GT.0}",
                                },
                              ],
                            };

                            const mockResponse: UpdateRelationship200Response = {
                              id: relationshipId,
                              parentTableId: "bck7gp3q2",
                              childTableId: tableId,
                              foreignKeyField: {
                                id: relationshipId,
                                label: "Related record",
                                type: "numeric",
                              },
                              isCrossApp: false,
                              lookupFields: [{ id: 7, label: "record - text field", type: "text" }],
                              summaryFields: [{ id: 9, label: "Count of Records", type: "numeric" }],
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "temp_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const result = await client.updateRelationship({
                              tableId,
                              relationshipId,
                              body: request,
                            });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(2);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${tableId}`,
                              expect.objectContaining({
                                method: "GET",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  "Content-Type": "application/json",
                                }),
                                credentials: "include",
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/tables/${tableId}/relationship/${relationshipId}`, // Changed to singular
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: "QB-TEMP-TOKEN temp_token",
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                                credentials: "omit",
                              })
                            );
                          });

                          it("retries successfully after 401 with temp token", async () => {
                            client = createClient(mockFetch, { useTempTokens: true, debug: true });

                            const tableId = QB_TABLE_ID_1;
                            const relationshipId = 6;

                            const request: UpdateRelationshipRequest = {
                              lookupFieldIds: [4],
                            };

                            const mockResponse: UpdateRelationship200Response = {
                              id: relationshipId,
                              parentTableId: "bck7gp3q2",
                              childTableId: tableId,
                              foreignKeyField: {
                                id: relationshipId,
                                label: "Related record",
                                type: "numeric",
                              },
                              isCrossApp: false,
                              lookupFields: [{ id: 4, label: "Field 4", type: "text" }],
                              summaryFields: [],
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () =>
                                  Promise.resolve({ temporaryAuthorization: "initial_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: false,
                                status: 401,
                                json: () => Promise.resolve({ message: "Unauthorized" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "new_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const consoleSpy = vi.spyOn(console, "log");
                            const result = await client.updateRelationship({
                              tableId,
                              relationshipId,
                              body: request,
                            });

                            expect(result).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(4);
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              1,
                              `https://api.quickbase.com/v1/auth/temporary/${tableId}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              2,
                              `https://api.quickbase.com/v1/tables/${tableId}/relationship/${relationshipId}`, // Changed to singular
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN initial_token",
                                }),
                              })
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              3,
                              `https://api.quickbase.com/v1/auth/temporary/${tableId}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenNthCalledWith(
                              4,
                              `https://api.quickbase.com/v1/tables/${tableId}/relationship/${relationshipId}`, // Changed to singular
                              expect.objectContaining({
                                headers: expect.objectContaining({
                                  Authorization: "QB-TEMP-TOKEN new_token",
                                }),
                              })
                            );
                            expect(consoleSpy).toHaveBeenCalledWith(
                              "Authorization error for updateRelationship (temp token), refreshing token:",
                              expect.any(String)
                            );
                            expect(consoleSpy).toHaveBeenCalledWith(
                              "Retrying updateRelationship with temp token"
                            );
                            consoleSpy.mockRestore();
                          });

                          it("handles 400 error for invalid request", async () => {
                            client = createClient(mockFetch, { debug: true });

                            const tableId = QB_TABLE_ID_1;
                            const relationshipId = 6;

                            const request: UpdateRelationshipRequest = {
                              lookupFieldIds: [-1],
                            };

                            mockFetch.mockResolvedValueOnce({
                              ok: false,
                              status: 400,
                              json: () => Promise.resolve({ message: "Invalid field ID" }),
                            });

                            await expect(
                              client.updateRelationship({
                                tableId,
                                relationshipId,
                                body: request,
                              })
                            ).rejects.toThrow("API Error: Invalid field ID (Status: 400)");

                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${tableId}/relationship/${relationshipId}`, // Changed to singular
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${QB_REALM}.quickbase.com`,
                                  Authorization: `QB-USER-TOKEN ${QB_USER_TOKEN}`,
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(request),
                                credentials: "omit",
                              })
                            );
                          });
                        });
                    - name: >-
                        updateTable.test.ts
                      type: >-
                        file
                      contents: >
                        //
                        tests/vitest/unit/records/updateTable.test.ts

                        import
                        {
                        describe,
                        it,
                        expect,
                        beforeEach
                        }
                        from
                        "vitest";

                        import
                        {
                          createClient,
                          mockFetch,
                          QB_APP_ID,
                          QB_TABLE_ID_1,
                        }
                        from
                        "@tests/setup.ts";


                        describe("QuickbaseClient
                        Unit
                        -
                        updateTable",
                        ()
                        =>
                        {
                          let client: ReturnType<typeof createClient>;

                          beforeEach(() => {
                            mockFetch.mockClear();
                            client = createClient(mockFetch, { debug: true });
                          });

                          it("calls updateTable successfully with temp token", async () => {
                            client = createClient(mockFetch, { debug: true, useTempTokens: true });

                            const mockBody = {
                              name: "Updated Root",
                              description: "Updated description",
                            };
                            const mockResponse = {
                              id: QB_TABLE_ID_1,
                              name: "Updated Root",
                              alias: "_DBID_ROOT",
                              description: "Updated description",
                              created: new Date("2025-02-13T18:22:33.000Z"),
                              updated: new Date("2025-03-10T12:00:00.000Z"),
                              nextRecordId: 1,
                              nextFieldId: 6,
                              defaultSortFieldId: 2,
                              defaultSortOrder: "DESC",
                              keyFieldId: 3,
                              singleRecordName: "Root",
                              pluralRecordName: "Roots",
                              sizeLimit: "500 MB",
                              spaceUsed: "0 KB",
                              spaceRemaining: "500 MB",
                            };

                            mockFetch
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve({ temporaryAuthorization: "temp_token" }),
                              })
                              .mockResolvedValueOnce({
                                ok: true,
                                status: 200,
                                json: () => Promise.resolve(mockResponse),
                              });

                            const response = await client.updateTable({
                              tableId: QB_TABLE_ID_1,
                              appId: QB_APP_ID,
                              body: mockBody,
                            });
                            expect(response).toEqual(mockResponse);
                            expect(mockFetch).toHaveBeenCalledTimes(2);
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/auth/temporary/${QB_TABLE_ID_1}`,
                              expect.any(Object)
                            );
                            expect(mockFetch).toHaveBeenCalledWith(
                              `https://api.quickbase.com/v1/tables/${QB_TABLE_ID_1}?appId=${QB_APP_ID}`,
                              expect.objectContaining({
                                method: "POST",
                                headers: expect.objectContaining({
                                  "QB-Realm-Hostname": `${process.env.QB_REALM}.quickbase.com`,
                                  Authorization: "QB-TEMP-TOKEN temp_token",
                                  "Content-Type": "application/json",
                                }),
                                body: JSON.stringify(mockBody),
                              })
                            );
                          });
                        });
                - name: >-
                    tokenLifespan.test.ts
                  type: >-
                    file
                  contents: >
                    import
                    {
                    describe,
                    it,
                    expect,
                    beforeEach,
                    vi
                    }
                    from
                    "vitest";

                    import
                    {
                    createClient,
                    mockFetch,
                    QB_APP_ID,
                    QB_REALM
                    }
                    from
                    "@tests/setup.ts";

                    import
                    {
                    UpdateAppRequest,
                    UpdateApp200Response
                    }
                    from
                    "@/generated/models";


                    describe("QuickbaseClient
                    Unit
                    -
                    Token
                    Lifespan",
                    ()
                    =>
                    {
                      let client: ReturnType<typeof createClient>;

                      beforeEach(() => {
                        mockFetch.mockClear();
                      });

                      it("reuses token within lifespan and fetches new token after expiration", async () => {
                        // Set a short lifespan of 500ms for testing
                        client = createClient(mockFetch, {
                          realm: QB_REALM,
                          useTempTokens: true,
                          tokenLifespan: 500, // 0.5 seconds
                          debug: true,
                        });

                        const request: UpdateAppRequest = {
                          name: "Test App",
                        };
                        const mockResponse: UpdateApp200Response = {
                          id: QB_APP_ID,
                          name: "Test App",
                          description: "",
                          created: new Date("2020-01-01T00:00:00Z"),
                          updated: new Date("2020-01-01T00:00:00Z"),
                          dateFormat: "MM-DD-YYYY",
                          timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                          hasEveryoneOnTheInternet: false,
                          ancestorId: null,
                          variables: [],
                          securityProperties: {},
                          memoryInfo: { estMemory: 0, estMemoryInclDependentApps: 0 },
                          dataClassification: "None",
                        };

                        // First call: Fetch a new token
                        mockFetch
                          .mockResolvedValueOnce({
                            ok: true,
                            status: 200,
                            json: () => Promise.resolve({ temporaryAuthorization: "token1" }),
                          })
                          .mockResolvedValueOnce({
                            ok: true,
                            status: 200,
                            json: () => Promise.resolve(mockResponse),
                          });

                        await client.updateApp({ appId: QB_APP_ID, body: request });
                        expect(mockFetch).toHaveBeenCalledTimes(2); // Token fetch + API call

                        // Second call within lifespan: Should reuse token1
                        mockFetch.mockResolvedValueOnce({
                          ok: true,
                          status: 200,
                          json: () => Promise.resolve(mockResponse),
                        });
                        await client.updateApp({ appId: QB_APP_ID, body: request });
                        expect(mockFetch).toHaveBeenCalledTimes(3); // Only API call, no new token fetch

                        // Wait for token to expire (500ms + buffer)
                        await new Promise((resolve) => setTimeout(resolve, 600));

                        // Third call after expiration: Should fetch a new token
                        mockFetch
                          .mockResolvedValueOnce({
                            ok: true,
                            status: 200,
                            json: () => Promise.resolve({ temporaryAuthorization: "token2" }),
                          })
                          .mockResolvedValueOnce({
                            ok: true,
                            status: 200,
                            json: () => Promise.resolve(mockResponse),
                          });
                        await client.updateApp({ appId: QB_APP_ID, body: request });
                        expect(mockFetch).toHaveBeenCalledTimes(5); // New token fetch + API call
                      });

                      it("uses default lifespan when not specified", async () => {
                        // No tokenLifespan provided, should use default (4:50 = 290,000ms)
                        client = createClient(mockFetch, {
                          realm: QB_REALM,
                          useTempTokens: true,
                          debug: true,
                        });

                        const request: UpdateAppRequest = {
                          name: "Default Lifespan Test",
                        };
                        const mockResponse: UpdateApp200Response = {
                          id: QB_APP_ID,
                          name: "Default Lifespan Test",
                          description: "",
                          created: new Date("2020-01-01T00:00:00Z"),
                          updated: new Date("2020-01-01T00:00:00Z"),
                          dateFormat: "MM-DD-YYYY",
                          timeZone: "(UTC-08:00) Pacific Time (US & Canada)",
                          hasEveryoneOnTheInternet: false,
                          ancestorId: null,
                          variables: [],
                          securityProperties: {},
                          memoryInfo: { estMemory: 0, estMemoryInclDependentApps: 0 },
                          dataClassification: "None",
                        };

                        // First call: Fetch a new token
                        mockFetch
                          .mockResolvedValueOnce({
                            ok: true,
                            status: 200,
                            json: () =>
                              Promise.resolve({ temporaryAuthorization: "default_token" }),
                          })
                          .mockResolvedValueOnce({
                            ok: true,
                            status: 200,
                            json: () => Promise.resolve(mockResponse),
                          });

                        await client.updateApp({ appId: QB_APP_ID, body: request });
                        expect(mockFetch).toHaveBeenCalledTimes(2); // Token fetch + API call

                        // Second call within default lifespan (e.g., after 1 second, well below 4:50)
                        mockFetch.mockResolvedValueOnce({
                          ok: true,
                          status: 200,
                          json: () => Promise.resolve(mockResponse),
                        });
                        await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait 1 second
                        await client.updateApp({ appId: QB_APP_ID, body: request });
                        expect(mockFetch).toHaveBeenCalledTimes(3); // No new token fetch, still within 4:50
                      });
                    });
                - name: >-
                    umd.test.ts
                  type: >-
                    file
                  contents: >
                    //
                    tests/vitest/unit/umd.test.ts

                    import
                    {
                    test,
                    expect
                    }
                    from
                    "vitest";

                    const
                    quickbaseUMD
                    =
                    require("../../dist/umd/quickbase.umd.js");

                    const
                    {
                    quickbase:
                    quickbaseESM
                    }
                    =
                    await
                    import("../../dist/esm/quickbase.js");

                    test("UMD
                    and
                    ESM
                    builds
                    work
                    in
                    Node.js",
                    ()
                    =>
                    {
                      expect(quickbaseUMD).toBeDefined();
                      expect(quickbaseESM).toBeDefined();
                    });
    - name: >-
        text.txt
      type: >-
        file
    - name: >-
        tools
      type: >-
        directory
      children:
        - name: >-
            log-gen.ts
          type: >-
            file
        - name: >-
            log-gen.yaml
          type: >-
            file
        - name: >-
            openapi-jars
          type: >-
            directory
          children:
            - name: >-
                openapi-generator-cli-7.12.0.jar
              type: >-
                file
    - name: >-
        tsconfig.build.json
      type: >-
        file
    - name: >-
        tsconfig.json
      type: >-
        file
    - name: >-
        versionrc.json
      type: >-
        file
    - name: >-
        vitest.config.ts
      type: >-
        file
      contents: >
        import
        {
        defineConfig
        }
        from
        "vitest/config";

        import
        path
        from
        "path";

        import
        dotenv
        from
        "dotenv";


        //
        Load
        .env
        variables
        before
        tests
        run

        dotenv.config({
        path:
        path.resolve(__dirname,
        ".env")
        });


        export
        default
        defineConfig({
          test: {
            environment: "jsdom",
            include: ["tests/vitest/**/**/*.test.ts"],
            setupFiles: ["tests/setup.ts"], // Relative path from root
            pool: "forks",
            poolOptions: {
              forks: {
                singleFork: true, // Run tests sequentially
              },
            },
            testTimeout: 10000, // Global timeout of 10 seconds for all tests
          },
          resolve: {
            alias: {
              "@": path.resolve(__dirname, "./src"), // For src/ imports
              "@tests": path.resolve(__dirname, "./tests"), // For tests/ imports
            },
          },
        });

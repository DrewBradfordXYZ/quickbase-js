project: >-
  quickbase-js
date: >-
  4/4/2025
root: >-
  /home/drew/Projects/quickbase-js
goals:
  - >-
    A
    library
    for
    interacting
    with
    the
    QuickBase
    RESTful
    API.
  - >-
    Use
    OpenAPI
    to
    generate
    types
    and
    methods
    using
    a
    proxy.
    Validate
    with
    tests.
  - >-
    Provide
    robust
    and
    intuitive
    temporary
    token
    support
    for
    browser
    environments.
  - >-
    User
    Tokens
    support
    both
    Node.js
    and
    browser
    environments.
  - >-
    Use
    case:
    JS
    frameworks
    like
    React,
    Vue,
    and
    Angular
    hosted
    in
    QuickBase
    code
    pages.
  - >-
    Enable
    a
    flexible
    or
    native
    fetch
    in
    the
    browser.
  - >-
    Enable
    a
    flexible
    fetch
    framework
    in
    Node.js.
  - >-
    #
  - >-
    No
    manual
    updating
    methods
    when
    the
    QuickBase
    API
    changes.
  - >-
    The
    proxy
    magic
    dynamically
    maps
    generated
    methods
    and
    types.
  - >-
    #
  - >-
    TokenCache
    is
    defined
    per
    quickbaseClient
    call,
    so
    each
    instance
    has
    its
    own
    isolated
    TokenCache.
  - >-
    Each
    quickbase
    client
    instance
    has
    an
    isolated
    and
    individual
    token
    cache.
pipelineOverview:
  - >-
    What
    I’m
    Trying
    to
    Do
  - >-
    My
    approach
    is
    to
    ensure
    AppsApi.ts
    is
    generated
    with
    getAppById
    so
    QuickbaseClient.ts
    can
    map
    it
    to
    client.getApp.
    Steps
    include:
  - >-
    Fix
    fix-spec.ts:
  - >-
    Add
    tags:
    ["Apps"]
    to
    /apps/*
    endpoints
    to
    group
    them
    into
    AppsApi.ts.
  - >-
    Ensure
    all
    endpoints
    and
    models
    are
    correctly
    defined
    and
    typed.
  - >-
    Debug
    regenerate-client.ts:
  - >-
    Enhance
    logging
    to
    catch
    why
    AppsApi.ts
    isn’t
    generated.
  - >-
    Test
    if
    getAppById
    appears
    in
    another
    file
    (e.g.,
    DefaultApi.ts).
  - >-
    Update
    QuickbaseClient.ts:
  - >-
    Adjust
    imports
    to
    use
    the
    correct
    API
    class
    once
    generated.
  - >-
    Test
    and
    Iterate:
  - >-
    Run
    npm
    run
    fix-spec,
    npm
    run
    regenerate,
    and
    npm
    run
    test
    to
    verify
    AppsApi.ts
    exists
    and
    test.ts
    works.
  - >-
    The
    latest
    fix-spec.ts
    with
    tags
    aims
    to
    force
    the
    generator
    to
    create
    AppsApi.ts,
    addressing
    the
    missing
    file
    issue.
  - >-
    Relevant
    Project
    Files
  - >-
    Here’s
    a
    list
    of
    files
    that
    would
    help
    understand
    and
    resolve
    this
    problem,
    along
    with
    their
    roles:
  - >-
    src/code-generation/fix-spec.ts:
  - >-
    Role:
    Modifies
    the
    original
    QuickBase
    spec
    (e.g.,
    QuickBase_RESTful_*.json)
    to
    create
    quickbase-fixed.json
    with
    required
    endpoints
    (e.g.,
    /apps/{appId}).
  - >-
    Relevance:
    Defines
    the
    spec
    fed
    to
    the
    generator;
    errors
    here
    affect
    generation.
  - >-
    src/code-generation/quickbase-fixed.json:
  - >-
    Role:
    The
    processed
    OpenAPI
    spec
    used
    by
    regenerate-client.ts
    to
    generate
    code.
  - >-
    Relevance:
    Confirms
    if
    /apps/{appId}
    is
    correctly
    structured
    with
    operationId:
    "getAppById".
  - >-
    src/code-generation/regenerate-client.ts:
  - >-
    Role:
    Runs
    OpenAPI
    Generator
    to
    produce
    src/generated/
    files
    (APIs
    and
    models)
    and
    fixes
    .ts
    extensions
    with
    ts-morph.
  - >-
    Relevance:
    Controls
    the
    generation
    process;
    logs
    reveal
    why
    AppsApi.ts
    is
    missing.
  - >-
    src/generated/apis/AppsApi.ts
    (if
    exists):
  - >-
    Role:
    Should
    contain
    getAppById
    method
    for
    /apps/{appId}
    GET.
  - >-
    Relevance:
    Missing
    file
    is
    the
    core
    issue;
    its
    absence
    breaks
    QuickbaseClient.ts.
  - >-
    src/generated/apis/DefaultApi.ts:
  - >-
    Role:
    Default
    API
    class
    for
    untagged
    operations.
  - >-
    Relevance:
    Might
    contain
    getAppById
    if
    tags
    are
    misconfigured.
  - >-
    src/QuickbaseClient.ts:
  - >-
    Role:
    Wraps
    generated
    API
    classes
    (e.g.,
    AppsApi)
    in
    a
    Proxy
    for
    ergonomic
    calls
    (e.g.,
    client.getApp).
  - >-
    Relevance:
    Fails
    to
    import
    AppsApi.ts,
    causing
    the
    runtime
    error.
  - >-
    src/test.ts:
  - >-
    Role:
    Test
    script
    calling
    client.getApp({
    appId
    }).
  - >-
    Relevance:
    Final
    validation
    point;
    shows
    if
    the
    fix
    works.
  - >-
    .env.development:
  - >-
    Role:
    Stores
    QB_REALM,
    QB_USER_TOKEN,
    QB_APP_ID
    for
    API
    authentication.
  - >-
    Relevance:
    Ensures
    the
    API
    call
    has
    valid
    credentials
    (not
    the
    current
    issue,
    but
    critical
    for
    success).
  - >-
    src/specs/QuickBase_RESTful_API_2025-03-04T06_22_39.725Z.json
    (or
    similar):
  - >-
    Role:
    Original
    QuickBase
    API
    spec
    before
    fix-spec.ts
    processing.
  - >-
    Relevance:
    Shows
    how
    /apps/{appId}
    was
    originally
    defined,
    helping
    identify
    conflicts.
  - >-
    package.json:
  - >-
    Role:
    Defines
    scripts
    (fix-spec,
    regenerate,
    test)
    and
    dependencies
    (e.g.,
    ts-node,
    openapi-generator-cli).
  - >-
    Relevance:
    Confirms
    script
    commands
    and
    versions
    align
    with
    our
    process.
  - >-
    What
    We
    Achieved
  - >-
    Goal
    Met:
    You
    can
    now
    call
    client.getApp({
    appId:
    "buwai2zpe"
    })
    and
    get
    the
    app
    details
    {
    id:
    'buwai2zpe',
    name:
    'qb-copy'
    }.
  - >-
    Fixes
    Applied:
  - >-
    Added
    tags:
    ["Apps"]
    in
    fix-spec.ts
    to
    ensure
    AppsApi.ts
    is
    generated
    with
    getAppById.
  - >-
    Updated
    QuickbaseClient.ts
    to:
  - >-
    Use
    prototype
    methods
    via
    Object.getOwnPropertyNames.
  - >-
    Bind
    methods
    to
    preserve
    context
    with
    .bind(api).
  - >-
    Handle
    getAppById’s
    direct
    JSON
    return
    instead
    of
    a
    Response
    object.
  - >-
    Result:
    The
    ergonomic
    API
    you
    wanted
    (client.getApp)
    works
    seamlessly
    with
    the
    generated
    AppsApi.ts.
  - >-
    Why
    It
    Works
    Now
  - >-
    fix-spec.ts:
  - >-
    Correctly
    defined
    /apps/{appId}
    with
    operationId:
    "getAppById"
    and
    tags:
    ["Apps"],
    ensuring
    AppsApi.ts
    generation.
  - >-
    regenerate-client.ts:
  - >-
    Successfully
    ran
    OpenAPI
    Generator
    to
    produce
    AppsApi.ts
    with
    getAppById.
  - >-
    QuickbaseClient.ts:
  - >-
    buildMethodMap
    now
    captures
    getAppById
    and
    maps
    it
    to
    getApp.
  - >-
    invokeMethod
    passes
    {
    appId:
    'buwai2zpe'
    }
    as
    requestParameters
    and
    handles
    the
    JSON
    response
    directly.
  - >-
    test.ts:
  - >-
    Calls
    client.getApp
    and
    logs
    the
    result,
    proving
    the
    end-to-end
    flow.
tree:
  name: >-
    .
  type: >-
    directory
  children:
    - name: >-
        .env
      type: >-
        file
    - name: >-
        .gitignore
      type: >-
        file
    - name: >-
        CHANGELOG.md
      type: >-
        file
    - name: >-
        LICENSE
      type: >-
        file
    - name: >-
        README.md
      type: >-
        file
    - name: >-
        build-common.js
      type: >-
        file
    - name: >-
        build-esm.js
      type: >-
        file
    - name: >-
        build-umd.js
      type: >-
        file
    - name: >-
        dist
      type: >-
        directory
      children:
        - name: >-
            esm
          type: >-
            directory
          children:
            - name: >-
                quickbase.d.ts
              type: >-
                file
            - name: >-
                quickbase.js
              type: >-
                file
            - name: >-
                quickbase.js.map
              type: >-
                file
            - name: >-
                quickbase.min.js
              type: >-
                file
            - name: >-
                quickbase.min.js.map
              type: >-
                file
        - name: >-
            umd
          type: >-
            directory
          children:
            - name: >-
                quickbase.umd.js
              type: >-
                file
            - name: >-
                quickbase.umd.js.map
              type: >-
                file
            - name: >-
                quickbase.umd.min.js
              type: >-
                file
            - name: >-
                quickbase.umd.min.js.map
              type: >-
                file
    - name: >-
        docs
      type: >-
        directory
      children:
        - name: >-
            .vitepress
          type: >-
            directory
          children:
            - name: >-
                cache
              type: >-
                directory
              children:
                - name: >-
                    deps
                  type: >-
                    directory
                  children:
                    - name: >-
                        @theme_index.js
                      type: >-
                        file
                    - name: >-
                        @theme_index.js.map
                      type: >-
                        file
                    - name: >-
                        _metadata.json
                      type: >-
                        file
                    - name: >-
                        chunk-5A67QEFC.js
                      type: >-
                        file
                    - name: >-
                        chunk-5A67QEFC.js.map
                      type: >-
                        file
                    - name: >-
                        chunk-7D4P4MMP.js
                      type: >-
                        file
                    - name: >-
                        chunk-7D4P4MMP.js.map
                      type: >-
                        file
                    - name: >-
                        package.json
                      type: >-
                        file
                    - name: >-
                        vitepress___@vue_devtools-api.js
                      type: >-
                        file
                    - name: >-
                        vitepress___@vue_devtools-api.js.map
                      type: >-
                        file
                    - name: >-
                        vitepress___@vueuse_core.js
                      type: >-
                        file
                    - name: >-
                        vitepress___@vueuse_core.js.map
                      type: >-
                        file
                    - name: >-
                        vue.js
                      type: >-
                        file
                    - name: >-
                        vue.js.map
                      type: >-
                        file
            - name: >-
                config.mts
              type: >-
                file
            - name: >-
                dist
              type: >-
                directory
              children:
                - name: >-
                    404.html
                  type: >-
                    file
                - name: >-
                    api-examples.html
                  type: >-
                    file
                - name: >-
                    assets
                  type: >-
                    directory
                  children:
                    - name: >-
                        api-examples.md.CRRh3xeI.js
                      type: >-
                        file
                    - name: >-
                        api-examples.md.CRRh3xeI.lean.js
                      type: >-
                        file
                    - name: >-
                        app.Yv9tMCdR.js
                      type: >-
                        file
                    - name: >-
                        chunks
                      type: >-
                        directory
                      children:
                        - name: >-
                            framework.Dh1jimFm.js
                          type: >-
                            file
                        - name: >-
                            theme.CDm2W-g2.js
                          type: >-
                            file
                    - name: >-
                        index.md.kvvDM3Wd.js
                      type: >-
                        file
                    - name: >-
                        index.md.kvvDM3Wd.lean.js
                      type: >-
                        file
                    - name: >-
                        inter-italic-cyrillic-ext.r48I6akx.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-cyrillic.By2_1cv3.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-greek-ext.1u6EdAuj.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-greek.DJ8dCoTZ.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-latin-ext.CN1xVJS-.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-latin.C2AdPX0b.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-vietnamese.BSbpV94h.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-cyrillic-ext.BBPuwvHQ.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-cyrillic.C5lxZ8CY.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-greek-ext.CqjqNYQ-.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-greek.BBVDIX6e.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-latin-ext.4ZJIpNVo.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-latin.Di8DUHzh.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-vietnamese.BjW4sHH5.woff2
                      type: >-
                        file
                    - name: >-
                        markdown-examples.md.ediKJOVO.js
                      type: >-
                        file
                    - name: >-
                        markdown-examples.md.ediKJOVO.lean.js
                      type: >-
                        file
                    - name: >-
                        style.BJrZ0CFW.css
                      type: >-
                        file
                - name: >-
                    hashmap.json
                  type: >-
                    file
                - name: >-
                    index.html
                  type: >-
                    file
                - name: >-
                    markdown-examples.html
                  type: >-
                    file
                - name: >-
                    vp-icons.css
                  type: >-
                    file
        - name: >-
            api-examples.md
          type: >-
            file
        - name: >-
            index.md
          type: >-
            file
        - name: >-
            markdown-examples.md
          type: >-
            file
        - name: >-
            node_modules
          type: >-
            directory
          children: []
    - name: >-
        docs-data
      type: >-
        directory
      children:
        - name: >-
            api-docs.json
          type: >-
            file
    - name: >-
        examples
      type: >-
        directory
      children:
        - name: >-
            quicbase-jsCDN.html
          type: >-
            file
        - name: >-
            react.js
          type: >-
            file
        - name: >-
            vanillajs.html
          type: >-
            file
    - name: >-
        index.md
      type: >-
        file
    - name: >-
        open-api
      type: >-
        directory
      children:
        - name: >-
            fix-spec-main.ts
          type: >-
            file
        - name: >-
            generate-unified-interface.ts
          type: >-
            file
        - name: >-
            generateDocsJson.ts
          type: >-
            file
        - name: >-
            post-process-generated.ts
          type: >-
            file
        - name: >-
            regenerate-client.ts
          type: >-
            file
        - name: >-
            schema
          type: >-
            directory
          children:
            - name: >-
                enhance-general.ts
              type: >-
                file
            - name: >-
                fix-arrays.ts
              type: >-
                file
            - name: >-
                tags
              type: >-
                directory
              children:
                - name: >-
                    apps.ts
                  type: >-
                    file
                - name: >-
                    fields.ts
                  type: >-
                    file
                - name: >-
                    groups.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    records.ts
                  type: >-
                    file
                - name: >-
                    tables.ts
                  type: >-
                    file
                - name: >-
                    users.ts
                  type: >-
                    file
        - name: >-
            types
          type: >-
            directory
          children:
            - name: >-
                spec.ts
              type: >-
                file
        - name: >-
            utils
          type: >-
            directory
          children:
            - name: >-
                common.ts
              type: >-
                file
            - name: >-
                generateJsDoc.ts
              type: >-
                file
            - name: >-
                infer-schema.ts
              type: >-
                file
            - name: >-
                naming.ts
              type: >-
                file
            - name: >-
                sharedUtils.ts
              type: >-
                file
    - name: >-
        openapitools.json
      type: >-
        file
    - name: >-
        package-lock.json
      type: >-
        file
    - name: >-
        package.json
      type: >-
        file
    - name: >-
        playwright.config.ts
      type: >-
        file
    - name: >-
        quickbase-js-0.1.0-beta.13.tgz
      type: >-
        file
    - name: >-
        rollup.config.js
      type: >-
        file
    - name: >-
        src
      type: >-
        directory
      children:
        - name: >-
            BurstAwareThrottleBucket.ts
          type: >-
            file
        - name: >-
            FlowThrottleBucket.ts
          type: >-
            file
        - name: >-
            RateLimitError.ts
          type: >-
            file
          contents: >
            //
            src/RateLimitError.ts

            export
            class
            RateLimitError
            extends
            Error
            {
              public readonly status: number;
              public readonly retryAfter?: number;

              constructor(message: string, status: number, retryAfter?: number) {
                super(message);
                this.name = "RateLimitError";
                this.status = status;
                this.retryAfter = retryAfter; // Seconds from Retry-After header, if present
              }
            }
        - name: >-
            RateThrottleBucket.ts
          type: >-
            file
        - name: >-
            Semaphore.ts
          type: >-
            file
        - name: >-
            authorizationStrategy.ts
          type: >-
            file
          contents: >
            import
            {
            TokenCache
            }
            from
            "./tokenCache";


            export
            interface
            AuthorizationStrategy
            {
              getToken(dbid: string): Promise<string | undefined>;
              applyHeaders(headers: Record<string, string>, token: string): void;
              handleError(
                status: number,
                params: any,
                attempt: number,
                maxAttempts: number,
                debug?: boolean,
                methodName?: string
              ): Promise<string | null>;
            }


            export
            class
            TempTokenStrategy
            implements
            AuthorizationStrategy
            {
              private pendingFetches: Map<string, Promise<string>> = new Map();

              constructor(
                private tokenCache: TokenCache,
                private initialTempToken: string | undefined,
                private fetchApi: typeof fetch,
                private realm: string,
                private baseUrl: string = "https://api.quickbase.com/v1"
              ) {}

              async fetchTempToken(dbid: string): Promise<string> {
                const headers = {
                  "QB-Realm-Hostname": `${this.realm}.quickbase.com`,
                  "Content-Type": "application/json",
                };
                const response = await this.fetchApi(
                  `${this.baseUrl}/auth/temporary/${dbid}`,
                  {
                    method: "GET",
                    headers,
                    credentials: "include",
                  }
                );

                if (!response.ok) {
                  const errorBody = await response.json().catch(() => ({}));
                  const message = errorBody.message || "Unknown error";
                  throw new Error(`API Error: ${message} (Status: ${response.status})`);
                }

                const tokenResult = await response.json();
                const token = tokenResult.temporaryAuthorization;
                if (!token) {
                  throw new Error(
                    "API Error: No temporary token returned from API (Status: 200)"
                  );
                }
                this.tokenCache.set(dbid, token);
                console.log(`Fetched and cached new token for dbid: ${dbid}`, token);
                return token;
              }

              async getToken(dbid: string): Promise<string | undefined> {
                let token = this.tokenCache.get(dbid) || this.initialTempToken;
                if (!token && dbid) {
                  if (this.pendingFetches.has(dbid)) {
                    console.log(`[getToken] Waiting for existing fetch for dbid: ${dbid}`);
                    return this.pendingFetches.get(dbid);
                  }
                  const fetchPromise = this.fetchTempToken(dbid).finally(() =>
                    this.pendingFetches.delete(dbid)
                  );
                  this.pendingFetches.set(dbid, fetchPromise);
                  token = await fetchPromise;
                }
                return token;
              }

              applyHeaders(headers: Record<string, string>, token: string): void {
                headers["Authorization"] = `QB-TEMP-TOKEN ${token}`;
              }

              async handleError(
                status: number,
                params: any,
                attempt: number,
                maxAttempts: number,
                debug?: boolean,
                methodName?: string
              ): Promise<string | null> {
                if (status !== 401 || attempt >= maxAttempts - 1) return null;
                if (debug)
                  console.log(
                    `Authorization error for ${
                      methodName || "method"
                    } (temp token), refreshing token:`
                  );
                const dbid = extractDbid(params);
                if (!dbid) {
                  if (debug)
                    console.log(
                      `No dbid available for ${
                        methodName || "method"
                      }, skipping token refresh`
                    );
                  return null;
                }
                if (debug) console.log(`Refreshing temp token for dbid: ${dbid}`);
                // Invalidate the cache for this dbid to force a fresh fetch
                this.tokenCache.delete(dbid);
                try {
                  const newToken = await this.getToken(dbid);
                  if (newToken) {
                    this.tokenCache.set(dbid, newToken);
                    if (debug)
                      console.log(
                        `[${
                          methodName || "method"
                        }] Retrying with token: ${newToken.substring(0, 10)}...`
                      );
                    return newToken;
                  }
                  return null;
                } catch (error) {
                  if (debug)
                    console.log(
                      `[${methodName || "method"}] Failed to refresh token:`,
                      error
                    );
                  throw error;
                }
              }
            }


            export
            class
            UserTokenStrategy
            implements
            AuthorizationStrategy
            {
              constructor(
                private userToken: string,
                private baseUrl: string = "https://api.quickbase.com/v1"
              ) {}

              async getToken(_dbid: string): Promise<string> {
                return this.userToken;
              }

              applyHeaders(headers: Record<string, string>, token: string): void {
                headers["Authorization"] = `QB-USER-TOKEN ${token}`;
              }

              async handleError(
                status: number,
                _params: any,
                attempt: number,
                maxAttempts: number,
                debug?: boolean,
                methodName?: string
              ): Promise<string | null> {
                if (status !== 401 || attempt >= maxAttempts - 1) return null;
                if (debug)
                  console.log(
                    `Retrying ${
                      methodName || "method"
                    } with existing user token: ${this.userToken.substring(0, 10)}...`
                  );
                return this.userToken;
              }
            }


            export
            class
            SsoTokenStrategy
            implements
            AuthorizationStrategy
            {
              private currentToken: string | undefined;
              private pendingFetches: Map<string, Promise<string>> = new Map();

              constructor(
                private samlToken: string,
                private realm: string,
                private fetchApi: typeof fetch,
                private debug: boolean = false,
                private baseUrl: string = "https://api.quickbase.com/v1"
              ) {}

              async getToken(_dbid: string): Promise<string | undefined> {
                if (!this.currentToken) {
                  if (this.pendingFetches.has("sso")) {
                    if (this.debug)
                      console.log("[getToken] Waiting for existing SSO fetch");
                    return this.pendingFetches.get("sso");
                  }
                  const fetchPromise = this.fetchSsoToken({
                    grant_type: "urn:ietf:params:oauth:grant-type:token-exchange",
                    requested_token_type:
                      "urn:quickbase:params:oauth:token-type:temp_token",
                    subject_token: this.samlToken,
                    subject_token_type: "urn:ietf:params:oauth:token-type:saml2",
                  }).finally(() => this.pendingFetches.delete("sso"));
                  this.pendingFetches.set("sso", fetchPromise);
                  this.currentToken = await fetchPromise;
                }
                return this.currentToken;
              }

              applyHeaders(headers: Record<string, string>, token: string): void {
                headers["Authorization"] = `QB-TEMP-TOKEN ${token}`;
              }

              async handleError(
                status: number,
                _params: any,
                attempt: number,
                maxAttempts: number,
                debug?: boolean,
                methodName?: string
              ): Promise<string | null> {
                if (status !== 401 || attempt >= maxAttempts - 1) return null;

                if (debug || this.debug) {
                  console.log(
                    `Authorization error for ${
                      methodName || "method"
                    } (SSO), refreshing token`
                  );
                }

                const newToken = await this.refreshSsoToken(debug || this.debug);
                if (newToken) {
                  this.currentToken = newToken;
                  if (debug || this.debug)
                    console.log(
                      `[${
                        methodName || "method"
                      }] Retrying with token: ${newToken.substring(0, 10)}...`
                    );
                  return newToken;
                }
                return null;
              }

              private async refreshSsoToken(debug: boolean = false): Promise<string> {
                const payload = {
                  grant_type: "urn:ietf:params:oauth:grant-type:token-exchange",
                  requested_token_type: "urn:quickbase:params:oauth:token-type:temp_token",
                  subject_token: this.samlToken,
                  subject_token_type: "urn:ietf:params:oauth:token-type:saml2",
                };

                const response = await this.fetchApi(`${this.baseUrl}/auth/oauth/token`, {
                  method: "POST",
                  headers: {
                    "QB-Realm-Hostname": `${this.realm}.quickbase.com`,
                    "Content-Type": "application/json",
                  },
                  body: JSON.stringify(payload),
                  credentials: "omit",
                });

                if (!response.ok) {
                  const errorBody = await response.json().catch(() => ({}));
                  if (debug) {
                    console.log(`[SSO Refresh] Failed: ${response.status}`, errorBody);
                  }
                  throw new Error(
                    `SSO token refresh failed: ${errorBody.message || "Unknown error"}`
                  );
                }

                const result = await response.json();
                const newToken = result.access_token;
                if (!newToken) {
                  throw new Error("No access token returned from SSO token exchange");
                }

                if (debug) {
                  console.log(`[SSO Refresh] New token: ${newToken.substring(0, 10)}...`);
                }
                return newToken;
              }

              private async fetchSsoToken(params: {
                grant_type: string;
                requested_token_type: string;
                subject_token: string;
                subject_token_type: string;
              }): Promise<string> {
                const response = await this.fetchApi(`${this.baseUrl}/auth/oauth/token`, {
                  method: "POST",
                  headers: {
                    "QB-Realm-Hostname": `${this.realm}.quickbase.com`,
                    "Content-Type": "application/json",
                  },
                  body: JSON.stringify(params),
                  credentials: "omit",
                });

                if (!response.ok) {
                  const errorBody = await response.json().catch(() => ({}));
                  if (this.debug) {
                    console.log(`[fetchSsoToken] Failed: ${response.status}`, errorBody);
                  }
                  throw new Error(
                    `SSO token fetch failed: ${errorBody.message || "Unknown error"}`
                  );
                }

                const result = await response.json();
                const newToken = result.access_token;
                if (!newToken) {
                  throw new Error("No access token returned from SSO token exchange");
                }

                if (this.debug) {
                  console.log(
                    `[fetchSsoToken] Fetched token: ${newToken.substring(0, 10)}...`
                  );
                }
                return newToken;
              }
            }


            export
            function
            extractDbid(params:
            any):
            string
            |
            undefined
            {
              return (
                params.dbid ||
                params.tableId ||
                params.appId ||
                params.body?.from ||
                params.body?.to
              );
            }
        - name: >-
            generated
          type: >-
            directory
          children:
            - name: >-
                .openapi-generator
              type: >-
                directory
              children:
                - name: >-
                    FILES
                  type: >-
                    file
                - name: >-
                    VERSION
                  type: >-
                    file
            - name: >-
                .openapi-generator-ignore
              type: >-
                file
            - name: >-
                apis
              type: >-
                directory
              children:
                - name: >-
                    AppsApi.ts
                  type: >-
                    file
                  contents: >
                    /*
                    tslint:disable
                    */

                    /*
                    eslint-disable
                    */

                    /**
                     * Quick Base API
                     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
                     *
                     * The version of the OpenAPI document: 1.0.0
                     * 
                     *
                     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
                     * https://openapi-generator.tech
                     * Do not edit the class manually.
                     */


                    import
                    *
                    as
                    runtime
                    from
                    '../runtime';

                    import
                    type
                    {
                      CopyApp200Response,
                      CopyAppRequest,
                      CreateApp200Response,
                      CreateAppRequest,
                      DeleteApp200Response,
                      DeleteAppRequest,
                      GetApp200Response,
                      GetAppEvents200Response,
                      UpdateApp200Response,
                      UpdateAppRequest,
                    }
                    from
                    '../models/index';

                    import
                    {
                        CopyApp200ResponseFromJSON,
                        CopyApp200ResponseToJSON,
                        CopyAppRequestFromJSON,
                        CopyAppRequestToJSON,
                        CreateApp200ResponseFromJSON,
                        CreateApp200ResponseToJSON,
                        CreateAppRequestFromJSON,
                        CreateAppRequestToJSON,
                        DeleteApp200ResponseFromJSON,
                        DeleteApp200ResponseToJSON,
                        DeleteAppRequestFromJSON,
                        DeleteAppRequestToJSON,
                        GetApp200ResponseFromJSON,
                        GetApp200ResponseToJSON,
                        GetAppEvents200ResponseFromJSON,
                        GetAppEvents200ResponseToJSON,
                        UpdateApp200ResponseFromJSON,
                        UpdateApp200ResponseToJSON,
                        UpdateAppRequestFromJSON,
                        UpdateAppRequestToJSON,
                    }
                    from
                    '../models/index';


                    export
                    interface
                    CopyAppOperationRequest
                    {
                        appId: string;
                        generated?: CopyAppRequest;
                    }


                    export
                    interface
                    CreateAppOperationRequest
                    {
                        generated?: CreateAppRequest;
                    }


                    export
                    interface
                    DeleteAppOperationRequest
                    {
                        appId: string;
                        generated?: DeleteAppRequest;
                    }


                    export
                    interface
                    GetAppRequest
                    {
                        appId: string;
                    }


                    export
                    interface
                    GetAppEventsRequest
                    {
                        appId: string;
                    }


                    export
                    interface
                    UpdateAppOperationRequest
                    {
                        appId: string;
                        generated?: UpdateAppRequest;
                    }


                    /**
                     * AppsApi - interface
                     * 
                     * @export
                     * @interface AppsApiInterface
                     */
                    export
                    interface
                    AppsApiInterface
                    {
                        /**
                         * Copies the specified application. The new application will have the same schema as the original. See below for additional copy options.
                         * @summary Copy an app
                         * @param {string} appId The unique identifier of an app
                         * @param {CopyAppRequest} [generated] 
                         * @param {*} [options] Override http request option.
                         * @throws {RequiredError}
                         * @memberof AppsApiInterface
                         */
                        copyAppRaw(requestParameters: CopyAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CopyApp200Response>>;

                        /**
                         * Copies the specified application. The new application will have the same schema as the original. See below for additional copy options.
                         * Copy an app
                         */
                        copyApp(requestParameters: CopyAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CopyApp200Response>;

                        /**
                         * Creates an application in an account. You must have application creation rights in the respective account. Main properties and application variables can be set with this API.
                         * @summary Create an app
                         * @param {CreateAppRequest} [generated] 
                         * @param {*} [options] Override http request option.
                         * @throws {RequiredError}
                         * @memberof AppsApiInterface
                         */
                        createAppRaw(requestParameters: CreateAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateApp200Response>>;

                        /**
                         * Creates an application in an account. You must have application creation rights in the respective account. Main properties and application variables can be set with this API.
                         * Create an app
                         */
                        createApp(requestParameters: CreateAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateApp200Response>;

                        /**
                         * Deletes an entire application, including all of the tables and data.
                         * @summary Delete an app
                         * @param {string} appId The unique identifier of an app
                         * @param {DeleteAppRequest} [generated] 
                         * @param {*} [options] Override http request option.
                         * @throws {RequiredError}
                         * @memberof AppsApiInterface
                         */
                        deleteAppRaw(requestParameters: DeleteAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteApp200Response>>;

                        /**
                         * Deletes an entire application, including all of the tables and data.
                         * Delete an app
                         */
                        deleteApp(requestParameters: DeleteAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteApp200Response>;

                        /**
                         * Returns the main properties of an application, including application variables.
                         * @summary Get an app
                         * @param {string} appId The unique identifier of an app
                         * @param {*} [options] Override http request option.
                         * @throws {RequiredError}
                         * @memberof AppsApiInterface
                         */
                        getAppRaw(requestParameters: GetAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetApp200Response>>;

                        /**
                         * Returns the main properties of an application, including application variables.
                         * Get an app
                         */
                        getApp(requestParameters: GetAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetApp200Response>;

                        /**
                         * Get a list of events that can be triggered based on data or user actions in this application, includes: Email notification, Reminders, Subscriptions, QB Actions, Webhooks, record change triggered Automations (does not include scheduled).
                         * @summary Get app events
                         * @param {string} appId The unique identifier of an app
                         * @param {*} [options] Override http request option.
                         * @throws {RequiredError}
                         * @memberof AppsApiInterface
                         */
                        getAppEventsRaw(requestParameters: GetAppEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAppEvents200Response>>;

                        /**
                         * Get a list of events that can be triggered based on data or user actions in this application, includes: Email notification, Reminders, Subscriptions, QB Actions, Webhooks, record change triggered Automations (does not include scheduled).
                         * Get app events
                         */
                        getAppEvents(requestParameters: GetAppEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAppEvents200Response>;

                        /**
                         * Updates the main properties and/or application variables for a specific application. Any properties of the app that you do not specify in the request body will remain unchanged.
                         * @summary Update an app
                         * @param {string} appId The unique identifier of an app
                         * @param {UpdateAppRequest} [generated] 
                         * @param {*} [options] Override http request option.
                         * @throws {RequiredError}
                         * @memberof AppsApiInterface
                         */
                        updateAppRaw(requestParameters: UpdateAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateApp200Response>>;

                        /**
                         * Updates the main properties and/or application variables for a specific application. Any properties of the app that you do not specify in the request body will remain unchanged.
                         * Update an app
                         */
                        updateApp(requestParameters: UpdateAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateApp200Response>;

                    }


                    /**
                     * 
                     */
                    export
                    class
                    AppsApi
                    extends
                    runtime.BaseAPI
                    implements
                    AppsApiInterface
                    {

                        /**
                         * Copies the specified application. The new application will have the same schema as the original. See below for additional copy options.
                         * Copy an app
                         */
                        async copyAppRaw(requestParameters: CopyAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CopyApp200Response>> {
                            if (requestParameters['appId'] == null) {
                                throw new runtime.RequiredError(
                                    'appId',
                                    'Required parameter "appId" was null or undefined when calling copyApp().'
                                );
                            }

                            const queryParameters: any = {};

                            const headerParameters: runtime.HTTPHeaders = {};

                            headerParameters['Content-Type'] = 'application/json';

                            const response = await this.request({
                                path: `/apps/{appId}/copy`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
                                method: 'POST',
                                headers: headerParameters,
                                query: queryParameters,
                                body: CopyAppRequestToJSON(requestParameters['generated']),
                            }, initOverrides);

                            return new runtime.JSONApiResponse(response, (jsonValue) => CopyApp200ResponseFromJSON(jsonValue));
                        }

                        /**
                         * Copies the specified application. The new application will have the same schema as the original. See below for additional copy options.
                         * Copy an app
                         */
                        async copyApp(requestParameters: CopyAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CopyApp200Response> {
                            const response = await this.copyAppRaw(requestParameters, initOverrides);
                            return await response.value();
                        }

                        /**
                         * Creates an application in an account. You must have application creation rights in the respective account. Main properties and application variables can be set with this API.
                         * Create an app
                         */
                        async createAppRaw(requestParameters: CreateAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateApp200Response>> {
                            const queryParameters: any = {};

                            const headerParameters: runtime.HTTPHeaders = {};

                            headerParameters['Content-Type'] = 'application/json';

                            const response = await this.request({
                                path: `/apps`,
                                method: 'POST',
                                headers: headerParameters,
                                query: queryParameters,
                                body: CreateAppRequestToJSON(requestParameters['generated']),
                            }, initOverrides);

                            return new runtime.JSONApiResponse(response, (jsonValue) => CreateApp200ResponseFromJSON(jsonValue));
                        }

                        /**
                         * Creates an application in an account. You must have application creation rights in the respective account. Main properties and application variables can be set with this API.
                         * Create an app
                         */
                        async createApp(requestParameters: CreateAppOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateApp200Response> {
                            const response = await this.createAppRaw(requestParameters, initOverrides);
                            return await response.value();
                        }

                        /**
                         * Deletes an entire application, including all of the tables and data.
                         * Delete an app
                         */
                        async deleteAppRaw(requestParameters: DeleteAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteApp200Response>> {
                            if (requestParameters['appId'] == null) {
                                throw new runtime.RequiredError(
                                    'appId',
                                    'Required parameter "appId" was null or undefined when calling deleteApp().'
                                );
                            }

                            const queryParameters: any = {};

                            const headerParameters: runtime.HTTPHeaders = {};

                            headerParameters['Content-Type'] = 'application/json';

                            const response = await this.request({
                                path: `/apps/{appId}`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
                                method: 'DELETE',
                                headers: headerParameters,
                                query: queryParameters,
                                body: DeleteAppRequestToJSON(requestParameters['generated']),
                            }, initOverrides);

                            return new runtime.JSONApiResponse(response, (jsonValue) => DeleteApp200ResponseFromJSON(jsonValue));
                        }

                        /**
                         * Deletes an entire application, including all of the tables and data.
                         * Delete an app
                         */
                        async deleteApp(requestParameters: DeleteAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteApp200Response> {
                            const response = await this.deleteAppRaw(requestParameters, initOverrides);
                            return await response.value();
                        }

                        /**
                         * Returns the main properties of an application, including application variables.
                         * Get an app
                         */
                        async getAppRaw(requestParameters: GetAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetApp200Response>> {
                            if (requestParameters['appId'] == null) {
                                throw new runtime.RequiredError(
                                    'appId',
                                    'Required parameter "appId" was null or undefined when calling getApp().'
                                );
                            }

                            const queryParameters: any = {};

                            const headerParameters: runtime.HTTPHeaders = {};

                            const response = await this.request({
                                path: `/apps/{appId}`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
                                method: 'GET',
                                headers: headerParameters,
                                query: queryParameters,
                            }, initOverrides);

                            return new runtime.JSONApiResponse(response, (jsonValue) => GetApp200ResponseFromJSON(jsonValue));
                        }

                        /**
                         * Returns the main properties of an application, including application variables.
                         * Get an app
                         */
                        async getApp(requestParameters: GetAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetApp200Response> {
                            const response = await this.getAppRaw(requestParameters, initOverrides);
                            return await response.value();
                        }

                        /**
                         * Get a list of events that can be triggered based on data or user actions in this application, includes: Email notification, Reminders, Subscriptions, QB Actions, Webhooks, record change triggered Automations (does not include scheduled).
                         * Get app events
                         */
                        async getAppEventsRaw(requestParameters: GetAppEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAppEvents200Response>> {
                            if (requestParameters['appId'] == null) {
                                throw new runtime.RequiredError(
                                    'appId',
                                    'Required parameter "appId" was null or undefined when calling getAppEvents().'
                                );
                            }

                            const queryParameters: any = {};

                            const headerParameters: runtime.HTTPHeaders = {};

                            const response = await this.request({
                                path: `/apps/{appId}/events`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
                                method: 'GET',
                                headers: headerParameters,
                                query: queryParameters,
                            }, initOverrides);

                            return new runtime.JSONApiResponse(response, (jsonValue) => GetAppEvents200ResponseFromJSON(jsonValue));
                        }

                        /**
                         * Get a list of events that can be triggered based on data or user actions in this application, includes: Email notification, Reminders, Subscriptions, QB Actions, Webhooks, record change triggered Automations (does not include scheduled).
                         * Get app events
                         */
                        async getAppEvents(requestParameters: GetAppEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAppEvents200Response> {
                            const response = await this.getAppEventsRaw(requestParameters, initOverrides);
                            return await response.value();
                        }

                        /**
                         * Updates the main properties and/or application variables for a specific application. Any properties of the app that you do not specify in the request body will remain unchanged.
                         * Update an app
                         */
                        async updateAppRaw(requestParameters: UpdateAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateApp200Response>> {
                            if (requestParameters['appId'] == null) {
                                throw new runtime.RequiredError(
                                    'appId',
                                    'Required parameter "appId" was null or undefined when calling updateApp().'
                                );
                            }

                            const queryParameters: any = {};

                            const headerParameters: runtime.HTTPHeaders = {};

                            headerParameters['Content-Type'] = 'application/json';

                            const response = await this.request({
                                path: `/apps/{appId}`.replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
                                method: 'POST',
                                headers: headerParameters,
                                query: queryParameters,
                                body: UpdateAppRequestToJSON(requestParameters['generated']),
                            }, initOverrides);

                            return new runtime.JSONApiResponse(response, (jsonValue) => UpdateApp200ResponseFromJSON(jsonValue));
                        }

                        /**
                         * Updates the main properties and/or application variables for a specific application. Any properties of the app that you do not specify in the request body will remain unchanged.
                         * Update an app
                         */
                        async updateApp(requestParameters: UpdateAppOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateApp200Response> {
                            const response = await this.updateAppRaw(requestParameters, initOverrides);
                            return await response.value();
                        }

                    }
                - name: >-
                    AuditApi.ts
                  type: >-
                    file
                - name: >-
                    AuthApi.ts
                  type: >-
                    file
                  contents: >
                    /*
                    tslint:disable
                    */

                    /*
                    eslint-disable
                    */

                    /**
                     * Quick Base API
                     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
                     *
                     * The version of the OpenAPI document: 1.0.0
                     * 
                     *
                     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
                     * https://openapi-generator.tech
                     * Do not edit the class manually.
                     */


                    import
                    *
                    as
                    runtime
                    from
                    '../runtime';

                    import
                    type
                    {
                      ExchangeSsoToken200Response,
                      ExchangeSsoTokenRequest,
                      GetTempTokenDBID200Response,
                    }
                    from
                    '../models/index';

                    import
                    {
                        ExchangeSsoToken200ResponseFromJSON,
                        ExchangeSsoToken200ResponseToJSON,
                        ExchangeSsoTokenRequestFromJSON,
                        ExchangeSsoTokenRequestToJSON,
                        GetTempTokenDBID200ResponseFromJSON,
                        GetTempTokenDBID200ResponseToJSON,
                    }
                    from
                    '../models/index';


                    export
                    interface
                    ExchangeSsoTokenOperationRequest
                    {
                        generated?: ExchangeSsoTokenRequest;
                    }


                    export
                    interface
                    GetTempTokenDBIDRequest
                    {
                        dbid: string;
                        qBAppToken?: string;
                    }


                    /**
                     * AuthApi - interface
                     * 
                     * @export
                     * @interface AuthApiInterface
                     */
                    export
                    interface
                    AuthApiInterface
                    {
                        /**
                         * Use this endpoint to exchange a SAML assertion for a Quickbase token following [RFC 8693](https://www.rfc-editor.org/rfc/rfc8693.html). Callers can choose to return a token compatible with SCIM, XML, or RESTful APIs. The token duration is determined by the [SAML timeout session time](https://helpv2.quickbase.com/hc/en-us/articles/4570410646420-SAML-assertion-example#:~:text=Setting%20SAML%20timeout%20session%20time). You must be able to create a SAML assertion in your code to use this endpoint. The SAML assertion is verified against the configuration on the realm. Learn more about about [SAML assertions](https://helpv2.quickbase.com/hc/en-us/articles/4570410646420-SAML-assertion-example).
                         * @summary Exchange an SSO token
                         * @param {ExchangeSsoTokenRequest} [generated] 
                         * @param {*} [options] Override http request option.
                         * @throws {RequiredError}
                         * @memberof AuthApiInterface
                         */
                        exchangeSsoTokenRaw(requestParameters: ExchangeSsoTokenOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExchangeSsoToken200Response>>;

                        /**
                         * Use this endpoint to exchange a SAML assertion for a Quickbase token following [RFC 8693](https://www.rfc-editor.org/rfc/rfc8693.html). Callers can choose to return a token compatible with SCIM, XML, or RESTful APIs. The token duration is determined by the [SAML timeout session time](https://helpv2.quickbase.com/hc/en-us/articles/4570410646420-SAML-assertion-example#:~:text=Setting%20SAML%20timeout%20session%20time). You must be able to create a SAML assertion in your code to use this endpoint. The SAML assertion is verified against the configuration on the realm. Learn more about about [SAML assertions](https://helpv2.quickbase.com/hc/en-us/articles/4570410646420-SAML-assertion-example).
                         * Exchange an SSO token
                         */
                        exchangeSsoToken(requestParameters: ExchangeSsoTokenOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExchangeSsoToken200Response>;

                        /**
                         * Use this endpoint to get a temporary authorization token, scoped to either an app or a table. It can only be used inside of code pages for client-side authentication because it relies on the browser session. Learn more about [extending Quickbase](https://helpv2.quickbase.com/hc/en-us/articles/4570341709844-Extending-Quickbase). You can then use this token to make other API calls (see [authorization](../auth)).  This token expires in 5 minutes.
                         * @summary Get a temporary token for a dbid
                         * @param {string} dbid The unique identifier of an app or table.
                         * @param {string} [qBAppToken] Your Quickbase app token
                         * @param {*} [options] Override http request option.
                         * @throws {RequiredError}
                         * @memberof AuthApiInterface
                         */
                        getTempTokenDBIDRaw(requestParameters: GetTempTokenDBIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTempTokenDBID200Response>>;

                        /**
                         * Use this endpoint to get a temporary authorization token, scoped to either an app or a table. It can only be used inside of code pages for client-side authentication because it relies on the browser session. Learn more about [extending Quickbase](https://helpv2.quickbase.com/hc/en-us/articles/4570341709844-Extending-Quickbase). You can then use this token to make other API calls (see [authorization](../auth)).  This token expires in 5 minutes.
                         * Get a temporary token for a dbid
                         */
                        getTempTokenDBID(requestParameters: GetTempTokenDBIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTempTokenDBID200Response>;

                    }


                    /**
                     * 
                     */
                    export
                    class
                    AuthApi
                    extends
                    runtime.BaseAPI
                    implements
                    AuthApiInterface
                    {

                        /**
                         * Use this endpoint to exchange a SAML assertion for a Quickbase token following [RFC 8693](https://www.rfc-editor.org/rfc/rfc8693.html). Callers can choose to return a token compatible with SCIM, XML, or RESTful APIs. The token duration is determined by the [SAML timeout session time](https://helpv2.quickbase.com/hc/en-us/articles/4570410646420-SAML-assertion-example#:~:text=Setting%20SAML%20timeout%20session%20time). You must be able to create a SAML assertion in your code to use this endpoint. The SAML assertion is verified against the configuration on the realm. Learn more about about [SAML assertions](https://helpv2.quickbase.com/hc/en-us/articles/4570410646420-SAML-assertion-example).
                         * Exchange an SSO token
                         */
                        async exchangeSsoTokenRaw(requestParameters: ExchangeSsoTokenOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExchangeSsoToken200Response>> {
                            const queryParameters: any = {};

                            const headerParameters: runtime.HTTPHeaders = {};

                            headerParameters['Content-Type'] = 'application/json';

                            const response = await this.request({
                                path: `/auth/oauth/token`,
                                method: 'POST',
                                headers: headerParameters,
                                query: queryParameters,
                                body: ExchangeSsoTokenRequestToJSON(requestParameters['generated']),
                            }, initOverrides);

                            return new runtime.JSONApiResponse(response, (jsonValue) => ExchangeSsoToken200ResponseFromJSON(jsonValue));
                        }

                        /**
                         * Use this endpoint to exchange a SAML assertion for a Quickbase token following [RFC 8693](https://www.rfc-editor.org/rfc/rfc8693.html). Callers can choose to return a token compatible with SCIM, XML, or RESTful APIs. The token duration is determined by the [SAML timeout session time](https://helpv2.quickbase.com/hc/en-us/articles/4570410646420-SAML-assertion-example#:~:text=Setting%20SAML%20timeout%20session%20time). You must be able to create a SAML assertion in your code to use this endpoint. The SAML assertion is verified against the configuration on the realm. Learn more about about [SAML assertions](https://helpv2.quickbase.com/hc/en-us/articles/4570410646420-SAML-assertion-example).
                         * Exchange an SSO token
                         */
                        async exchangeSsoToken(requestParameters: ExchangeSsoTokenOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExchangeSsoToken200Response> {
                            const response = await this.exchangeSsoTokenRaw(requestParameters, initOverrides);
                            return await response.value();
                        }

                        /**
                         * Use this endpoint to get a temporary authorization token, scoped to either an app or a table. It can only be used inside of code pages for client-side authentication because it relies on the browser session. Learn more about [extending Quickbase](https://helpv2.quickbase.com/hc/en-us/articles/4570341709844-Extending-Quickbase). You can then use this token to make other API calls (see [authorization](../auth)).  This token expires in 5 minutes.
                         * Get a temporary token for a dbid
                         */
                        async getTempTokenDBIDRaw(requestParameters: GetTempTokenDBIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTempTokenDBID200Response>> {
                            if (requestParameters['dbid'] == null) {
                                throw new runtime.RequiredError(
                                    'dbid',
                                    'Required parameter "dbid" was null or undefined when calling getTempTokenDBID().'
                                );
                            }

                            const queryParameters: any = {};

                            const headerParameters: runtime.HTTPHeaders = {};

                            if (requestParameters['qBAppToken'] != null) {
                                headerParameters['qBAppToken'] = String(requestParameters['qBAppToken']);
                            }

                            const response = await this.request({
                                path: `/auth/temporary/{dbid}`.replace(`{${"dbid"}}`, encodeURIComponent(String(requestParameters['dbid']))),
                                method: 'GET',
                                headers: headerParameters,
                                query: queryParameters,
                            }, initOverrides);

                            return new runtime.JSONApiResponse(response, (jsonValue) => GetTempTokenDBID200ResponseFromJSON(jsonValue));
                        }

                        /**
                         * Use this endpoint to get a temporary authorization token, scoped to either an app or a table. It can only be used inside of code pages for client-side authentication because it relies on the browser session. Learn more about [extending Quickbase](https://helpv2.quickbase.com/hc/en-us/articles/4570341709844-Extending-Quickbase). You can then use this token to make other API calls (see [authorization](../auth)).  This token expires in 5 minutes.
                         * Get a temporary token for a dbid
                         */
                        async getTempTokenDBID(requestParameters: GetTempTokenDBIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTempTokenDBID200Response> {
                            const response = await this.getTempTokenDBIDRaw(requestParameters, initOverrides);
                            return await response.value();
                        }

                    }
                - name: >-
                    DocumentTemplatesApi.ts
                  type: >-
                    file
                - name: >-
                    FieldsApi.ts
                  type: >-
                    file
                  contents: >
                    /*
                    tslint:disable
                    */

                    /*
                    eslint-disable
                    */

                    /**
                     * Quick Base API
                     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
                     *
                     * The version of the OpenAPI document: 1.0.0
                     * 
                     *
                     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
                     * https://openapi-generator.tech
                     * Do not edit the class manually.
                     */


                    import
                    *
                    as
                    runtime
                    from
                    '../runtime';

                    import
                    type
                    {
                      CreateField200Response,
                      CreateFieldRequest,
                      DeleteFields200Response,
                      DeleteFieldsRequest,
                      GetField200Response,
                      GetFieldUsage200Response,
                      GetFields200Response,
                      GetFieldsUsage200Response,
                      UpdateField200Response,
                      UpdateFieldRequest,
                    }
                    from
                    '../models/index';

                    import
                    {
                        CreateField200ResponseFromJSON,
                        CreateField200ResponseToJSON,
                        CreateFieldRequestFromJSON,
                        CreateFieldRequestToJSON,
                        DeleteFields200ResponseFromJSON,
                        DeleteFields200ResponseToJSON,
                        DeleteFieldsRequestFromJSON,
                        DeleteFieldsRequestToJSON,
                        GetField200ResponseFromJSON,
                        GetField200ResponseToJSON,
                        GetFieldUsage200ResponseFromJSON,
                        GetFieldUsage200ResponseToJSON,
                        GetFields200ResponseFromJSON,
                        GetFields200ResponseToJSON,
                        GetFieldsUsage200ResponseFromJSON,
                        GetFieldsUsage200ResponseToJSON,
                        UpdateField200ResponseFromJSON,
                        UpdateField200ResponseToJSON,
                        UpdateFieldRequestFromJSON,
                        UpdateFieldRequestToJSON,
                    }
                    from
                    '../models/index';


                    export
                    interface
                    CreateFieldOperationRequest
                    {
                        tableId: string;
                        generated?: CreateFieldRequest;
                    }


                    export
                    interface
                    DeleteFieldsOperationRequest
                    {
                        tableId: string;
                        generated?: DeleteFieldsRequest;
                    }


                    export
                    interface
                    GetFieldRequest
                    {
                        tableId: string;
                        fieldId: number;
                        includeFieldPerms?: boolean;
                    }


                    export
                    interface
                    GetFieldUsageRequest
                    {
                        tableId: string;
                        fieldId: number;
                    }


                    export
                    interface
                    GetFieldsRequest
                    {
                        tableId: string;
                        includeFieldPerms?: boolean;
                    }


                    export
                    interface
                    GetFieldsUsageRequest
                    {
                        tableId: string;
                        skip?: number;
                        top?: number;
                    }


                    export
                    interface
                    UpdateFieldOperationRequest
                    {
                        tableId: string;
                        fieldId: number;
                        generated?: UpdateFieldRequest;
                    }


                    /**
                     * FieldsApi - interface
                     * 
                     * @export
                     * @interface FieldsApiInterface
                     */
                    export
                    interface
                    FieldsApiInterface
                    {
                        /**
                         * Creates a field within a table, including the custom permissions of that field.
                         * @summary Create a field
                         * @param {string} tableId The unique identifier of the table.
                         * @param {CreateFieldRequest} [generated] 
                         * @param {*} [options] Override http request option.
                         * @throws {RequiredError}
                         * @memberof FieldsApiInterface
                         */
                        createFieldRaw(requestParameters: CreateFieldOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateField200Response>>;

                        /**
                         * Creates a field within a table, including the custom permissions of that field.
                         * Create a field
                         */
                        createField(requestParameters: CreateFieldOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateField200Response>;

                        /**
                         * Deletes one or many fields in a table, based on field id. This will also permanently delete any data or calculations in that field.
                         * @summary Delete field(s)
                         * @param {string} tableId The unique identifier of the table.
                         * @param {DeleteFieldsRequest} [generated] 
                         * @param {*} [options] Override http request option.
                         * @throws {RequiredError}
                         * @memberof FieldsApiInterface
                         */
                        deleteFieldsRaw(requestParameters: DeleteFieldsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteFields200Response>>;

                        /**
                         * Deletes one or many fields in a table, based on field id. This will also permanently delete any data or calculations in that field.
                         * Delete field(s)
                         */
                        deleteFields(requestParameters: DeleteFieldsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteFields200Response>;

                        /**
                         * Gets the properties of an individual field, based on field id.   Properties present on all field types are returned at the top level. Properties unique to a specific type of field are returned under the \'properties\' attribute. Please see [Field types page](../fieldInfo) for more details on the properties for each field type.
                         * @summary Get field
                         * @param {string} tableId The unique identifier (dbid) of the table.
                         * @param {number} fieldId The unique identifier (fid) of the field.
                         * @param {boolean} [includeFieldPerms] Set to \&#39;true\&#39; if you\&#39;d like to get back the custom permissions for the field(s).
                         * @param {*} [options] Override http request option.
                         * @throws {RequiredError}
                         * @memberof FieldsApiInterface
                         */
                        getFieldRaw(requestParameters: GetFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetField200Response>>;

                        /**
                         * Gets the properties of an individual field, based on field id.   Properties present on all field types are returned at the top level. Properties unique to a specific type of field are returned under the \'properties\' attribute. Please see [Field types page](../fieldInfo) for more details on the properties for each field type.
                         * Get field
                         */
                        getField(requestParameters: GetFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetField200Response>;

                        /**
                         * Get a single fields usage statistics. This is a summary of the information that can be found in the usage table of field properties.
                         * @summary Get usage for a field
                         * @param {string} tableId The unique identifier (dbid) of the table.
                         * @param {number} fieldId The unique identifier (fid) of the field.
                         * @param {*} [options] Override http request option.
                         * @throws {RequiredError}
                         * @memberof FieldsApiInterface
                         */
                        getFieldUsageRaw(requestParameters: GetFieldUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetFieldUsage200Response>>;

                        /**
                         * Get a single fields usage statistics. This is a summary of the information that can be found in the usage table of field properties.
                         * Get usage for a field
                         */
                        getFieldUsage(requestParameters: GetFieldUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetFieldUsage200Response>;

                        /**
                         * Gets the properties for all fields in a specific table. The properties for each field are the same as in Get field.
                         * @summary Get fields for a table
                         * @param {string} tableId The unique identifier (dbid) of the table.
                         * @param {boolean} [includeFieldPerms] Set to \&#39;true\&#39; if you\&#39;d like to get back the custom permissions for the field(s).
                         * @param {*} [options] Override http request option.
                         * @throws {RequiredError}
                         * @memberof FieldsApiInterface
                         */
                        getFieldsRaw(requestParameters: GetFieldsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetFields200Response>>;

                        /**
                         * Gets the properties for all fields in a specific table. The properties for each field are the same as in Get field.
                         * Get fields for a table
                         */
                        getFields(requestParameters: GetFieldsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetFields200Response>;

                        /**
                         * Get all the field usage statistics for a table. This is a summary of the information that can be found in the usage table of field properties.
                         * @summary Get usage for all fields
                         * @param {string} tableId The unique identifier (dbid) of the table.
                         * @param {number} [skip] The number of fields to skip from the list.
                         * @param {number} [top] The maximum number of fields to return.
                         * @param {*} [options] Override http request option.
                         * @throws {RequiredError}
                         * @memberof FieldsApiInterface
                         */
                        getFieldsUsageRaw(requestParameters: GetFieldsUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetFieldsUsage200Response>>;

                        /**
                         * Get all the field usage statistics for a table. This is a summary of the information that can be found in the usage table of field properties.
                         * Get usage for all fields
                         */
                        getFieldsUsage(requestParameters: GetFieldsUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetFieldsUsage200Response>;

                        /**
                         * Updates the properties and custom permissions of a field. The attempt to update certain properties might cause existing data to no longer obey the field’s new properties and may be rejected. See the descriptions of required, unique, and choices, below, for specific situations. Any properties of the field that you do not specify in the request body will remain unchanged.
                         * @summary Update a field
                         * @param {string} tableId The unique identifier of the table.
                         * @param {number} fieldId The unique identifier (fid) of the field.
                         * @param {UpdateFieldRequest} [generated] 
                         * @param {*} [options] Override http request option.
                         * @throws {RequiredError}
                         * @memberof FieldsApiInterface
                         */
                        updateFieldRaw(requestParameters: UpdateFieldOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateField200Response>>;

                        /**
                         * Updates the properties and custom permissions of a field. The attempt to update certain properties might cause existing data to no longer obey the field’s new properties and may be rejected. See the descriptions of required, unique, and choices, below, for specific situations. Any properties of the field that you do not specify in the request body will remain unchanged.
                         * Update a field
                         */
                        updateField(requestParameters: UpdateFieldOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateField200Response>;

                    }


                    /**
                     * 
                     */
                    export
                    class
                    FieldsApi
                    extends
                    runtime.BaseAPI
                    implements
                    FieldsApiInterface
                    {

                        /**
                         * Creates a field within a table, including the custom permissions of that field.
                         * Create a field
                         */
                        async createFieldRaw(requestParameters: CreateFieldOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateField200Response>> {
                            if (requestParameters['tableId'] == null) {
                                throw new runtime.RequiredError(
                                    'tableId',
                                    'Required parameter "tableId" was null or undefined when calling createField().'
                                );
                            }

                            const queryParameters: any = {};

                            if (requestParameters['tableId'] != null) {
                                queryParameters['tableId'] = requestParameters['tableId'];
                            }

                            const headerParameters: runtime.HTTPHeaders = {};

                            headerParameters['Content-Type'] = 'application/json';

                            const response = await this.request({
                                path: `/fields`,
                                method: 'POST',
                                headers: headerParameters,
                                query: queryParameters,
                                body: CreateFieldRequestToJSON(requestParameters['generated']),
                            }, initOverrides);

                            return new runtime.JSONApiResponse(response, (jsonValue) => CreateField200ResponseFromJSON(jsonValue));
                        }

                        /**
                         * Creates a field within a table, including the custom permissions of that field.
                         * Create a field
                         */
                        async createField(requestParameters: CreateFieldOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateField200Response> {
                            const response = await this.createFieldRaw(requestParameters, initOverrides);
                            return await response.value();
                        }

                        /**
                         * Deletes one or many fields in a table, based on field id. This will also permanently delete any data or calculations in that field.
                         * Delete field(s)
                         */
                        async deleteFieldsRaw(requestParameters: DeleteFieldsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteFields200Response>> {
                            if (requestParameters['tableId'] == null) {
                                throw new runtime.RequiredError(
                                    'tableId',
                                    'Required parameter "tableId" was null or undefined when calling deleteFields().'
                                );
                            }

                            const queryParameters: any = {};

                            if (requestParameters['tableId'] != null) {
                                queryParameters['tableId'] = requestParameters['tableId'];
                            }

                            const headerParameters: runtime.HTTPHeaders = {};

                            headerParameters['Content-Type'] = 'application/json';

                            const response = await this.request({
                                path: `/fields`,
                                method: 'DELETE',
                                headers: headerParameters,
                                query: queryParameters,
                                body: DeleteFieldsRequestToJSON(requestParameters['generated']),
                            }, initOverrides);

                            return new runtime.JSONApiResponse(response, (jsonValue) => DeleteFields200ResponseFromJSON(jsonValue));
                        }

                        /**
                         * Deletes one or many fields in a table, based on field id. This will also permanently delete any data or calculations in that field.
                         * Delete field(s)
                         */
                        async deleteFields(requestParameters: DeleteFieldsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteFields200Response> {
                            const response = await this.deleteFieldsRaw(requestParameters, initOverrides);
                            return await response.value();
                        }

                        /**
                         * Gets the properties of an individual field, based on field id.   Properties present on all field types are returned at the top level. Properties unique to a specific type of field are returned under the \'properties\' attribute. Please see [Field types page](../fieldInfo) for more details on the properties for each field type.
                         * Get field
                         */
                        async getFieldRaw(requestParameters: GetFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetField200Response>> {
                            if (requestParameters['tableId'] == null) {
                                throw new runtime.RequiredError(
                                    'tableId',
                                    'Required parameter "tableId" was null or undefined when calling getField().'
                                );
                            }

                            if (requestParameters['fieldId'] == null) {
                                throw new runtime.RequiredError(
                                    'fieldId',
                                    'Required parameter "fieldId" was null or undefined when calling getField().'
                                );
                            }

                            const queryParameters: any = {};

                            if (requestParameters['tableId'] != null) {
                                queryParameters['tableId'] = requestParameters['tableId'];
                            }

                            if (requestParameters['includeFieldPerms'] != null) {
                                queryParameters['includeFieldPerms'] = requestParameters['includeFieldPerms'];
                            }

                            const headerParameters: runtime.HTTPHeaders = {};

                            const response = await this.request({
                                path: `/fields/{fieldId}`.replace(`{${"fieldId"}}`, encodeURIComponent(String(requestParameters['fieldId']))),
                                method: 'GET',
                                headers: headerParameters,
                                query: queryParameters,
                            }, initOverrides);

                            return new runtime.JSONApiResponse(response, (jsonValue) => GetField200ResponseFromJSON(jsonValue));
                        }

                        /**
                         * Gets the properties of an individual field, based on field id.   Properties present on all field types are returned at the top level. Properties unique to a specific type of field are returned under the \'properties\' attribute. Please see [Field types page](../fieldInfo) for more details on the properties for each field type.
                         * Get field
                         */
                        async getField(requestParameters: GetFieldRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetField200Response> {
                            const response = await this.getFieldRaw(requestParameters, initOverrides);
                            return await response.value();
                        }

                        /**
                         * Get a single fields usage statistics. This is a summary of the information that can be found in the usage table of field properties.
                         * Get usage for a field
                         */
                        async getFieldUsageRaw(requestParameters: GetFieldUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetFieldUsage200Response>> {
                            if (requestParameters['tableId'] == null) {
                                throw new runtime.RequiredError(
                                    'tableId',
                                    'Required parameter "tableId" was null or undefined when calling getFieldUsage().'
                                );
                            }

                            if (requestParameters['fieldId'] == null) {
                                throw new runtime.RequiredError(
                                    'fieldId',
                                    'Required parameter "fieldId" was null or undefined when calling getFieldUsage().'
                                );
                            }

                            const queryParameters: any = {};

                            if (requestParameters['tableId'] != null) {
                                queryParameters['tableId'] = requestParameters['tableId'];
                            }

                            const headerParameters: runtime.HTTPHeaders = {};

                            const response = await this.request({
                                path: `/fields/usage/{fieldId}`.replace(`{${"fieldId"}}`, encodeURIComponent(String(requestParameters['fieldId']))),
                                method: 'GET',
                                headers: headerParameters,
                                query: queryParameters,
                            }, initOverrides);

                            return new runtime.JSONApiResponse(response, (jsonValue) => GetFieldUsage200ResponseFromJSON(jsonValue));
                        }

                        /**
                         * Get a single fields usage statistics. This is a summary of the information that can be found in the usage table of field properties.
                         * Get usage for a field
                         */
                        async getFieldUsage(requestParameters: GetFieldUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetFieldUsage200Response> {
                            const response = await this.getFieldUsageRaw(requestParameters, initOverrides);
                            return await response.value();
                        }

                        /**
                         * Gets the properties for all fields in a specific table. The properties for each field are the same as in Get field.
                         * Get fields for a table
                         */
                        async getFieldsRaw(requestParameters: GetFieldsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetFields200Response>> {
                            if (requestParameters['tableId'] == null) {
                                throw new runtime.RequiredError(
                                    'tableId',
                                    'Required parameter "tableId" was null or undefined when calling getFields().'
                                );
                            }

                            const queryParameters: any = {};

                            if (requestParameters['tableId'] != null) {
                                queryParameters['tableId'] = requestParameters['tableId'];
                            }

                            if (requestParameters['includeFieldPerms'] != null) {
                                queryParameters['includeFieldPerms'] = requestParameters['includeFieldPerms'];
                            }

                            const headerParameters: runtime.HTTPHeaders = {};

                            const response = await this.request({
                                path: `/fields`,
                                method: 'GET',
                                headers: headerParameters,
                                query: queryParameters,
                            }, initOverrides);

                            return new runtime.JSONApiResponse(response, (jsonValue) => GetFields200ResponseFromJSON(jsonValue));
                        }

                        /**
                         * Gets the properties for all fields in a specific table. The properties for each field are the same as in Get field.
                         * Get fields for a table
                         */
                        async getFields(requestParameters: GetFieldsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetFields200Response> {
                            const response = await this.getFieldsRaw(requestParameters, initOverrides);
                            return await response.value();
                        }

                        /**
                         * Get all the field usage statistics for a table. This is a summary of the information that can be found in the usage table of field properties.
                         * Get usage for all fields
                         */
                        async getFieldsUsageRaw(requestParameters: GetFieldsUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetFieldsUsage200Response>> {
                            if (requestParameters['tableId'] == null) {
                                throw new runtime.RequiredError(
                                    'tableId',
                                    'Required parameter "tableId" was null or undefined when calling getFieldsUsage().'
                                );
                            }

                            const queryParameters: any = {};

                            if (requestParameters['tableId'] != null) {
                                queryParameters['tableId'] = requestParameters['tableId'];
                            }

                            if (requestParameters['skip'] != null) {
                                queryParameters['skip'] = requestParameters['skip'];
                            }

                            if (requestParameters['top'] != null) {
                                queryParameters['top'] = requestParameters['top'];
                            }

                            const headerParameters: runtime.HTTPHeaders = {};

                            const response = await this.request({
                                path: `/fields/usage`,
                                method: 'GET',
                                headers: headerParameters,
                                query: queryParameters,
                            }, initOverrides);

                            return new runtime.JSONApiResponse(response, (jsonValue) => GetFieldsUsage200ResponseFromJSON(jsonValue));
                        }

                        /**
                         * Get all the field usage statistics for a table. This is a summary of the information that can be found in the usage table of field properties.
                         * Get usage for all fields
                         */
                        async getFieldsUsage(requestParameters: GetFieldsUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetFieldsUsage200Response> {
                            const response = await this.getFieldsUsageRaw(requestParameters, initOverrides);
                            return await response.value();
                        }

                        /**
                         * Updates the properties and custom permissions of a field. The attempt to update certain properties might cause existing data to no longer obey the field’s new properties and may be rejected. See the descriptions of required, unique, and choices, below, for specific situations. Any properties of the field that you do not specify in the request body will remain unchanged.
                         * Update a field
                         */
                        async updateFieldRaw(requestParameters: UpdateFieldOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateField200Response>> {
                            if (requestParameters['tableId'] == null) {
                                throw new runtime.RequiredError(
                                    'tableId',
                                    'Required parameter "tableId" was null or undefined when calling updateField().'
                                );
                            }

                            if (requestParameters['fieldId'] == null) {
                                throw new runtime.RequiredError(
                                    'fieldId',
                                    'Required parameter "fieldId" was null or undefined when calling updateField().'
                                );
                            }

                            const queryParameters: any = {};

                            if (requestParameters['tableId'] != null) {
                                queryParameters['tableId'] = requestParameters['tableId'];
                            }

                            const headerParameters: runtime.HTTPHeaders = {};

                            headerParameters['Content-Type'] = 'application/json';

                            const response = await this.request({
                                path: `/fields/{fieldId}`.replace(`{${"fieldId"}}`, encodeURIComponent(String(requestParameters['fieldId']))),
                                method: 'POST',
                                headers: headerParameters,
                                query: queryParameters,
                                body: UpdateFieldRequestToJSON(requestParameters['generated']),
                            }, initOverrides);

                            return new runtime.JSONApiResponse(response, (jsonValue) => UpdateField200ResponseFromJSON(jsonValue));
                        }

                        /**
                         * Updates the properties and custom permissions of a field. The attempt to update certain properties might cause existing data to no longer obey the field’s new properties and may be rejected. See the descriptions of required, unique, and choices, below, for specific situations. Any properties of the field that you do not specify in the request body will remain unchanged.
                         * Update a field
                         */
                        async updateField(requestParameters: UpdateFieldOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateField200Response> {
                            const response = await this.updateFieldRaw(requestParameters, initOverrides);
                            return await response.value();
                        }

                    }
                - name: >-
                    FilesApi.ts
                  type: >-
                    file
                - name: >-
                    FormulasApi.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticsApi.ts
                  type: >-
                    file
                - name: >-
                    RecordsApi.ts
                  type: >-
                    file
                - name: >-
                    ReportsApi.ts
                  type: >-
                    file
                - name: >-
                    SolutionsApi.ts
                  type: >-
                    file
                - name: >-
                    TablesApi.ts
                  type: >-
                    file
                - name: >-
                    UserTokenApi.ts
                  type: >-
                    file
                - name: >-
                    UsersApi.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
            - name: >-
                index.ts
              type: >-
                file
            - name: >-
                models
              type: >-
                directory
              children:
                - name: >-
                    AddManagersToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddManagersToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    AddMembersToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddMembersToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    AddSubgroupsToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddSubgroupsToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    Audit200Response.ts
                  type: >-
                    file
                - name: >-
                    Audit202Response.ts
                  type: >-
                    file
                - name: >-
                    AuditRequest.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200ResponseInnerChangesInnerInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution404Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CloneUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    CloneUserTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    CopyApp200Response.ts
                  type: >-
                    file
                - name: >-
                    CopyAppRequest.ts
                  type: >-
                    file
                - name: >-
                    CopyAppRequestProperties.ts
                  type: >-
                    file
                - name: >-
                    CreateApp200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateAppRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateField200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateFieldRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateFieldRequestProperties.ts
                  type: >-
                    file
                - name: >-
                    CreateRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateRelationshipRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInnerCreatedResourcesInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInnerCreatedResourcesInnerAppsInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CreateTable200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateTableRequest.ts
                  type: >-
                    file
                - name: >-
                    DeactivateUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteApp200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteAppRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteFields200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteFieldsRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteFile200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteRecords200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteRecordsRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteTable200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersAndGroups200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersAndGroupsRequest.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    DownloadFile200Response.ts
                  type: >-
                    file
                - name: >-
                    ExchangeSsoToken200Response.ts
                  type: >-
                    file
                - name: >-
                    ExchangeSsoTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution404Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    GenerateDocument200Response.ts
                  type: >-
                    file
                - name: >-
                    GetApp200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppEvents200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppEvents200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetAppTables200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppTables200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetField200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFieldUsage200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFieldUsage200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetFields200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFields200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetFieldsUsage200Response.ts
                  type: >-
                    file
                  contents: >-
                    /*
                    Auto-generated
                    by
                    post-process-generated.ts
                    */

                    import
                    {
                    GetFieldsUsage200ResponseItemsInner,
                    GetFieldsUsage200ResponseItemsInnerFromJSON,
                    GetFieldsUsage200ResponseItemsInnerToJSON
                    }
                    from
                    './GetFieldsUsage200ResponseItemsInner';


                    /**
                     * Response for getFieldsUsage
                     */
                    export
                    type
                    GetFieldsUsage200Response
                    =
                    GetFieldsUsage200ResponseItemsInner[];


                    /**
                     * Convert JSON to GetFieldsUsage200Response
                     */
                    export
                    function
                    GetFieldsUsage200ResponseFromJSON(json:
                    any):
                    GetFieldsUsage200Response
                    {
                      if (!json) return [];
                      return json.map(GetFieldsUsage200ResponseItemsInnerFromJSON);
                    }


                    /**
                     * Convert GetFieldsUsage200Response to JSON
                     */
                    export
                    function
                    GetFieldsUsage200ResponseToJSON(value?:
                    GetFieldsUsage200Response
                    |
                    null):
                    any
                    {
                      if (!value) return [];
                      return value.map(GetFieldsUsage200ResponseItemsInnerToJSON);
                    }
                - name: >-
                    GetFieldsUsage200ResponseItemsInner.ts
                  type: >-
                    file
                  contents: >-
                    /*
                    Auto-generated
                    by
                    post-process-generated.ts
                    */

                    import
                    {
                    mapValues
                    }
                    from
                    '../runtime';

                    import
                    {
                    Permission
                    }
                    from
                    './Permission';


                    /**
                     * Auto-generated model for GetFieldsUsage200ResponseItemsInner
                     */
                    export
                    interface
                    GetFieldsUsage200ResponseItemsInner
                    {
                      /**
                     * Basic information about the field.
                     * @type {object}
                     */
                      field: object;
                      /**
                     * Usage Information about the field.
                     * @type {object}
                     */
                      usage: object;
                      /**
                       * Allows additional unspecified properties
                       * @type {any}
                       */
                      [key: string]: any;
                    }


                    export
                    function
                    GetFieldsUsage200ResponseItemsInnerFromJSON(json:
                    any):
                    GetFieldsUsage200ResponseItemsInner
                    {
                      return json || {};
                    }


                    export
                    function
                    GetFieldsUsage200ResponseItemsInnerToJSON(value?:
                    GetFieldsUsage200ResponseItemsInner
                    |
                    null):
                    any
                    {
                      return value || {};
                    }
                - name: >-
                    GetRelationships200Response.ts
                  type: >-
                    file
                - name: >-
                    GetReport200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTable200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTableReports200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTableReports200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetTempTokenDBID200Response.ts
                  type: >-
                    file
                - name: >-
                    GetUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    GetUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    Permission.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200Response.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseMetadata.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseTotals.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseWhereInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummariesRequest.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummariesRequestWhereInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticReads200Response.ts
                  type: >-
                    file
                - name: >-
                    Record.ts
                  type: >-
                    file
                - name: >-
                    RecordValue.ts
                  type: >-
                    file
                - name: >-
                    RemoveManagersFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveManagersFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RemoveMembersFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveMembersFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RemoveSubgroupsFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveSubgroupsFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RunFormula200Response.ts
                  type: >-
                    file
                - name: >-
                    RunFormulaRequest.ts
                  type: >-
                    file
                - name: >-
                    RunQuery200Response.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequest.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestGroupByInner.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestOptions.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestSortByInner.ts
                  type: >-
                    file
                - name: >-
                    RunReport200Response.ts
                  type: >-
                    file
                - name: >-
                    TransferUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    TransferUserTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    UndenyUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    UndenyUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateApp200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateAppRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateField200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateFieldRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateRelationshipRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200ResponseInnerCreatedResourcesInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    UpdateTable200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateTableRequest.ts
                  type: >-
                    file
                - name: >-
                    Upsert200Response.ts
                  type: >-
                    file
                - name: >-
                    Upsert207Response.ts
                  type: >-
                    file
                - name: >-
                    Upsert400Response.ts
                  type: >-
                    file
                - name: >-
                    UpsertRequest.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
            - name: >-
                runtime.ts
              type: >-
                file
              contents: >
                /*
                tslint:disable
                */

                /*
                eslint-disable
                */

                /**
                 * Quick Base API
                 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
                 *
                 * The version of the OpenAPI document: 1.0.0
                 * 
                 *
                 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
                 * https://openapi-generator.tech
                 * Do not edit the class manually.
                 */


                export
                const
                BASE_PATH
                =
                "https://api.quickbase.com/v1".replace(/\/+$/,
                "");


                export
                interface
                ConfigurationParameters
                {
                    basePath?: string; // override base path
                    fetchApi?: FetchAPI; // override for fetch implementation
                    middleware?: Middleware[]; // middleware to apply before/after fetch requests
                    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
                    username?: string; // parameter for basic security
                    password?: string; // parameter for basic security
                    apiKey?: string | Promise<string> | ((name: string) => string | Promise<string>); // parameter for apiKey security
                    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
                    headers?: HTTPHeaders; //header params we want to use on every request
                    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
                }


                export
                class
                Configuration
                {
                    constructor(private configuration: ConfigurationParameters = {}) {}

                    set config(configuration: Configuration) {
                        this.configuration = configuration;
                    }

                    get basePath(): string {
                        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
                    }

                    get fetchApi(): FetchAPI | undefined {
                        return this.configuration.fetchApi;
                    }

                    get middleware(): Middleware[] {
                        return this.configuration.middleware || [];
                    }

                    get queryParamsStringify(): (params: HTTPQuery) => string {
                        return this.configuration.queryParamsStringify || querystring;
                    }

                    get username(): string | undefined {
                        return this.configuration.username;
                    }

                    get password(): string | undefined {
                        return this.configuration.password;
                    }

                    get apiKey(): ((name: string) => string | Promise<string>) | undefined {
                        const apiKey = this.configuration.apiKey;
                        if (apiKey) {
                            return typeof apiKey === 'function' ? apiKey : () => apiKey;
                        }
                        return undefined;
                    }

                    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
                        const accessToken = this.configuration.accessToken;
                        if (accessToken) {
                            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
                        }
                        return undefined;
                    }

                    get headers(): HTTPHeaders | undefined {
                        return this.configuration.headers;
                    }

                    get credentials(): RequestCredentials | undefined {
                        return this.configuration.credentials;
                    }
                }


                export
                const
                DefaultConfig
                =
                new
                Configuration();


                /**
                 * This is the base class for all generated API classes.
                 */
                export
                class
                BaseAPI
                {

                    private static readonly jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
                    private middleware: Middleware[];

                    constructor(protected configuration = DefaultConfig) {
                        this.middleware = configuration.middleware;
                    }

                    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
                        const next = this.clone<T>();
                        next.middleware = next.middleware.concat(...middlewares);
                        return next;
                    }

                    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
                        const middlewares = preMiddlewares.map((pre) => ({ pre }));
                        return this.withMiddleware<T>(...middlewares);
                    }

                    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
                        const middlewares = postMiddlewares.map((post) => ({ post }));
                        return this.withMiddleware<T>(...middlewares);
                    }

                    /**
                     * Check if the given MIME is a JSON MIME.
                     * JSON MIME examples:
                     *   application/json
                     *   application/json; charset=UTF8
                     *   APPLICATION/JSON
                     *   application/vnd.company+json
                     * @param mime - MIME (Multipurpose Internet Mail Extensions)
                     * @return True if the given MIME is JSON, false otherwise.
                     */
                    protected isJsonMime(mime: string | null | undefined): boolean {
                        if (!mime) {
                            return false;
                        }
                        return BaseAPI.jsonRegex.test(mime);
                    }

                    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
                        const { url, init } = await this.createFetchParams(context, initOverrides);
                        const response = await this.fetchApi(url, init);
                        if (response && (response.status >= 200 && response.status < 300)) {
                            return response;
                        }
                        throw new ResponseError(response, 'Response returned an error code');
                    }

                    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {
                        let url = this.configuration.basePath + context.path;
                        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                            // only add the querystring to the URL if there are query parameters.
                            // this is done to avoid urls ending with a "?" character which buggy webservers
                            // do not handle correctly sometimes.
                            url += '?' + this.configuration.queryParamsStringify(context.query);
                        }

                        const headers = Object.assign({}, this.configuration.headers, context.headers);
                        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

                        const initOverrideFn =
                            typeof initOverrides === "function"
                                ? initOverrides
                                : async () => initOverrides;

                        const initParams = {
                            method: context.method,
                            headers,
                            body: context.body,
                            credentials: this.configuration.credentials,
                        };

                        const overriddenInit: RequestInit = {
                            ...initParams,
                            ...(await initOverrideFn({
                                init: initParams,
                                context,
                            }))
                        };

                        let body: any;
                        if (isFormData(overriddenInit.body)
                            || (overriddenInit.body instanceof URLSearchParams)
                            || isBlob(overriddenInit.body)) {
                          body = overriddenInit.body;
                        } else if (this.isJsonMime(headers['Content-Type'])) {
                          body = JSON.stringify(overriddenInit.body);
                        } else {
                          body = overriddenInit.body;
                        }

                        const init: RequestInit = {
                            ...overriddenInit,
                            body
                        };

                        return { url, init };
                    }

                    private fetchApi = async (url: string, init: RequestInit) => {
                        let fetchParams = { url, init };
                        for (const middleware of this.middleware) {
                            if (middleware.pre) {
                                fetchParams = await middleware.pre({
                                    fetch: this.fetchApi,
                                    ...fetchParams,
                                }) || fetchParams;
                            }
                        }
                        let response: Response | undefined = undefined;
                        try {
                            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
                        } catch (e) {
                            for (const middleware of this.middleware) {
                                if (middleware.onError) {
                                    response = await middleware.onError({
                                        fetch: this.fetchApi,
                                        url: fetchParams.url,
                                        init: fetchParams.init,
                                        error: e,
                                        response: response ? response.clone() : undefined,
                                    }) || response;
                                }
                            }
                            if (response === undefined) {
                              if (e instanceof Error) {
                                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
                              } else {
                                throw e;
                              }
                            }
                        }
                        for (const middleware of this.middleware) {
                            if (middleware.post) {
                                response = await middleware.post({
                                    fetch: this.fetchApi,
                                    url: fetchParams.url,
                                    init: fetchParams.init,
                                    response: response.clone(),
                                }) || response;
                            }
                        }
                        return response;
                    }

                    /**
                     * Create a shallow clone of `this` by constructing a new instance
                     * and then shallow cloning data members.
                     */
                    private clone<T extends BaseAPI>(this: T): T {
                        const constructor = this.constructor as any;
                        const next = new constructor(this.configuration);
                        next.middleware = this.middleware.slice();
                        return next;
                    }
                };


                function
                isBlob(value:
                any):
                value
                is
                Blob
                {
                    return typeof Blob !== 'undefined' && value instanceof Blob;
                }


                function
                isFormData(value:
                any):
                value
                is
                FormData
                {
                    return typeof FormData !== "undefined" && value instanceof FormData;
                }


                export
                class
                ResponseError
                extends
                Error
                {
                    override name: "ResponseError" = "ResponseError";
                    constructor(public response: Response, msg?: string) {
                        super(msg);
                    }
                }


                export
                class
                FetchError
                extends
                Error
                {
                    override name: "FetchError" = "FetchError";
                    constructor(public cause: Error, msg?: string) {
                        super(msg);
                    }
                }


                export
                class
                RequiredError
                extends
                Error
                {
                    override name: "RequiredError" = "RequiredError";
                    constructor(public field: string, msg?: string) {
                        super(msg);
                    }
                }


                export
                const
                COLLECTION_FORMATS
                =
                {
                    csv: ",",
                    ssv: " ",
                    tsv: "\t",
                    pipes: "|",
                };


                export
                type
                FetchAPI
                =
                WindowOrWorkerGlobalScope['fetch'];


                export
                type
                Json
                =
                any;

                export
                type
                HTTPMethod
                =
                'GET'
                |
                'POST'
                |
                'PUT'
                |
                'PATCH'
                |
                'DELETE'
                |
                'OPTIONS'
                |
                'HEAD';

                export
                type
                HTTPHeaders
                =
                {
                [key:
                string]:
                string
                };

                export
                type
                HTTPQuery
                =
                {
                [key:
                string]:
                string
                |
                number
                |
                null
                |
                boolean
                |
                Array<string
                |
                number
                |
                null
                |
                boolean>
                |
                Set<string
                |
                number
                |
                null
                |
                boolean>
                |
                HTTPQuery
                };

                export
                type
                HTTPBody
                =
                Json
                |
                FormData
                |
                URLSearchParams;

                export
                type
                HTTPRequestInit
                =
                {
                headers?:
                HTTPHeaders;
                method:
                HTTPMethod;
                credentials?:
                RequestCredentials;
                body?:
                HTTPBody
                };

                export
                type
                ModelPropertyNaming
                =
                'camelCase'
                |
                'snake_case'
                |
                'PascalCase'
                |
                'original';


                export
                type
                InitOverrideFunction
                =
                (requestContext:
                {
                init:
                HTTPRequestInit,
                context:
                RequestOpts
                })
                =>
                Promise<RequestInit>


                export
                interface
                FetchParams
                {
                    url: string;
                    init: RequestInit;
                }


                export
                interface
                RequestOpts
                {
                    path: string;
                    method: HTTPMethod;
                    headers: HTTPHeaders;
                    query?: HTTPQuery;
                    body?: HTTPBody;
                }


                export
                function
                querystring(params:
                HTTPQuery,
                prefix:
                string
                =
                ''):
                string
                {
                    return Object.keys(params)
                        .map(key => querystringSingleKey(key, params[key], prefix))
                        .filter(part => part.length > 0)
                        .join('&');
                }


                function
                querystringSingleKey(key:
                string,
                value:
                string
                |
                number
                |
                null
                |
                undefined
                |
                boolean
                |
                Array<string
                |
                number
                |
                null
                |
                boolean>
                |
                Set<string
                |
                number
                |
                null
                |
                boolean>
                |
                HTTPQuery,
                keyPrefix:
                string
                =
                ''):
                string
                {
                    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
                    if (value instanceof Array) {
                        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
                            .join(`&${encodeURIComponent(fullKey)}=`);
                        return `${encodeURIComponent(fullKey)}=${multiValue}`;
                    }
                    if (value instanceof Set) {
                        const valueAsArray = Array.from(value);
                        return querystringSingleKey(key, valueAsArray, keyPrefix);
                    }
                    if (value instanceof Date) {
                        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
                    }
                    if (value instanceof Object) {
                        return querystring(value as HTTPQuery, fullKey);
                    }
                    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
                }


                export
                function
                exists(json:
                any,
                key:
                string)
                {
                    const value = json[key];
                    return value !== null && value !== undefined;
                }


                export
                function
                mapValues(data:
                any,
                fn:
                (item:
                any)
                =>
                any)
                {
                  return Object.keys(data).reduce(
                    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
                    {}
                  );
                }


                export
                function
                canConsumeForm(consumes:
                Consume[]):
                boolean
                {
                    for (const consume of consumes) {
                        if ('multipart/form-data' === consume.contentType) {
                            return true;
                        }
                    }
                    return false;
                }


                export
                interface
                Consume
                {
                    contentType: string;
                }


                export
                interface
                RequestContext
                {
                    fetch: FetchAPI;
                    url: string;
                    init: RequestInit;
                }


                export
                interface
                ResponseContext
                {
                    fetch: FetchAPI;
                    url: string;
                    init: RequestInit;
                    response: Response;
                }


                export
                interface
                ErrorContext
                {
                    fetch: FetchAPI;
                    url: string;
                    init: RequestInit;
                    error: unknown;
                    response?: Response;
                }


                export
                interface
                Middleware
                {
                    pre?(context: RequestContext): Promise<FetchParams | void>;
                    post?(context: ResponseContext): Promise<Response | void>;
                    onError?(context: ErrorContext): Promise<Response | void>;
                }


                export
                interface
                ApiResponse<T>
                {
                    raw: Response;
                    value(): Promise<T>;
                }


                export
                interface
                ResponseTransformer<T>
                {
                    (json: any): T;
                }


                export
                class
                JSONApiResponse<T>
                {
                    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

                    async value(): Promise<T> {
                        return this.transformer(await this.raw.json());
                    }
                }


                export
                class
                VoidApiResponse
                {
                    constructor(public raw: Response) {}

                    async value(): Promise<void> {
                        return undefined;
                    }
                }


                export
                class
                BlobApiResponse
                {
                    constructor(public raw: Response) {}

                    async value(): Promise<Blob> {
                        return await this.raw.blob();
                    };
                }


                export
                class
                TextApiResponse
                {
                    constructor(public raw: Response) {}

                    async value(): Promise<string> {
                        return await this.raw.text();
                    };
                }
        - name: >-
            generated-unified
          type: >-
            directory
          children:
            - name: >-
                QuickbaseClient.ts
              type: >-
                file
              contents: >
                //
                Generated
                on
                2025-03-25T22:56:49.051Z

                import
                {
                AddManagersToGroup200Response,
                AddManagersToGroupRequest,
                AddMembersToGroup200Response,
                AddMembersToGroupRequest,
                AddSubgroupsToGroup200Response,
                AddSubgroupsToGroupRequest,
                Audit200Response,
                ChangesetSolution200Response,
                ChangesetSolutionFromRecord200Response,
                CloneUserToken200Response,
                CopyApp200Response,
                CopyAppRequest,
                CreateApp200Response,
                CreateAppRequest,
                CreateField200Response,
                CreateFieldRequest,
                CreateRelationship200Response,
                CreateRelationshipRequest,
                CreateSolution200Response,
                CreateSolutionFromRecord200Response,
                CreateTable200Response,
                CreateTableRequest,
                DeactivateUserToken200Response,
                DeleteApp200Response,
                DeleteAppRequest,
                DeleteFields200Response,
                DeleteFieldsRequest,
                DeleteFile200Response,
                DeleteRecords200Response,
                DeleteRecordsRequest,
                DeleteRelationship200Response,
                DeleteTable200Response,
                DeleteUserToken200Response,
                DenyUsers200Response,
                DenyUsersAndGroups200Response,
                DenyUsersAndGroupsRequest,
                DenyUsersRequest,
                DownloadFile200Response,
                ExchangeSsoToken200Response,
                ExportSolution200Response,
                ExportSolutionToRecord200Response,
                GenerateDocument200Response,
                GetApp200Response,
                GetAppEvents200Response,
                GetAppTables200Response,
                GetField200Response,
                GetFieldUsage200Response,
                GetFields200Response,
                GetFieldsUsage200Response,
                GetRelationships200Response,
                GetReport200Response,
                GetTable200Response,
                GetTableReports200Response,
                GetTempTokenDBID200Response,
                GetUsers200Response,
                GetUsersRequest,
                PlatformAnalyticEventSummaries200Response,
                PlatformAnalyticReads200Response,
                RemoveManagersFromGroup200Response,
                RemoveManagersFromGroupRequest,
                RemoveMembersFromGroup200Response,
                RemoveMembersFromGroupRequest,
                RemoveSubgroupsFromGroup200Response,
                RemoveSubgroupsFromGroupRequest,
                RunFormula200Response,
                RunQuery200Response,
                RunQueryRequest,
                RunReport200Response,
                TransferUserToken200Response,
                UndenyUsers200Response,
                UndenyUsersRequest,
                UpdateApp200Response,
                UpdateAppRequest,
                UpdateField200Response,
                UpdateFieldRequest,
                UpdateRelationship200Response,
                UpdateRelationshipRequest,
                UpdateSolution200Response,
                UpdateSolutionToRecord200Response,
                UpdateTable200Response,
                UpdateTableRequest,
                Upsert200Response,
                Upsert207Response,
                UpsertRequest
                }
                from
                "../generated/models";


                export
                interface
                QuickbaseClient
                {
                  /**
                   * Create an app
                   *
                   * @param {Object} params - Object containing the parameters for createApp.
                   * @param {CreateAppRequest} [params.body] - No description provided. (Optional)
                   *   - **name** (`string`, required) - The name of the app.
                   *   - **description** (`string`, optional) - A description for the app.
                   *   - **assignToken** (`boolean`, required) - Whether to assign the user token.
                   *
                   * @returns {Promise<CreateApp200Response>} - Promise resolving to the createApp response.
                   *   - **name** (`string`, required) - The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this.
                   *   - **description** (`string`, optional) - The description for the app. If this property is left out, the app description will be blank.
                   *   - **created** (`string`, optional) - The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **updated** (`string`, optional) - The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **dateFormat** (`string`, optional) - A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/user-assistance/about_localizing_dates_numbers.html) to set the app’s date format.
                   *   - **timeZone** (`string`, optional) - A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/user-assistance/application_local_timezone.html) to set the application’s time zone.
                   *   - **memoryInfo** (`object`, optional) - Application memory info
                   *   - **id** (`string`, optional) - The unique identifier for this application.
                   *   - **hasEveryoneOnTheInternet** (`boolean`, optional) - Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/user-assistance/share_with_everyone_on_internet.html)
                   *   - **variables** (`any`, optional) - The app variables. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
                   *   - **dataClassification** (`string`, optional) - The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return “None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans.
                   *   - **securityProperties** (`object`, optional) - Security properties of the application
                   *
                   * @see https://developer.quickbase.com/operation/createApp - Official Quickbase API documentation
                   */
                  createApp: (params: { body?: CreateAppRequest }) => Promise<CreateApp200Response>;
                  /**
                   * Get an app
                   *
                   * @param {Object} params - Object containing the parameters for getApp.
                   * @param {string} params.appId - The unique identifier of an app
                   *
                   * @returns {Promise<GetApp200Response>} - Promise resolving to the getApp response.
                   *   - **ancestorId** (`string`, optional) - The id of the app from which this app was copied
                   *   - **name** (`string`, required) - The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this.
                   *   - **description** (`string`, optional) - The description for the app. If this property is left out, the app description will be blank.
                   *   - **created** (`string`, optional) - The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **updated** (`string`, optional) - The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **dateFormat** (`string`, optional) - A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/user-assistance/about_localizing_dates_numbers.html) to set the app’s date format.
                   *   - **timeZone** (`string`, optional) - A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/user-assistance/application_local_timezone.html) to set the application’s time zone.
                   *   - **memoryInfo** (`object`, optional) - Application memory info
                   *   - **id** (`string`, optional) - The unique identifier for this application.
                   *   - **hasEveryoneOnTheInternet** (`boolean`, optional) - Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/user-assistance/share_with_everyone_on_internet.html)
                   *   - **variables** (`any`, optional) - The app variables. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
                   *   - **dataClassification** (`string`, optional) - The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return “None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans.
                   *   - **securityProperties** (`object`, optional) - Security properties of the application
                   *
                   * @see https://developer.quickbase.com/operation/getApp - Official Quickbase API documentation
                   */
                  getApp: (params: { appId: string }) => Promise<GetApp200Response>;
                  /**
                   * Update an app
                   *
                   * @param {Object} params - Object containing the parameters for updateApp.
                   * @param {string} params.appId - The unique identifier of an app
                   * @param {UpdateAppRequest} [params.body] - No description provided. (Optional)
                   *   - **name** (`string`, required) - The name of the app.
                   *   - **description** (`string`, optional) - A description for the app.
                   *   - **assignToken** (`boolean`, required) - Whether to assign the user token.
                   *
                   * @returns {Promise<UpdateApp200Response>} - Promise resolving to the updateApp response.
                   *   - **ancestorId** (`string`, optional) - The id of the app from which this app was copied
                   *   - **name** (`string`, required) - The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this.
                   *   - **description** (`string`, optional) - The description for the app. If this property is left out, the app description will be blank.
                   *   - **created** (`string`, optional) - The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **updated** (`string`, optional) - The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **dateFormat** (`string`, optional) - A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/user-assistance/about_localizing_dates_numbers.html) to set the app’s date format.
                   *   - **timeZone** (`string`, optional) - A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/user-assistance/application_local_timezone.html) to set the application’s time zone.
                   *   - **memoryInfo** (`object`, optional) - Application memory info
                   *   - **id** (`string`, optional) - The unique identifier for this application.
                   *   - **hasEveryoneOnTheInternet** (`boolean`, optional) - Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/user-assistance/share_with_everyone_on_internet.html)
                   *   - **variables** (`any`, optional) - The app variables. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
                   *   - **dataClassification** (`string`, optional) - The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return “None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans.
                   *   - **securityProperties** (`object`, optional) - Security properties of the application
                   *
                   * @see https://developer.quickbase.com/operation/updateApp - Official Quickbase API documentation
                   */
                  updateApp: (params: { appId: string; body?: UpdateAppRequest }) => Promise<UpdateApp200Response>;
                  /**
                   * Delete an app
                   *
                   * @param {Object} params - Object containing the parameters for deleteApp.
                   * @param {string} params.appId - The unique identifier of an app
                   * @param {DeleteAppRequest} [params.body] - No description provided. (Optional)
                   *   - **name** (`string`, required) - The name of the app.
                   *   - **description** (`string`, optional) - A description for the app.
                   *   - **assignToken** (`boolean`, required) - Whether to assign the user token.
                   *
                   * @returns {Promise<DeleteApp200Response>} - Promise resolving to the deleteApp response.
                   *   - **deletedAppId** (`string`, optional) - An ID of deleted application.
                   *
                   * @see https://developer.quickbase.com/operation/deleteApp - Official Quickbase API documentation
                   */
                  deleteApp: (params: { appId: string; body?: DeleteAppRequest }) => Promise<DeleteApp200Response>;
                  /**
                   * Get app events
                   *
                   * @param {Object} params - Object containing the parameters for getAppEvents.
                   * @param {string} params.appId - The unique identifier of an app
                   *
                   * @returns {Promise<GetAppEvents200Response>} - Promise resolving to the getAppEvents response.
                   *   - **isActive** (`boolean`, optional) - Indication of whether current event is active.
                   *   - **type** (`string`, optional) - Type of an event.
                   *   - **name** (`string`, optional) - The name of the event. This property is not returned for automations.
                   *   - **url** (`string`, optional) - The url to automation that can be accessed from the browser. Only returned for automations.
                   *   - **owner** (`object`, optional) - The user that owns the event.
                   *   - **tableId** (`string`, optional) - The unique identifier of the table to which event belongs to.
                   *
                   * @see https://developer.quickbase.com/operation/getAppEvents - Official Quickbase API documentation
                   */
                  getAppEvents: (params: { appId: string }) => Promise<GetAppEvents200Response>;
                  /**
                   * Copy an app
                   *
                   * @param {Object} params - Object containing the parameters for copyApp.
                   * @param {string} params.appId - The unique identifier of an app
                   * @param {CopyAppRequest} [params.body] - No description provided. (Optional)
                   *   - **name** (`string`, required) - The name of the new app.
                   *   - **description** (`string`, optional) - A description for the new app.
                   *   - **properties** (`CopyAppRequestProperties`, optional) - Type: CopyAppRequestProperties
                   *
                   * @returns {Promise<CopyApp200Response>} - Promise resolving to the copyApp response.
                   *   - **name** (`string`, required) - The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this.
                   *   - **description** (`string`, optional) - The description for the app
                   *   - **created** (`string`, optional) - The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **updated** (`string`, optional) - The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **dateFormat** (`string`, optional) - A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/user-assistance/about_localizing_dates_numbers.html) to set the app’s date format.
                   *   - **timeZone** (`string`, optional) - A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/user-assistance/application_local_timezone.html) to set the application’s time zone.
                   *   - **id** (`string`, optional) - The unique identifier for this application.
                   *   - **hasEveryoneOnTheInternet** (`boolean`, optional) - Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/user-assistance/share_with_everyone_on_internet.html)
                   *   - **variables** (`any`, optional) - The app variables. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
                   *   - **ancestorId** (`string`, optional) - The id of the app from which this app was copied
                   *   - **dataClassification** (`string`, optional) - The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return “None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans.
                   *
                   * @see https://developer.quickbase.com/operation/copyApp - Official Quickbase API documentation
                   */
                  copyApp: (params: { appId: string; body?: CopyAppRequest }) => Promise<CopyApp200Response>;
                  /**
                   * Create a table
                   *
                   * @param {Object} params - Object containing the parameters for createTable.
                   * @param {string} params.appId - The unique identifier of an app
                   * @param {CreateTableRequest} [params.body] - No description provided. (Optional)
                   *   - **name** (`string`, required) - The name for the table.
                   *   - **description** (`string`, optional) - The description for the table...
                   *   - **singleRecordName** (`string`, optional) - The singular noun for records...
                   *   - **pluralRecordName** (`string`, optional) - The plural noun for records...
                   *
                   * @returns {Promise<CreateTable200Response>} - Promise resolving to the createTable response.
                   *   - **name** (`string`, optional) - The name of the table.
                   *   - **id** (`string`, optional) - The unique identifier (dbid) of the table.
                   *   - **alias** (`string`, optional) - The automatically-created table alias for the table.
                   *   - **description** (`string`, optional) - The description of the table, as configured by an application administrator.
                   *   - **created** (`string`, optional) - The time and date when the table was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **updated** (`string`, optional) - The time and date when the table schema or data was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **nextRecordId** (`number`, optional) - The incremental Record ID that will be used when the next record is created, as determined when the API call was ran.
                   *   - **nextFieldId** (`number`, optional) - The incremental Field ID that will be used when the next field is created, as determined when the API call was ran.
                   *   - **defaultSortFieldId** (`number`, optional) - The id of the field that is configured for default sorting.
                   *   - **defaultSortOrder** (`string`, optional) - The configuration of the default sort order on the table.
                   *   - **keyFieldId** (`number`, optional) - The id of the field that is configured to be the key on this table, which is usually the Quickbase Record ID.
                   *   - **singleRecordName** (`string`, optional) - The builder-configured singular noun of the table.
                   *   - **pluralRecordName** (`string`, optional) - The builder-configured plural noun of the table.
                   *   - **sizeLimit** (`string`, optional) - The size limit for the table.
                   *   - **spaceUsed** (`string`, optional) - The amount of space currently being used by the table.
                   *   - **spaceRemaining** (`string`, optional) - The amount of space remaining for use by the table.
                   *
                   * @see https://developer.quickbase.com/operation/createTable - Official Quickbase API documentation
                   */
                  createTable: (params: { appId: string; body?: CreateTableRequest }) => Promise<CreateTable200Response>;
                  /**
                   * Get tables for an app
                   *
                   * @param {Object} params - Object containing the parameters for getAppTables.
                   * @param {string} params.appId - The unique identifier of an app
                   *
                   * @returns {Promise<GetAppTables200Response>} - Promise resolving to the getAppTables response.
                   *   - **name** (`string`, optional) - The name of the table.
                   *   - **id** (`string`, optional) - The unique identifier (dbid) of the table.
                   *   - **alias** (`string`, optional) - The automatically-created table alias for the table.
                   *   - **description** (`string`, optional) - The description of the table, as configured by an application administrator.
                   *   - **created** (`string`, optional) - The time and date when the table was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **updated** (`string`, optional) - The time and date when the table schema or data was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **nextRecordId** (`number`, optional) - The incremental Record ID that will be used when the next record is created, as determined when the API call was ran.
                   *   - **nextFieldId** (`number`, optional) - The incremental Field ID that will be used when the next field is created, as determined when the API call was ran.
                   *   - **defaultSortFieldId** (`number`, optional) - The id of the field that is configured for default sorting.
                   *   - **defaultSortOrder** (`string`, optional) - The configuration of the default sort order on the table.
                   *   - **keyFieldId** (`number`, optional) - The id of the field that is configured to be the key on this table, which is usually the Quickbase Record ID.
                   *   - **singleRecordName** (`string`, optional) - The builder-configured singular noun of the table.
                   *   - **pluralRecordName** (`string`, optional) - The builder-configured plural noun of the table.
                   *   - **sizeLimit** (`string`, optional) - The size limit for the table.
                   *   - **spaceUsed** (`string`, optional) - The amount of space currently being used by the table.
                   *   - **spaceRemaining** (`string`, optional) - The amount of space remaining for use by the table.
                   *
                   * @see https://developer.quickbase.com/operation/getAppTables - Official Quickbase API documentation
                   */
                  getAppTables: (params: { appId: string }) => Promise<GetAppTables200Response>;
                  /**
                   * Get a table
                   *
                   * @param {Object} params - Object containing the parameters for getTable.
                   * @param {string} params.appId - The unique identifier of an app
                   * @param {string} params.tableId - The unique identifier (dbid) of the table.
                   *
                   * @returns {Promise<GetTable200Response>} - Promise resolving to the getTable response.
                   *   - **name** (`string`, optional) - The name of the table.
                   *   - **id** (`string`, optional) - The unique identifier (dbid) of the table.
                   *   - **alias** (`string`, optional) - The automatically-created table alias for the table.
                   *   - **description** (`string`, optional) - The description of the table, as configured by an application administrator.
                   *   - **created** (`string`, optional) - The time and date when the table was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **updated** (`string`, optional) - The time and date when the table schema or data was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **nextRecordId** (`number`, optional) - The incremental Record ID that will be used when the next record is created, as determined when the API call was ran.
                   *   - **nextFieldId** (`number`, optional) - The incremental Field ID that will be used when the next field is created, as determined when the API call was ran.
                   *   - **defaultSortFieldId** (`number`, optional) - The id of the field that is configured for default sorting.
                   *   - **defaultSortOrder** (`string`, optional) - The configuration of the default sort order on the table.
                   *   - **keyFieldId** (`number`, optional) - The id of the field that is configured to be the key on this table, which is usually the Quickbase Record ID.
                   *   - **singleRecordName** (`string`, optional) - The builder-configured singular noun of the table.
                   *   - **pluralRecordName** (`string`, optional) - The builder-configured plural noun of the table.
                   *   - **sizeLimit** (`string`, optional) - The size limit for the table.
                   *   - **spaceUsed** (`string`, optional) - The amount of space currently being used by the table.
                   *   - **spaceRemaining** (`string`, optional) - The amount of space remaining for use by the table.
                   *
                   * @see https://developer.quickbase.com/operation/getTable - Official Quickbase API documentation
                   */
                  getTable: (params: { appId: string; tableId: string }) => Promise<GetTable200Response>;
                  /**
                   * Update a table
                   *
                   * @param {Object} params - Object containing the parameters for updateTable.
                   * @param {string} params.appId - The unique identifier of an app
                   * @param {string} params.tableId - The unique identifier (dbid) of the table.
                   * @param {UpdateTableRequest} [params.body] - No description provided. (Optional)
                   *   - **name** (`string`, optional) - The updated name of the table.
                   *   - **description** (`string`, optional) - The updated description for the table.
                   *
                   * @returns {Promise<UpdateTable200Response>} - Promise resolving to the updateTable response.
                   *   - **name** (`string`, optional) - The name of the table.
                   *   - **id** (`string`, optional) - The unique identifier (dbid) of the table.
                   *   - **alias** (`string`, optional) - The automatically-created table alias for the table.
                   *   - **description** (`string`, optional) - The description of the table, as configured by an application administrator.
                   *   - **created** (`string`, optional) - The time and date when the table was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **updated** (`string`, optional) - The time and date when the table schema or data was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **nextRecordId** (`number`, optional) - The incremental Record ID that will be used when the next record is created, as determined when the API call was ran.
                   *   - **nextFieldId** (`number`, optional) - The incremental Field ID that will be used when the next field is created, as determined when the API call was ran.
                   *   - **defaultSortFieldId** (`number`, optional) - The id of the field that is configured for default sorting.
                   *   - **defaultSortOrder** (`string`, optional) - The configuration of the default sort order on the table.
                   *   - **keyFieldId** (`number`, optional) - The id of the field that is configured to be the key on this table, which is usually the Quickbase Record ID.
                   *   - **singleRecordName** (`string`, optional) - The builder-configured singular noun of the table.
                   *   - **pluralRecordName** (`string`, optional) - The builder-configured plural noun of the table.
                   *   - **sizeLimit** (`string`, optional) - The size limit for the table.
                   *   - **spaceUsed** (`string`, optional) - The amount of space currently being used by the table.
                   *   - **spaceRemaining** (`string`, optional) - The amount of space remaining for use by the table.
                   *
                   * @see https://developer.quickbase.com/operation/updateTable - Official Quickbase API documentation
                   */
                  updateTable: (params: { appId: string; tableId: string; body?: UpdateTableRequest }) => Promise<UpdateTable200Response>;
                  /**
                   * Delete a table
                   *
                   * @param {Object} params - Object containing the parameters for deleteTable.
                   * @param {string} params.appId - The unique identifier of an app
                   * @param {string} params.tableId - The unique identifier (dbid) of the table.
                   *
                   * @returns {Promise<DeleteTable200Response>} - Promise resolving to the deleteTable response.
                   *   - **deletedTableId** (`string`, optional) - The deleted table id.
                   *
                   * @see https://developer.quickbase.com/operation/deleteTable - Official Quickbase API documentation
                   */
                  deleteTable: (params: { appId: string; tableId: string }) => Promise<DeleteTable200Response>;
                  /**
                   * Get all relationships
                   *
                   * @param {Object} params - Object containing the parameters for getRelationships.
                   * @param {number} [params.skip] - The number of relationships to skip. (Optional)
                   * @param {string} params.tableId - The unique identifier (dbid) of the child table.
                   *
                   * @returns {Promise<GetRelationships200Response>} - Promise resolving to the getRelationships response.
                   *   - **relationships** (`any`, required) - The relationships in a table.
                   *   - **metadata** (`object`, optional) - Additional information about the results that may be helpful.
                   *
                   * @see https://developer.quickbase.com/operation/getRelationships - Official Quickbase API documentation
                   */
                  getRelationships: (params: { skip?: number; tableId: string }) => Promise<GetRelationships200Response>;
                  /**
                   * Create a relationship
                   *
                   * @param {Object} params - Object containing the parameters for createRelationship.
                   * @param {string} params.tableId - The unique identifier (dbid) of the table. This will be the child table.
                   * @param {CreateRelationshipRequest} [params.body] - No description provided. (Optional)
                   *   - **parentTableId** (`string`, required) - The parent table id for the relationship.
                   *   - **foreignKeyField** (`{ [key: string]: any; }`, optional) - Type: { [key: string]: any; }
                   *   - **lookupFieldIds** (`number[]`, optional) - Array of field ids...
                   *   - **summaryFields** (`{ [key: string]: any; }[]`, optional) - Array of summary field objects...
                   *
                   * @returns {Promise<CreateRelationship200Response>} - Promise resolving to the createRelationship response.
                   *   - **id** (`number`, required) - The relationship id (foreign key field id).
                   *   - **parentTableId** (`string`, required) - The parent table id of the relationship.
                   *   - **childTableId** (`string`, required) - The child table id of the relationship.
                   *   - **foreignKeyField** (`object`, optional) - The foreign key field information.
                   *   - **isCrossApp** (`boolean`, required) - Whether this is a cross-app relationship.
                   *   - **lookupFields** (`any`, optional) - The lookup fields array.
                   *   - **summaryFields** (`any`, optional) - The summary fields array.
                   *
                   * @see https://developer.quickbase.com/operation/createRelationship - Official Quickbase API documentation
                   */
                  createRelationship: (params: { tableId: string; body?: CreateRelationshipRequest }) => Promise<CreateRelationship200Response>;
                  /**
                   * Update a relationship
                   *
                   * @param {Object} params - Object containing the parameters for updateRelationship.
                   * @param {string} params.tableId - The unique identifier (dbid) of the table. This will be the child table.
                   * @param {number} params.relationshipId - The relationship id. This is the field id of the reference field on the child table.
                   * @param {UpdateRelationshipRequest} [params.body] - No description provided. (Optional)
                   *   - **parentTableId** (`string`, optional) - The updated parent table id...
                   *   - **foreignKeyField** (`{ [key: string]: any; }`, optional) - Type: { [key: string]: any; }
                   *   - **lookupFieldIds** (`number[]`, optional) - Updated array of field ids...
                   *   - **summaryFields** (`{ [key: string]: any; }[]`, optional) - Type: { [key: string]: any; }[]
                   *
                   * @returns {Promise<UpdateRelationship200Response>} - Promise resolving to the updateRelationship response.
                   *   - **id** (`number`, required) - The relationship id (foreign key field id).
                   *   - **parentTableId** (`string`, required) - The parent table id of the relationship.
                   *   - **childTableId** (`string`, required) - The child table id of the relationship.
                   *   - **foreignKeyField** (`object`, optional) - The foreign key field information.
                   *   - **isCrossApp** (`boolean`, required) - Whether this is a cross-app relationship.
                   *   - **lookupFields** (`any`, optional) - The lookup fields array.
                   *   - **summaryFields** (`any`, optional) - The summary fields array.
                   *
                   * @see https://developer.quickbase.com/operation/updateRelationship - Official Quickbase API documentation
                   */
                  updateRelationship: (params: { tableId: string; relationshipId: number; body?: UpdateRelationshipRequest }) => Promise<UpdateRelationship200Response>;
                  /**
                   * Delete a relationship
                   *
                   * @param {Object} params - Object containing the parameters for deleteRelationship.
                   * @param {string} params.tableId - The unique identifier (dbid) of the table. This will be the child table.
                   * @param {number} params.relationshipId - The relationship id. This is the field id of the reference field on the child table.
                   *
                   * @returns {Promise<DeleteRelationship200Response>} - Promise resolving to the deleteRelationship response.
                   *   - **relationshipId** (`number`, required) - The relationship id.
                   *
                   * @see https://developer.quickbase.com/operation/deleteRelationship - Official Quickbase API documentation
                   */
                  deleteRelationship: (params: { tableId: string; relationshipId: number }) => Promise<DeleteRelationship200Response>;
                  /**
                   * Get reports for a table
                   *
                   * @param {Object} params - Object containing the parameters for getTableReports.
                   * @param {string} params.tableId - The unique identifier of the table.
                   *
                   * @returns {Promise<GetTableReports200Response>} - Promise resolving to the getTableReports response.
                   *   - **id** (`string`, optional) - The identifier of the report, unique to the table.
                   *   - **name** (`string`, optional) - The configured name of the report.
                   *   - **type** (`string`, optional) - The type of report in Quickbase (e.g., chart).
                   *   - **description** (`string`, optional) - The configured description of a report.
                   *   - **ownerId** (`number`, optional) - Optional, showed only for personal reports. The user ID of report owner.
                   *   - **query** (`object`, optional) - The query definition as configured in Quickbase that gets executed when the report is run.
                   *   - **properties** (`{ [key: string]: any; }`, optional) - A list of properties specific to the report type. To see a detailed description of the properties for each report type, See [Report Types.](../reportTypes)
                   *   - **usedLast** (`string`, optional) - The instant at which a report was last used.
                   *   - **usedCount** (`number`, optional) - The number of times a report has been used.
                   *
                   * @see https://developer.quickbase.com/operation/getTableReports - Official Quickbase API documentation
                   */
                  getTableReports: (params: { tableId: string }) => Promise<GetTableReports200Response>;
                  /**
                   * Get a report
                   *
                   * @param {Object} params - Object containing the parameters for getReport.
                   * @param {string} params.tableId - The unique identifier of table.
                   * @param {string} params.reportId - The identifier of the report, unique to the table.
                   *
                   * @returns {Promise<GetReport200Response>} - Promise resolving to the getReport response.
                   *   - **id** (`string`, optional) - The identifier of the report, unique to the table.
                   *   - **name** (`string`, optional) - The configured name of the report.
                   *   - **type** (`string`, optional) - The type of report in Quickbase (e.g., chart).
                   *   - **description** (`string`, optional) - The configured description of a report.
                   *   - **ownerId** (`number`, optional) - Optional, showed only for personal reports. The user ID of report owner.
                   *   - **query** (`object`, optional) - The query definition as configured in Quickbase that gets executed when the report is run.
                   *   - **properties** (`{ [key: string]: any; }`, optional) - A list of properties specific to the report type. To see a detailed description of the properties for each report type, See [Report Types.](../reportTypes)
                   *   - **usedLast** (`string`, optional) - The instant at which a report was last used.
                   *   - **usedCount** (`number`, optional) - The number of times a report has been used.
                   *
                   * @see https://developer.quickbase.com/operation/getReport - Official Quickbase API documentation
                   */
                  getReport: (params: { tableId: string; reportId: string }) => Promise<GetReport200Response>;
                  /**
                   * Run a report
                   *
                   * @param {Object} params - Object containing the parameters for runReport.
                   * @param {string} params.tableId - The identifier of the table for the report.
                   * @param {number} [params.skip] - The number of records to skip. You can set this value when paginating through a set of results. (Optional)
                   * @param {number} [params.top] - The maximum number of records to return. You can override the default Quickbase pagination to get more or fewer results. If your requested value here exceeds the dynamic maximums, we will return a subset of results and the rest can be gathered in subsequent API calls. (Optional)
                   * @param {string} params.reportId - The identifier of the report, unique to the table.
                   * @param {any} [params.body] - No description provided. (Optional)
                   *
                   * @returns {Promise<RunReport200Response>} - Promise resolving to the runReport response.
                   *   - **fields** (`any`, optional) - An array of objects that contains limited meta-data of each field displayed in the report. This assists in building logic that depends on field types and IDs.
                   *   - **data** (`any`, optional) - An array of objects that either represents the record data or summarized values, depending on the report type.
                   *   - **metadata** (`object`, optional) - Additional information about the results that may be helpful. Pagination may be needed if either you specify a smaller number of results to skip than is available, or if the API automatically returns fewer results. numRecords can be compared to totalRecords to determine if further pagination is needed.
                   *
                   * @see https://developer.quickbase.com/operation/runReport - Official Quickbase API documentation
                   */
                  runReport: (params: { tableId: string; skip?: number; top?: number; reportId: string; body?: any }) => Promise<RunReport200Response>;
                  /**
                   * Get fields for a table
                   *
                   * @param {Object} params - Object containing the parameters for getFields.
                   * @param {string} params.tableId - The unique identifier (dbid) of the table.
                   * @param {boolean} [params.includeFieldPerms] - Set to 'true' if you'd like to get back the custom permissions for the field(s). (Optional)
                   *
                   * @returns {Promise<GetFields200Response>} - Promise resolving to the getFields response.
                   *   - **id** (`number`, required) - The id of the field, unique to this table.
                   *   - **fieldType** (`string`, optional) - The type of field, as described [here](https://help.quickbase.com/user-assistance/field_types.html).
                   *   - **mode** (`string`, optional) - For derived fields, this will be 'lookup', 'summary', or 'formula', to indicate the type of derived field.  For non-derived fields, this will be blank.
                   *   - **label** (`string`, optional) - The label (name) of the field.
                   *   - **noWrap** (`boolean`, optional) - Indicates if the field is configured to not wrap when displayed in the product.
                   *   - **bold** (`boolean`, optional) - Indicates if the field is configured to display in bold in the product.
                   *   - **required** (`boolean`, optional) - Indicates if the field is marked required.
                   *   - **appearsByDefault** (`boolean`, optional) - Indicates if the field is marked as a default in reports.
                   *   - **findEnabled** (`boolean`, optional) - Indicates if the field is marked as searchable.
                   *   - **unique** (`boolean`, optional) - Indicates if the field is marked unique.
                   *   - **doesDataCopy** (`boolean`, optional) - Indicates if the field data will copy when a user copies the record.
                   *   - **fieldHelp** (`string`, optional) - The configured help text shown to users within the product.
                   *   - **audited** (`boolean`, optional) - Indicates if the field is being tracked as part of Quickbase Audit Logs.
                   *   - **properties** (`{ [key: string]: any; }`, optional) - Additional properties for the field. Please see [Field type details](../fieldInfo) page for more details on the properties for each field type.
                   *   - **permissions** (`Permission[]`, optional) - Field Permissions for different roles.
                   *     *   - **role** (`string`, required) - The role name
                   *     *   - **permissionType** (`string`, required) - Permission type (e.g., View, Modify)
                   *     *   - **roleId** (`number`, required) - The role identifier
                   *
                   * @see https://developer.quickbase.com/operation/getFields - Official Quickbase API documentation
                   */
                  getFields: (params: { tableId: string; includeFieldPerms?: boolean }) => Promise<GetFields200Response>;
                  /**
                   * Create a field
                   *
                   * @param {Object} params - Object containing the parameters for createField.
                   * @param {string} params.tableId - The unique identifier of the table.
                   * @param {CreateFieldRequest} [params.body] - No description provided. (Optional)
                   *   - **label** (`string`, required) - The label of the field
                   *   - **fieldType** (`CreateFieldRequestFieldTypeEnum`, required) - The type of the field
                   *   - **fieldHelp** (`string`, optional) - Help text for the field
                   *   - **addToForms** (`boolean`, optional) - Whether to add the field to forms
                   *   - **permissions** (`object`, optional) - Custom permissions for the field
                   *   - **required** (`boolean`, optional) - Whether the field is required
                   *   - **unique** (`boolean`, optional) - Whether the field must have unique values
                   *   - **noWrap** (`boolean`, optional) - Whether text wrapping is disabled
                   *   - **bold** (`boolean`, optional) - Whether the field is bolded
                   *   - **appearsByDefault** (`boolean`, optional) - Whether the field appears by default in reports
                   *   - **findEnabled** (`boolean`, optional) - Whether the field is searchable
                   *   - **doesDataCopy** (`boolean`, optional) - Whether the field copies data
                   *   - **audited** (`boolean`, optional) - Whether changes to the field are audited
                   *   - **properties** (`CreateFieldRequestProperties`, optional) - Type: CreateFieldRequestProperties
                   *
                   * @returns {Promise<CreateField200Response>} - Promise resolving to the createField response.
                   *   - **id** (`number`, required) - The id of the field, unique to this table.
                   *   - **fieldType** (`string`, optional) - The type of field, as described [here](https://help.quickbase.com/user-assistance/field_types.html).
                   *   - **mode** (`string`, optional) - For derived fields, this will be 'lookup', 'summary', or 'formula', to indicate the type of derived field.  For non-derived fields, this will be blank.
                   *   - **label** (`string`, optional) - The label (name) of the field.
                   *   - **noWrap** (`boolean`, optional) - Indicates if the field is configured to not wrap when displayed in the product.
                   *   - **bold** (`boolean`, optional) - Indicates if the field is configured to display in bold in the product.
                   *   - **required** (`boolean`, optional) - Indicates if the field is marked required.
                   *   - **appearsByDefault** (`boolean`, optional) - Indicates if the field is marked as a default in reports.
                   *   - **findEnabled** (`boolean`, optional) - Indicates if the field is marked as searchable.
                   *   - **unique** (`boolean`, optional) - Indicates if the field is marked unique.
                   *   - **doesDataCopy** (`boolean`, optional) - Indicates if the field data will copy when a user copies the record.
                   *   - **fieldHelp** (`string`, optional) - The configured help text shown to users within the product.
                   *   - **audited** (`boolean`, optional) - Indicates if the field is being tracked as part of Quickbase Audit Logs.
                   *   - **properties** (`{ [key: string]: any; }`, optional) - Additional properties for the field. Please see [Field type details](../fieldInfo) page for more details on the properties for each field type.
                   *   - **permissions** (`Permission[]`, optional) - Field Permissions for different roles.
                   *     *   - **role** (`string`, required) - The role name
                   *     *   - **permissionType** (`string`, required) - Permission type (e.g., View, Modify)
                   *     *   - **roleId** (`number`, required) - The role identifier
                   *
                   * @see https://developer.quickbase.com/operation/createField - Official Quickbase API documentation
                   */
                  createField: (params: { tableId: string; body?: CreateFieldRequest }) => Promise<CreateField200Response>;
                  /**
                   * Delete field(s)
                   *
                   * @param {Object} params - Object containing the parameters for deleteFields.
                   * @param {string} params.tableId - The unique identifier of the table.
                   * @param {DeleteFieldsRequest} [params.body] - No description provided. (Optional)
                   *   - **fieldIds** (`number[]`, required) - Type: number[]
                   *
                   * @returns {Promise<DeleteFields200Response>} - Promise resolving to the deleteFields response.
                   *   - **deletedFieldIds** (`any`, required) - List of field ids to were deleted.
                   *   - **errors** (`any`, required) - List of errors found.
                   *
                   * @see https://developer.quickbase.com/operation/deleteFields - Official Quickbase API documentation
                   */
                  deleteFields: (params: { tableId: string; body?: DeleteFieldsRequest }) => Promise<DeleteFields200Response>;
                  /**
                   * Get field
                   *
                   * @param {Object} params - Object containing the parameters for getField.
                   * @param {string} params.tableId - The unique identifier (dbid) of the table.
                   * @param {boolean} [params.includeFieldPerms] - Set to 'true' if you'd like to get back the custom permissions for the field(s). (Optional)
                   * @param {number} params.fieldId - The unique identifier (fid) of the field.
                   *
                   * @returns {Promise<GetField200Response>} - Promise resolving to the getField response.
                   *   - **id** (`number`, required) - The id of the field, unique to this table.
                   *   - **fieldType** (`string`, optional) - The type of field, as described [here](https://help.quickbase.com/user-assistance/field_types.html).
                   *   - **mode** (`string`, optional) - For derived fields, this will be 'lookup', 'summary', or 'formula', to indicate the type of derived field.  For non-derived fields, this will be blank.
                   *   - **label** (`string`, optional) - The label (name) of the field.
                   *   - **noWrap** (`boolean`, optional) - Indicates if the field is configured to not wrap when displayed in the product.
                   *   - **bold** (`boolean`, optional) - Indicates if the field is configured to display in bold in the product.
                   *   - **required** (`boolean`, optional) - Indicates if the field is marked required.
                   *   - **appearsByDefault** (`boolean`, optional) - Indicates if the field is marked as a default in reports.
                   *   - **findEnabled** (`boolean`, optional) - Indicates if the field is marked as searchable.
                   *   - **unique** (`boolean`, optional) - Indicates if the field is marked unique.
                   *   - **doesDataCopy** (`boolean`, optional) - Indicates if the field data will copy when a user copies the record.
                   *   - **fieldHelp** (`string`, optional) - The configured help text shown to users within the product.
                   *   - **audited** (`boolean`, optional) - Indicates if the field is being tracked as part of Quickbase Audit Logs.
                   *   - **properties** (`{ [key: string]: any; }`, optional) - Additional properties for the field. Please see [Field type details](../fieldInfo) page for more details on the properties for each field type.
                   *   - **permissions** (`Permission[]`, optional) - Field Permissions for different roles.
                   *     *   - **role** (`string`, required) - The role name
                   *     *   - **permissionType** (`string`, required) - Permission type (e.g., View, Modify)
                   *     *   - **roleId** (`number`, required) - The role identifier
                   *
                   * @see https://developer.quickbase.com/operation/getField - Official Quickbase API documentation
                   */
                  getField: (params: { tableId: string; includeFieldPerms?: boolean; fieldId: number }) => Promise<GetField200Response>;
                  /**
                   * Update a field
                   *
                   * @param {Object} params - Object containing the parameters for updateField.
                   * @param {string} params.tableId - The unique identifier of the table.
                   * @param {number} params.fieldId - The unique identifier (fid) of the field.
                   * @param {UpdateFieldRequest} [params.body] - No description provided. (Optional)
                   *   - **label** (`string`, required) - The label of the field
                   *   - **fieldType** (`UpdateFieldRequestFieldTypeEnum`, optional) - The type of the field
                   *   - **fieldHelp** (`string`, optional) - Help text for the field
                   *   - **addToForms** (`boolean`, optional) - Whether to add the field to forms
                   *   - **permissions** (`object`, optional) - Custom permissions for the field
                   *   - **required** (`boolean`, optional) - Whether the field is required
                   *   - **unique** (`boolean`, optional) - Whether the field must have unique values
                   *   - **noWrap** (`boolean`, optional) - Whether text wrapping is disabled
                   *   - **bold** (`boolean`, optional) - Whether the field is bolded
                   *   - **appearsByDefault** (`boolean`, optional) - Whether the field appears by default in reports
                   *   - **findEnabled** (`boolean`, optional) - Whether the field is searchable
                   *   - **doesDataCopy** (`boolean`, optional) - Whether the field copies data
                   *   - **audited** (`boolean`, optional) - Whether changes to the field are audited
                   *   - **properties** (`CreateFieldRequestProperties`, optional) - Type: CreateFieldRequestProperties
                   *
                   * @returns {Promise<UpdateField200Response>} - Promise resolving to the updateField response.
                   *   - **id** (`number`, required) - The id of the field, unique to this table.
                   *   - **fieldType** (`string`, optional) - The type of field, as described [here](https://help.quickbase.com/user-assistance/field_types.html).
                   *   - **mode** (`string`, optional) - For derived fields, this will be 'lookup', 'summary', or 'formula', to indicate the type of derived field.  For non-derived fields, this will be blank.
                   *   - **label** (`string`, optional) - The label (name) of the field.
                   *   - **noWrap** (`boolean`, optional) - Indicates if the field is configured to not wrap when displayed in the product.
                   *   - **bold** (`boolean`, optional) - Indicates if the field is configured to display in bold in the product.
                   *   - **required** (`boolean`, optional) - Indicates if the field is marked required.
                   *   - **appearsByDefault** (`boolean`, optional) - Indicates if the field is marked as a default in reports.
                   *   - **findEnabled** (`boolean`, optional) - Indicates if the field is marked as searchable.
                   *   - **unique** (`boolean`, optional) - Indicates if the field is marked unique.
                   *   - **doesDataCopy** (`boolean`, optional) - Indicates if the field data will copy when a user copies the record.
                   *   - **fieldHelp** (`string`, optional) - The configured help text shown to users within the product.
                   *   - **audited** (`boolean`, optional) - Indicates if the field is being tracked as part of Quickbase Audit Logs.
                   *   - **properties** (`{ [key: string]: any; }`, optional) - Additional properties for the field. Please see [Field type details](../fieldInfo) page for more details on the properties for each field type.
                   *   - **permissions** (`Permission[]`, optional) - Field Permissions for different roles.
                   *     *   - **role** (`string`, required) - The role name
                   *     *   - **permissionType** (`string`, required) - Permission type (e.g., View, Modify)
                   *     *   - **roleId** (`number`, required) - The role identifier
                   *
                   * @see https://developer.quickbase.com/operation/updateField - Official Quickbase API documentation
                   */
                  updateField: (params: { tableId: string; fieldId: number; body?: UpdateFieldRequest }) => Promise<UpdateField200Response>;
                  /**
                   * Get usage for all fields
                   *
                   * @param {Object} params - Object containing the parameters for getFieldsUsage.
                   * @param {string} params.tableId - The unique identifier (dbid) of the table.
                   * @param {number} [params.skip] - The number of fields to skip from the list. (Optional)
                   * @param {number} [params.top] - The maximum number of fields to return. (Optional)
                   *
                   * @returns {Promise<GetFieldsUsage200Response>} - Promise resolving to the getFieldsUsage response.
                   *   - **field** (`object`, required) - Basic information about the field.
                   *   - **usage** (`object`, required) - Usage Information about the field.
                   *
                   * @see https://developer.quickbase.com/operation/getFieldsUsage - Official Quickbase API documentation
                   */
                  getFieldsUsage: (params: { tableId: string; skip?: number; top?: number }) => Promise<GetFieldsUsage200Response>;
                  /**
                   * Get usage for a field
                   *
                   * @param {Object} params - Object containing the parameters for getFieldUsage.
                   * @param {string} params.tableId - The unique identifier (dbid) of the table.
                   * @param {number} params.fieldId - The unique identifier (fid) of the field.
                   *
                   * @returns {Promise<GetFieldUsage200Response>} - Promise resolving to the getFieldUsage response.
                   *   - **field** (`object`, required) - Basic information about the field.
                   *   - **usage** (`object`, required) - Usage Information about the field.
                   *
                   * @see https://developer.quickbase.com/operation/getFieldUsage - Official Quickbase API documentation
                   */
                  getFieldUsage: (params: { tableId: string; fieldId: number }) => Promise<GetFieldUsage200Response>;
                  /**
                   * Run a formula
                   *
                   * @param {Object} params - Object containing the parameters for runFormula.
                   * @param {{ formula?: string; rid?: number; from?: string }} [params.body] - No description provided. (Optional)
                   *
                   * @returns {Promise<RunFormula200Response>} - Promise resolving to the runFormula response.
                   *   - **result** (`string`, optional) - The formula execution result.
                   *
                   * @see https://developer.quickbase.com/operation/runFormula - Official Quickbase API documentation
                   */
                  runFormula: (params: { body?: { formula?: string; rid?: number; from?: string } }) => Promise<RunFormula200Response>;
                  /**
                   * Insert/Update record(s)
                   *
                   * @param {Object} params - Object containing the parameters for upsert.
                   * @param {UpsertRequest} [params.body] - No description provided. (Optional)
                   *   - **data** (`Record[]`, optional) - Type: Record[]
                   *   - **to** (`string`, optional) - Type: string
                   *   - **fieldsToReturn** (`number[]`, optional) - Type: number[]
                   *
                   * @returns {Promise<Upsert200Response | Upsert207Response>} - Promise resolving to the upsert response.
                   *   - **metadata** (`object`, optional) - Information about created records, updated records, referenced but unchanged records, and records having any errors while being processed.
                   *   - **data** (`any`, optional) - The data that is expected to be returned.
                   *   - **metadata** (`{ [key: string]: any; }`, optional) - Information about created records, updated records, referenced but unchanged records, and records having any errors while being processed.
                   *   - **data** (`string[]`, optional) - The data that is expected to be returned.
                   *
                   * @see https://developer.quickbase.com/operation/upsert - Official Quickbase API documentation
                   */
                  upsert: (params: { body?: UpsertRequest }) => Promise<Upsert200Response | Upsert207Response>;
                  /**
                   * Delete record(s)
                   *
                   * @param {Object} params - Object containing the parameters for deleteRecords.
                   * @param {DeleteRecordsRequest} [params.body] - No description provided. (Optional)
                   *   - **from** (`string`, required) - Type: string
                   *   - **where** (`string`, optional) - Type: string
                   *
                   * @returns {Promise<DeleteRecords200Response>} - Promise resolving to the deleteRecords response.
                   *   - **numberDeleted** (`number`, optional) - The number of records deleted.
                   *
                   * @see https://developer.quickbase.com/operation/deleteRecords - Official Quickbase API documentation
                   */
                  deleteRecords: (params: { body?: DeleteRecordsRequest }) => Promise<DeleteRecords200Response>;
                  /**
                   * Query for data
                   *
                   * @param {Object} params - Object containing the parameters for runQuery.
                   * @param {RunQueryRequest} [params.body] - No description provided. (Optional)
                   *   - **from** (`string`, required) - The table identifier.
                   *   - **select** (`number[]`, optional) - An array of field ids...
                   *   - **where** (`string`, optional) - The filter, using the Quickbase query language...
                   *   - **sortBy** (`RunQueryRequestSortByInner[]`, optional) - An array of field IDs and sort directions...
                   *   - **groupBy** (`RunQueryRequestGroupByInner[]`, optional) - An array that contains the fields to group the records by.
                   *   - **options** (`RunQueryRequestOptions`, optional) - Type: RunQueryRequestOptions
                   *
                   * @returns {Promise<RunQuery200Response>} - Promise resolving to the runQuery response.
                   *   - **fields** (`any`, optional) - An array of objects that contains limited meta-data of each field displayed in the report. This assists in building logic that depends on field types and IDs.
                   *   - **data** (`any`, optional) - An array of objects that either represents the record data or summarized values, depending on the report type.
                   *   - **metadata** (`object`, optional) - Additional information about the results that may be helpful. Pagination may be needed if either you specify a smaller number of results to skip than is available, or if the API automatically returns fewer results. numRecords can be compared to totalRecords to determine if further pagination is needed.
                   *
                   * @see https://developer.quickbase.com/operation/runQuery - Official Quickbase API documentation
                   */
                  runQuery: (params: { body?: RunQueryRequest }) => Promise<RunQuery200Response>;
                  /**
                   * Get a temporary token for a dbid
                   *
                   * @param {Object} params - Object containing the parameters for getTempTokenDBID.
                   * @param {string} params.dbid - The unique identifier of an app or table.
                   * @param {string} [params.qBAppToken] - Your Quickbase app token (Optional)
                   *
                   * @returns {Promise<GetTempTokenDBID200Response>} - Promise resolving to the getTempTokenDBID response.
                   *   - **temporaryAuthorization** (`string`, optional) - Temporary authorization token.
                   *
                   * @see https://developer.quickbase.com/operation/getTempTokenDBID - Official Quickbase API documentation
                   */
                  getTempTokenDBID: (params: { dbid: string; qBAppToken?: string }) => Promise<GetTempTokenDBID200Response>;
                  /**
                   * Exchange an SSO token
                   *
                   * @param {Object} params - Object containing the parameters for exchangeSsoToken.
                   * @param {{ grant_type?: string; requested_token_type?: string; subject_token?: string; subject_token_type?: string }} [params.body] - No description provided. (Optional)
                   *
                   * @returns {Promise<ExchangeSsoToken200Response>} - Promise resolving to the exchangeSsoToken response.
                   *   - **access_token** (`string`, optional) - The security token issued by the authorization server in response to the token exchange request. The identifier `access_token` is used for historical reasons and the issued token need not be an OAuth access token.
                   *   - **issued_token_type** (`string`, optional) - An identifier for the representation of the issued security token.
                   *   - **token_type** (`string`, optional) - Will always return `N_A`
                   *
                   * @see https://developer.quickbase.com/operation/exchangeSsoToken - Official Quickbase API documentation
                   */
                  exchangeSsoToken: (params: { body?: { grant_type?: string; requested_token_type?: string; subject_token?: string; subject_token_type?: string } }) => Promise<ExchangeSsoToken200Response>;
                  /**
                   * Clone a user token
                   *
                   * @param {Object} params - Object containing the parameters for cloneUserToken.
                   * @param {{ name?: string; description?: string }} [params.body] - No description provided. (Optional)
                   *
                   * @returns {Promise<CloneUserToken200Response>} - Promise resolving to the cloneUserToken response.
                   *   - **active** (`boolean`, optional) - Whether the user token is active.
                   *   - **apps** (`any`, optional) - The list of apps this user token is assigned to.
                   *   - **lastUsed** (`string`, optional) - The last date this user token was used, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **description** (`string`, optional) - User Token description.
                   *   - **id** (`number`, optional) - User Token id.
                   *   - **name** (`string`, optional) - User Token name.
                   *   - **token** (`string`, optional) - User Token value.
                   *
                   * @see https://developer.quickbase.com/operation/cloneUserToken - Official Quickbase API documentation
                   */
                  cloneUserToken: (params: { body?: { name?: string; description?: string } }) => Promise<CloneUserToken200Response>;
                  /**
                   * Transfer a user token
                   *
                   * @param {Object} params - Object containing the parameters for transferUserToken.
                   * @param {{ id?: number; from?: string; to?: string }} [params.body] - No description provided. (Optional)
                   *
                   * @returns {Promise<TransferUserToken200Response>} - Promise resolving to the transferUserToken response.
                   *   - **active** (`boolean`, optional) - Whether the user token is active.
                   *   - **apps** (`any`, optional) - The list of apps this user token is assigned to.
                   *   - **lastUsed** (`string`, optional) - The last date this user token was used, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
                   *   - **description** (`string`, optional) - User Token description.
                   *   - **id** (`number`, optional) - User Token id.
                   *   - **name** (`string`, optional) - User Token name.
                   *
                   * @see https://developer.quickbase.com/operation/transferUserToken - Official Quickbase API documentation
                   */
                  transferUserToken: (params: { body?: { id?: number; from?: string; to?: string } }) => Promise<TransferUserToken200Response>;
                  /**
                   * Deactivate a user token
                   *
                   * No parameters.
                   *
                   * @returns {Promise<DeactivateUserToken200Response>} - Promise resolving to the deactivateUserToken response.
                   *   - **id** (`number`, optional) - The user token id.
                   *
                   * @see https://developer.quickbase.com/operation/deactivateUserToken - Official Quickbase API documentation
                   */
                  deactivateUserToken: (params: {  }) => Promise<DeactivateUserToken200Response>;
                  /**
                   * Delete a user token
                   *
                   * No parameters.
                   *
                   * @returns {Promise<DeleteUserToken200Response>} - Promise resolving to the deleteUserToken response.
                   *   - **id** (`number`, optional) - The user token id.
                   *
                   * @see https://developer.quickbase.com/operation/deleteUserToken - Official Quickbase API documentation
                   */
                  deleteUserToken: (params: {  }) => Promise<DeleteUserToken200Response>;
                  /**
                   * Download file
                   *
                   * @param {Object} params - Object containing the parameters for downloadFile.
                   * @param {string} params.tableId - The unique identifier of the table.
                   * @param {number} params.recordId - The unique identifier of the record.
                   * @param {number} params.fieldId - The unique identifier of the field.
                   * @param {number} params.versionNumber - The file attachment version number.
                   *
                   * @returns {Promise<DownloadFile200Response>} - Promise resolving to the downloadFile response.
                   *   - **data** (`string`, optional) - Type: string
                   *
                   * @see https://developer.quickbase.com/operation/downloadFile - Official Quickbase API documentation
                   */
                  downloadFile: (params: { tableId: string; recordId: number; fieldId: number; versionNumber: number }) => Promise<DownloadFile200Response>;
                  /**
                   * Delete file
                   *
                   * @param {Object} params - Object containing the parameters for deleteFile.
                   * @param {string} params.tableId - The unique identifier of the table.
                   * @param {number} params.recordId - The unique identifier of the record.
                   * @param {number} params.fieldId - The unique identifier of the field.
                   * @param {number} params.versionNumber - The file attachment version number.
                   *
                   * @returns {Promise<DeleteFile200Response>} - Promise resolving to the deleteFile response.
                   *   - **versionNumber** (`number`, optional) - The number of deleted version.
                   *   - **fileName** (`string`, optional) - The name of file associated with deleted version.
                   *   - **uploaded** (`string`, optional) - The timestamp when the version was originally uploaded.
                   *   - **creator** (`object`, optional) - The user that uploaded version.
                   *
                   * @see https://developer.quickbase.com/operation/deleteFile - Official Quickbase API documentation
                   */
                  deleteFile: (params: { tableId: string; recordId: number; fieldId: number; versionNumber: number }) => Promise<DeleteFile200Response>;
                  /**
                   * Get users
                   *
                   * @param {Object} params - Object containing the parameters for getUsers.
                   * @param {number} [params.accountId] - The account id being used to get users. If no value is specified, the first account associated with the requesting user token is chosen. (Optional)
                   * @param {GetUsersRequest} [params.body] - No description provided. (Optional)
                   *   - **userIds** (`string[]`, required) - Type: string[]
                   *
                   * @returns {Promise<GetUsers200Response>} - Promise resolving to the getUsers response.
                   *   - **users** (`any`, required) - A list of users found in an account with the given criterias
                   *   - **metadata** (`object`, required) - Additional request information
                   *
                   * @see https://developer.quickbase.com/operation/getUsers - Official Quickbase API documentation
                   */
                  getUsers: (params: { accountId?: number; body?: GetUsersRequest }) => Promise<GetUsers200Response>;
                  /**
                   * Deny users
                   *
                   * @param {Object} params - Object containing the parameters for denyUsers.
                   * @param {number} [params.accountId] - The account id being used to deny users. If no value is specified, the first account associated with the requesting user token is chosen. (Optional)
                   * @param {DenyUsersRequest} [params.body] - No description provided. (Optional)
                   *   - **userIds** (`string[]`, required) - Type: string[]
                   *
                   * @returns {Promise<DenyUsers200Response>} - Promise resolving to the denyUsers response.
                   *   - **failure** (`any`, required) - A list of users that couldn't be denied. This also includes the ID's of users that are not valid.
                   *   - **success** (`any`, required) - A list of users that have successfully been denied.
                   *
                   * @see https://developer.quickbase.com/operation/denyUsers - Official Quickbase API documentation
                   */
                  denyUsers: (params: { accountId?: number; body?: DenyUsersRequest }) => Promise<DenyUsers200Response>;
                  /**
                   * Deny and remove users from groups
                   *
                   * @param {Object} params - Object containing the parameters for denyUsersAndGroups.
                   * @param {number} [params.accountId] - The account id being used to deny users. If no value is specified, the first account associated with the requesting user token is chosen. (Optional)
                   * @param {boolean} params.shouldDeleteFromGroups - Specifies if the users should also be removed from all groups.
                   * @param {DenyUsersAndGroupsRequest} [params.body] - No description provided. (Optional)
                   *   - **userIds** (`string[]`, required) - Type: string[]
                   *
                   * @returns {Promise<DenyUsersAndGroups200Response>} - Promise resolving to the denyUsersAndGroups response.
                   *   - **failure** (`any`, required) - A list of users that couldn't be denied. This also includes the ID's of users that are not valid.
                   *   - **success** (`any`, required) - A list of users that have successfully been denied.
                   *
                   * @see https://developer.quickbase.com/operation/denyUsersAndGroups - Official Quickbase API documentation
                   */
                  denyUsersAndGroups: (params: { accountId?: number; shouldDeleteFromGroups: boolean; body?: DenyUsersAndGroupsRequest }) => Promise<DenyUsersAndGroups200Response>;
                  /**
                   * Undeny users
                   *
                   * @param {Object} params - Object containing the parameters for undenyUsers.
                   * @param {number} [params.accountId] - The account id being used to undeny users. If no value is specified, the first account associated with the requesting user token is chosen. (Optional)
                   * @param {UndenyUsersRequest} [params.body] - No description provided. (Optional)
                   *   - **userIds** (`string[]`, required) - Type: string[]
                   *
                   * @returns {Promise<UndenyUsers200Response>} - Promise resolving to the undenyUsers response.
                   *   - **failure** (`any`, required) - A list of users that couldn't be undenied. This also includes the ID's of users that are not valid.
                   *   - **success** (`any`, required) - A list of users that have successfully been undenied.
                   *
                   * @see https://developer.quickbase.com/operation/undenyUsers - Official Quickbase API documentation
                   */
                  undenyUsers: (params: { accountId?: number; body?: UndenyUsersRequest }) => Promise<UndenyUsers200Response>;
                  /**
                   * Add members
                   *
                   * @param {Object} params - Object containing the parameters for addMembersToGroup.
                   * @param {number} params.gid - This is the ID of the group being modified.
                   * @param {AddMembersToGroupRequest} [params.body] - No description provided. (Optional)
                   *   - **userIds** (`string[]`, required) - Type: string[]
                   *
                   * @returns {Promise<AddMembersToGroup200Response>} - Promise resolving to the addMembersToGroup response.
                   *   - **failure** (`any`, required) - A list of users that couldn’t be added to the group. This includes a list of IDs that represent invalid users and users who have already been added to the group.
                   *   - **success** (`any`, required) - A list of users that have been added to the group successfully.
                   *
                   * @see https://developer.quickbase.com/operation/addMembersToGroup - Official Quickbase API documentation
                   */
                  addMembersToGroup: (params: { gid: number; body?: AddMembersToGroupRequest }) => Promise<AddMembersToGroup200Response>;
                  /**
                   * Remove members
                   *
                   * @param {Object} params - Object containing the parameters for removeMembersFromGroup.
                   * @param {number} params.gid - This is the ID of the group being modified.
                   * @param {RemoveMembersFromGroupRequest} [params.body] - No description provided. (Optional)
                   *   - **userIds** (`string[]`, required) - Type: string[]
                   *
                   * @returns {Promise<RemoveMembersFromGroup200Response>} - Promise resolving to the removeMembersFromGroup response.
                   *   - **failure** (`any`, required) - A list of users that couldn’t be removed from the group. This includes a list of IDs that represent invalid users.
                   *   - **success** (`any`, required) - A list of users that have been removed from the group successfully.
                   *
                   * @see https://developer.quickbase.com/operation/removeMembersFromGroup - Official Quickbase API documentation
                   */
                  removeMembersFromGroup: (params: { gid: number; body?: RemoveMembersFromGroupRequest }) => Promise<RemoveMembersFromGroup200Response>;
                  /**
                   * Add managers
                   *
                   * @param {Object} params - Object containing the parameters for addManagersToGroup.
                   * @param {number} params.gid - This is the ID of the group being modified.
                   * @param {AddManagersToGroupRequest} [params.body] - No description provided. (Optional)
                   *   - **userIds** (`string[]`, required) - Type: string[]
                   *
                   * @returns {Promise<AddManagersToGroup200Response>} - Promise resolving to the addManagersToGroup response.
                   *   - **failure** (`any`, required) - A list of users that couldn’t be added to the group. This includes a list of IDs that represent invalid users and users who have already been added to the group.
                   *   - **success** (`any`, required) - A list of users that have been added to the group successfully.
                   *
                   * @see https://developer.quickbase.com/operation/addManagersToGroup - Official Quickbase API documentation
                   */
                  addManagersToGroup: (params: { gid: number; body?: AddManagersToGroupRequest }) => Promise<AddManagersToGroup200Response>;
                  /**
                   * Remove managers
                   *
                   * @param {Object} params - Object containing the parameters for removeManagersFromGroup.
                   * @param {number} params.gid - This is the ID of the group being modified.
                   * @param {RemoveManagersFromGroupRequest} [params.body] - No description provided. (Optional)
                   *   - **userIds** (`string[]`, required) - Type: string[]
                   *
                   * @returns {Promise<RemoveManagersFromGroup200Response>} - Promise resolving to the removeManagersFromGroup response.
                   *   - **failure** (`any`, required) - A list of users that couldn’t be removed from the group. This includes a list of IDs that represent invalid users.
                   *   - **success** (`any`, required) - A list of users that have been removed from the group successfully.
                   *
                   * @see https://developer.quickbase.com/operation/removeManagersFromGroup - Official Quickbase API documentation
                   */
                  removeManagersFromGroup: (params: { gid: number; body?: RemoveManagersFromGroupRequest }) => Promise<RemoveManagersFromGroup200Response>;
                  /**
                   * Add child groups
                   *
                   * @param {Object} params - Object containing the parameters for addSubgroupsToGroup.
                   * @param {number} params.gid - This is the ID of the group being modified.
                   * @param {AddSubgroupsToGroupRequest} [params.body] - No description provided. (Optional)
                   *   - **userIds** (`string[]`, required) - Type: string[]
                   *
                   * @returns {Promise<AddSubgroupsToGroup200Response>} - Promise resolving to the addSubgroupsToGroup response.
                   *   - **failure** (`any`, required) - A list of child groups that couldn’t be added to the group. This includes a list of IDs that represent invalid groups and groups that have already been added to the group.
                   *   - **success** (`any`, required) - A list of child groups that have been added to the group successfully.
                   *
                   * @see https://developer.quickbase.com/operation/addSubgroupsToGroup - Official Quickbase API documentation
                   */
                  addSubgroupsToGroup: (params: { gid: number; body?: AddSubgroupsToGroupRequest }) => Promise<AddSubgroupsToGroup200Response>;
                  /**
                   * Remove child groups
                   *
                   * @param {Object} params - Object containing the parameters for removeSubgroupsFromGroup.
                   * @param {number} params.gid - This is the ID of the group being modified.
                   * @param {RemoveSubgroupsFromGroupRequest} [params.body] - No description provided. (Optional)
                   *   - **userIds** (`string[]`, required) - Type: string[]
                   *
                   * @returns {Promise<RemoveSubgroupsFromGroup200Response>} - Promise resolving to the removeSubgroupsFromGroup response.
                   *   - **failure** (`any`, required) - A list of child groups that couldn’t be removed from the group. This includes a list of IDs that represent invalid groups.
                   *   - **success** (`any`, required) - A list of child groups that have been removed from the group successfully.
                   *
                   * @see https://developer.quickbase.com/operation/removeSubgroupsFromGroup - Official Quickbase API documentation
                   */
                  removeSubgroupsFromGroup: (params: { gid: number; body?: RemoveSubgroupsFromGroupRequest }) => Promise<RemoveSubgroupsFromGroup200Response>;
                  /**
                   * Get audit logs
                   *
                   * @param {Object} params - Object containing the parameters for audit.
                   * @param {{ nextToken?: string; numRows?: number; queryId?: string; date?: string; topics?: string[] }} [params.body] - No description provided. (Optional)
                   *
                   * @returns {Promise<Audit200Response>} - Promise resolving to the audit response.
                   *   - **queryId** (`string`, required) - Query id of the requested audit log.
                   *   - **events** (`any`, optional) - All events of the audit log.
                   *   - **nextToken** (`string`, optional) - Token to fetch the next 1000 logs.
                   *
                   * @see https://developer.quickbase.com/operation/audit - Official Quickbase API documentation
                   */
                  audit: (params: { body?: { nextToken?: string; numRows?: number; queryId?: string; date?: string; topics?: string[] } }) => Promise<Audit200Response>;
                  /**
                   * Get read summaries
                   *
                   * @param {Object} params - Object containing the parameters for platformAnalyticReads.
                   * @param {string} [params.day] - The date for which read summaries need to be fetched. This must be date-time only, as YYYY-MM-DD, and a valid date in the past. (Optional)
                   *
                   * @returns {Promise<PlatformAnalyticReads200Response>} - Promise resolving to the platformAnalyticReads response.
                   *   - **date** (`string`, required) - The date of the requested summary.
                   *   - **reads** (`object`, required) - Total reads for the specified date.
                   *
                   * @see https://developer.quickbase.com/operation/platformAnalyticReads - Official Quickbase API documentation
                   */
                  platformAnalyticReads: (params: { day?: string }) => Promise<PlatformAnalyticReads200Response>;
                  /**
                   * Get event summaries
                   *
                   * @param {Object} params - Object containing the parameters for platformAnalyticEventSummaries.
                   * @param {number} [params.accountId] - The ID of the account to query. If no value is specified, the first account matching the provided domain is chosen. (Optional)
                   * @param {{ start?: string; end?: string; groupBy?: string; nextToken?: string; where?: { id?: string; type?: string }[] }} [params.body] - No description provided. (Optional)
                   *
                   * @returns {Promise<PlatformAnalyticEventSummaries200Response>} - Promise resolving to the platformAnalyticEventSummaries response.
                   *   - **accountId** (`string`, required) - The ID of the account the events are associated with.
                   *   - **start** (`string`, required) - The start date and time of the requested summaries in ISO 8601 time format.
                   *   - **end** (`string`, required) - The end date and time of the requested summaries in ISO 8601 time format.
                   *   - **groupBy** (`string`, required) - How the events should be grouped.
                   *   - **where** (`any`, required) - Type: any
                   *   - **results** (`any`, required) - An array of objects that contains Application/User information and an events object with summaries by event type.
                   *   - **metadata** (`object`, optional) - Additional information about the results that may be helpful.
                   *   - **totals** (`object`, optional) - Totals by billing category for all queried events.
                   *
                   * @see https://developer.quickbase.com/operation/platformAnalyticEventSummaries - Official Quickbase API documentation
                   */
                  platformAnalyticEventSummaries: (params: { accountId?: number; body?: { start?: string; end?: string; groupBy?: string; nextToken?: string; where?: { id?: string; type?: string }[] } }) => Promise<PlatformAnalyticEventSummaries200Response>;
                  /**
                   * Export a solution
                   *
                   * @param {Object} params - Object containing the parameters for exportSolution.
                   * @param {string} params.solutionId - The unique identifier of a solution
                   * @param {string} [params.qBLVersion] - The QBL version to be used for the export. If not specified the default would be used. (Optional)
                   *
                   * @returns {Promise<ExportSolution200Response>} - Promise resolving to the exportSolution response.
                   *   - **content** (`string`, optional) - Type: string
                   *
                   * @see https://developer.quickbase.com/operation/exportSolution - Official Quickbase API documentation
                   */
                  exportSolution: (params: { solutionId: string; qBLVersion?: string }) => Promise<ExportSolution200Response>;
                  /**
                   * Update a solution
                   *
                   * @param {Object} params - Object containing the parameters for updateSolution.
                   * @param {string} params.solutionId - The unique identifier of a solution
                   * @param {any} [params.body] - The QBL to be used for the update. (Optional)
                   * @param {boolean} [params.xQBLErrorsAsSuccess] - If this header is set to true, the API will return a 207 status code even if there are errors. The errors will be returned in the response body. (Optional)
                   *
                   * @returns {Promise<UpdateSolution200Response>} - Promise resolving to the updateSolution response.
                   *   - **solutionId** (`string`, optional) - Type: string
                   *   - **alias** (`object`, optional) - Type: object
                   *   - **createdResources** (`any`, optional) - Type: any
                   *   - **warnings** (`any`, optional) - Type: any
                   *
                   * @see https://developer.quickbase.com/operation/updateSolution - Official Quickbase API documentation
                   */
                  updateSolution: (params: { solutionId: string; body?: any; xQBLErrorsAsSuccess?: boolean }) => Promise<UpdateSolution200Response>;
                  /**
                   * Create a solution
                   *
                   * @param {Object} params - Object containing the parameters for createSolution.
                   * @param {any} [params.body] - The QBL to be used for the create. (Optional)
                   * @param {boolean} [params.xQBLErrorsAsSuccess] - If this header is set to true, the API will return a 207 status code even if there are errors. The errors will be returned in the response body. (Optional)
                   *
                   * @returns {Promise<CreateSolution200Response>} - Promise resolving to the createSolution response.
                   *   - **solutionId** (`string`, optional) - Type: string
                   *   - **alias** (`object`, optional) - Type: object
                   *   - **createdResources** (`any`, optional) - Type: any
                   *   - **warnings** (`any`, optional) - Type: any
                   *
                   * @see https://developer.quickbase.com/operation/createSolution - Official Quickbase API documentation
                   */
                  createSolution: (params: { body?: any; xQBLErrorsAsSuccess?: boolean }) => Promise<CreateSolution200Response>;
                  /**
                   * Export solution to record
                   *
                   * @param {Object} params - Object containing the parameters for exportSolutionToRecord.
                   * @param {string} params.solutionId - The unique identifier of the solution.
                   * @param {string} params.tableId - The unique identifier (dbid) of the table.
                   * @param {number} params.fieldId - The unique identifier (fid) of the field. It needs to be a file attachment field.
                   * @param {boolean} [params.xQBLErrorsAsSuccess] - If this header is set to true, the API will return a 207 status code even if there are errors. The errors will be returned in the response body. (Optional)
                   * @param {string} [params.qBLVersion] - The QBL version to be used for the export. If not specified the default would be used. (Optional)
                   *
                   * @returns {Promise<ExportSolutionToRecord200Response>} - Promise resolving to the exportSolutionToRecord response.
                   *   - **record_id** (`number`, optional) - Type: number
                   *   - **filename** (`string`, optional) - Type: string
                   *
                   * @see https://developer.quickbase.com/operation/exportSolutionToRecord - Official Quickbase API documentation
                   */
                  exportSolutionToRecord: (params: { solutionId: string; tableId: string; fieldId: number; xQBLErrorsAsSuccess?: boolean; qBLVersion?: string }) => Promise<ExportSolutionToRecord200Response>;
                  /**
                   * Create solution from record
                   *
                   * @param {Object} params - Object containing the parameters for createSolutionFromRecord.
                   * @param {string} params.tableId - The unique identifier (dbid) of the table.
                   * @param {number} params.fieldId - The unique identifier (fid) of the field. It needs to be a file attachment field.
                   * @param {number} params.recordId - The unique identifier of the record.
                   * @param {boolean} [params.xQBLErrorsAsSuccess] - If this header is set to true, the API will return a 207 status code even if there are errors. The errors will be returned in the response body. (Optional)
                   *
                   * @returns {Promise<CreateSolutionFromRecord200Response>} - Promise resolving to the createSolutionFromRecord response.
                   *   - **solutionId** (`string`, optional) - Type: string
                   *   - **alias** (`object`, optional) - Type: object
                   *   - **createdResources** (`any`, optional) - Type: any
                   *   - **warnings** (`any`, optional) - Type: any
                   *
                   * @see https://developer.quickbase.com/operation/createSolutionFromRecord - Official Quickbase API documentation
                   */
                  createSolutionFromRecord: (params: { tableId: string; fieldId: number; recordId: number; xQBLErrorsAsSuccess?: boolean }) => Promise<CreateSolutionFromRecord200Response>;
                  /**
                   * Update solution from record
                   *
                   * @param {Object} params - Object containing the parameters for updateSolutionToRecord.
                   * @param {string} params.solutionId - The unique identifier of the solution.
                   * @param {string} params.tableId - The unique identifier (dbid) of the table.
                   * @param {number} params.fieldId - The unique identifier (fid) of the field. It needs to be a file attachment field.
                   * @param {number} params.recordId - The unique identifier of the record.
                   * @param {boolean} [params.xQBLErrorsAsSuccess] - If this header is set to true, the API will return a 207 status code even if there are errors. The errors will be returned in the response body. (Optional)
                   *
                   * @returns {Promise<UpdateSolutionToRecord200Response>} - Promise resolving to the updateSolutionToRecord response.
                   *   - **solutionId** (`string`, optional) - Type: string
                   *   - **alias** (`object`, optional) - Type: object
                   *   - **resources** (`any`, optional) - Type: any
                   *   - **warnings** (`any`, optional) - Type: any
                   *
                   * @see https://developer.quickbase.com/operation/updateSolutionToRecord - Official Quickbase API documentation
                   */
                  updateSolutionToRecord: (params: { solutionId: string; tableId: string; fieldId: number; recordId: number; xQBLErrorsAsSuccess?: boolean }) => Promise<UpdateSolutionToRecord200Response>;
                  /**
                   * List solution changes
                   *
                   * @param {Object} params - Object containing the parameters for changesetSolution.
                   * @param {string} params.solutionId - The unique identifier of the solution.
                   * @param {any} [params.body] - The QBL to be used for the changeset. (Optional)
                   * @param {boolean} [params.xQBLErrorsAsSuccess] - If this header is set to true, the API will return a 207 status code even if there are errors. The errors will be returned in the response body. (Optional)
                   *
                   * @returns {Promise<ChangesetSolution200Response>} - Promise resolving to the changesetSolution response.
                   *   - **id** (`string`, optional) - Type: string
                   *   - **changes** (`any`, optional) - Type: any
                   *
                   * @see https://developer.quickbase.com/operation/changesetSolution - Official Quickbase API documentation
                   */
                  changesetSolution: (params: { solutionId: string; body?: any; xQBLErrorsAsSuccess?: boolean }) => Promise<ChangesetSolution200Response>;
                  /**
                   * List solution changes from record
                   *
                   * @param {Object} params - Object containing the parameters for changesetSolutionFromRecord.
                   * @param {string} params.solutionId - The unique identifier of the solution.
                   * @param {string} params.tableId - The unique identifier (dbid) of the table.
                   * @param {number} params.fieldId - The unique identifier (fid) of the field. It needs to be a file attachment field.
                   * @param {number} params.recordId - The unique identifier of the record.
                   * @param {boolean} [params.xQBLErrorsAsSuccess] - If this header is set to true, the API will return a 207 status code even if there are errors. The errors will be returned in the response body. (Optional)
                   *
                   * @returns {Promise<ChangesetSolutionFromRecord200Response>} - Promise resolving to the changesetSolutionFromRecord response.
                   *   - **id** (`string`, optional) - Type: string
                   *   - **changes** (`any`, optional) - Type: any
                   *
                   * @see https://developer.quickbase.com/operation/changesetSolutionFromRecord - Official Quickbase API documentation
                   */
                  changesetSolutionFromRecord: (params: { solutionId: string; tableId: string; fieldId: number; recordId: number; xQBLErrorsAsSuccess?: boolean }) => Promise<ChangesetSolutionFromRecord200Response>;
                  /**
                   * Generate a document
                   *
                   * @param {Object} params - Object containing the parameters for generateDocument.
                   * @param {number} params.templateId - This is the ID of document template.
                   * @param {string} params.tableId - The unique identifier of the table.
                   * @param {number} [params.recordId] - The ID of the record (Optional)
                   * @param {string} params.filename - File name for the downloaded file
                   * @param {string} [params.accept] - The content-type of the response. application/json will return a JSON payload with a base64 encoded file. application/octet-stream will download the file directly. (Optional)
                   * @param {string} [params.format] - The format of the file that is returned. Default is "pdf". (Optional)
                   * @param {string} [params.margin] - Margin formatted as top right bottom left, separated by spaces. Add to override the value set in the template builder. (Optional)
                   * @param {string} [params.unit] - Unit of measurement for the margin. Default is "in". Add to override the value set in the template builder. (Optional)
                   * @param {string} [params.pageSize] - Page size. Default is "A4". Add to override the value set in the template builder. (Optional)
                   * @param {string} [params.orientation] - Page orientation. Default is "portrait". Add to override the value set in the template builder. (Optional)
                   * @param {string} [params.realm] - Your Quickbase domain, for example demo.quickbase.com (Optional)
                   *
                   * @returns {Promise<GenerateDocument200Response>} - Promise resolving to the generateDocument response.
                   *   - **fileName** (`string`, optional) - The file name.
                   *   - **data** (`string`, optional) - Base64 encoded file content.
                   *   - **contentType** (`string`, optional) - The document content type.
                   *
                   * @see https://developer.quickbase.com/operation/generateDocument - Official Quickbase API documentation
                   */
                  generateDocument: (params: { templateId: number; tableId: string; recordId?: number; filename: string; accept?: string; format?: string; margin?: string; unit?: string; pageSize?: string; orientation?: string; realm?: string }) => Promise<GenerateDocument200Response>;
                }
            - name: >-
                missing-types-report.json
              type: >-
                file
        - name: >-
            index.ts
          type: >-
            file
        - name: >-
            invokeMethod.ts
          type: >-
            file
          contents: >
            //
            src/invokeMethod.ts


            import
            {
            AuthorizationStrategy,
            extractDbid
            }
            from
            "./authorizationStrategy";

            import
            {
            RateLimiter
            }
            from
            "./rateLimiter";

            import
            {
            RateLimitError
            }
            from
            "./RateLimitError";

            import
            {
            ResponseError
            }
            from
            "./generated/runtime";

            import
            {
            QuickbaseClient
            }
            from
            "./quickbaseClient";

            import
            {
            paginateRecords,
            isPaginatable
            }
            from
            "./pagination";


            export
            type
            ApiMethod<K
            extends
            keyof
            QuickbaseClient>
            =
            (
              requestParameters: Parameters<QuickbaseClient[K]>[0],
              initOverrides?: RequestInit
            )
            =>
            Promise<ReturnType<QuickbaseClient[K]>>;


            export
            interface
            MethodInfo<K
            extends
            keyof
            QuickbaseClient>
            {
              api: any;
              method: ApiMethod<K>;
              paramMap: string[];
              httpMethod: string;
            }


            export
            async
            function
            invokeMethod<K
            extends
            keyof
            QuickbaseClient>(
              methodName: K,
              params: Parameters<QuickbaseClient[K]>[0] & {
                dbid?: string;
                tableId?: string;
                appId?: string;
                startTime?: number;
                skip?: number;
                top?: number;
                disablePagination?: boolean; // Add per-call override
              },
              methodMap: { [P in keyof QuickbaseClient]: MethodInfo<P> },
              baseHeaders: Record<string, string>,
              authStrategy: AuthorizationStrategy,
              rateLimiter: RateLimiter,
              transformDates: (obj: any, convertStringsToDates: boolean) => any,
              debug: boolean | undefined,
              convertDates: boolean,
              autoPaginate: boolean = true,
              attempt: number = 0,
              maxAttempts: number = rateLimiter.maxRetries + 1,
              isPaginating: boolean = false
            ):
            Promise<ReturnType<QuickbaseClient[K]>>
            {
              const methodInfo = methodMap[methodName];
              if (!methodInfo) throw new Error(`Method ${methodName} not found`);

              const hasBody = "body" in params && params.body !== undefined;
              const body = hasBody ? params.body : undefined;
              const options =
                hasBody && body && typeof body === "object" && "options" in body
                  ? (body as any).options
                  : undefined;
              const adjustedParams = {
                ...params,
                skip:
                  params.skip ?? (options && "skip" in options ? options.skip : undefined),
                top: params.top ?? (options && "top" in options ? options.top : undefined),
              };

              const restParams: any = hasBody
                ? Object.fromEntries(
                    Object.entries(adjustedParams).filter(
                      ([key]) =>
                        key !== "body" && key !== "startTime" && key !== "disablePagination"
                    )
                  )
                : { ...adjustedParams, startTime: undefined, disablePagination: undefined };
              const requestParameters: any = {
                ...restParams,
                ...(hasBody ? { generated: body } : {}),
              };

              if (debug)
                console.log(
                  "[invokeMethod] Adjusted params for pagination:",
                  adjustedParams
                );

              const requestOptions: RequestInit = {
                credentials: methodName === "getTempTokenDBID" ? "include" : "omit",
                method: methodInfo.httpMethod,
              };

              let dbid: string | undefined = extractDbid(params);
              let token = dbid
                ? await authStrategy.getToken(dbid)
                : await authStrategy.getToken("");

              if (token) {
                authStrategy.applyHeaders(baseHeaders, token);
                requestOptions.headers = { ...baseHeaders };
                if (methodName === "getTempTokenDBID") {
                  return { temporaryAuthorization: token } as ReturnType<
                    QuickbaseClient[K]
                  >;
                }
              }

              // Determine effective pagination setting: per-call override takes precedence
              const effectiveAutoPaginate =
                params.disablePagination !== undefined
                  ? !params.disablePagination
                  : autoPaginate;

              async function processResponse(
                rawResponse: any
              ): Promise<ReturnType<QuickbaseClient[K]>> {
                if (rawResponse instanceof Response) {
                  const contentType = rawResponse.headers
                    .get("Content-Type")
                    ?.toLowerCase();
                  if (contentType?.includes("application/json")) {
                    const jsonResponse = await rawResponse.json();
                    if (
                      effectiveAutoPaginate &&
                      !isPaginating &&
                      isPaginatable(jsonResponse)
                    ) {
                      if (debug)
                        console.log(
                          "[invokeMethod] Entering pagination with params:",
                          adjustedParams
                        );
                      return paginateRecords(
                        methodName,
                        adjustedParams,
                        methodMap,
                        baseHeaders,
                        authStrategy,
                        rateLimiter,
                        transformDates,
                        debug,
                        convertDates,
                        jsonResponse
                      );
                    }
                    return transformDates(jsonResponse, convertDates) as ReturnType<
                      QuickbaseClient[K]
                    >;
                  }
                  return rawResponse as ReturnType<QuickbaseClient[K]>;
                }
                if (rawResponse && typeof rawResponse.value === "function") {
                  const response = await rawResponse.value();
                  if (effectiveAutoPaginate && !isPaginating && isPaginatable(response)) {
                    if (debug)
                      console.log(
                        "[invokeMethod] Entering pagination with params:",
                        adjustedParams
                      );
                    return paginateRecords(
                      methodName,
                      adjustedParams,
                      methodMap,
                      baseHeaders,
                      authStrategy,
                      rateLimiter,
                      transformDates,
                      debug,
                      convertDates,
                      response
                    );
                  }
                  return transformDates(response, convertDates) as ReturnType<
                    QuickbaseClient[K]
                  >;
                }
                return transformDates(rawResponse, convertDates) as ReturnType<
                  QuickbaseClient[K]
                >;
              }

              async function parseErrorResponse(
                response: Response
              ): Promise<{ message: string; status: number }> {
                let message = "Unknown error";
                let status = response.status || 500;
                try {
                  const contentType =
                    response.headers?.get("Content-Type")?.toLowerCase() ||
                    "application/json";
                  if (
                    contentType.includes("application/json") &&
                    typeof response.json === "function"
                  ) {
                    const errorBody = await response.json();
                    if (
                      errorBody &&
                      typeof errorBody === "object" &&
                      "message" in errorBody
                    ) {
                      message = errorBody.message;
                    } else {
                      message = "Invalid error response format";
                    }
                  } else if (typeof response.text === "function") {
                    message = (await response.text()) || message;
                  }
                } catch (e) {
                  message = "Failed to parse error response";
                }
                return { message, status };
              }

              while (attempt < maxAttempts) {
                let acquired = false;
                try {
                  await rateLimiter.throttle();
                  acquired = true;
                  const postThrottleTime = Date.now();
                  if (params.startTime !== undefined) params.startTime = postThrottleTime;
                  const headers = { ...baseHeaders };
                  const finalRequest = { ...requestParameters, headers };
                  if (debug) console.log("[invokeMethod] Sending request:", finalRequest);
                  const responsePromise = methodInfo.method(finalRequest, {
                    ...requestOptions,
                    headers,
                  });
                  rateLimiter.release();
                  const response = await responsePromise;
                  return await processResponse(response);
                } catch (error: unknown) {
                  if (acquired) rateLimiter.release();
                  let status: number;
                  let message: string;
                  let response: Response | undefined;

                  if (error instanceof ResponseError && error.response) {
                    response = error.response;
                    ({ message, status } = await parseErrorResponse(response));
                  } else if (error instanceof Response) {
                    response = error;
                    ({ message, status } = await parseErrorResponse(response));
                  } else {
                    throw error;
                  }

                  if (status === 429) {
                    if (!(error instanceof ResponseError)) {
                      throw new Error("Expected ResponseError for 429 handling");
                    }
                    const delay = await rateLimiter.handle429(error, attempt + 1);
                    if (attempt + 1 === maxAttempts) {
                      throw new RateLimitError(
                        `API Error: ${message} (Status: ${status})`,
                        status,
                        response?.headers.get("Retry-After")
                          ? parseInt(response.headers.get("Retry-After")!, 10)
                          : undefined
                      );
                    }
                    await new Promise((resolve) => setTimeout(resolve, delay));
                    attempt++;
                    continue;
                  }

                  let newToken: string | null;
                  try {
                    newToken = await authStrategy.handleError(
                      status,
                      params,
                      attempt,
                      maxAttempts,
                      debug,
                      methodName
                    );
                  } catch (authError) {
                    throw authError;
                  }

                  if (newToken !== null) {
                    token = newToken;
                    authStrategy.applyHeaders(baseHeaders, token);
                    requestOptions.headers = { ...baseHeaders };
                    attempt++;
                    continue;
                  }

                  throw new Error(`API Error: ${message} (Status: ${status})`);
                }
              }
              throw new Error(`API Error: Exhausted retries after ${maxAttempts} attempts`);
            }
        - name: >-
            pagination.ts
          type: >-
            file
        - name: >-
            quickbaseClient.ts
          type: >-
            file
          contents: >
            //
            src/quickbaseClient.ts


            import
            {
            QuickbaseClient
            as
            IQuickbaseClient
            }
            from
            "./generated-unified/QuickbaseClient";

            import
            {
            Configuration,
            HTTPHeaders
            }
            from
            "./generated/runtime";

            import
            *
            as
            apis
            from
            "./generated/apis";

            import
            {
            TokenCache
            }
            from
            "./tokenCache";

            import
            {
              simplifyName,
              getParamNames,
              transformDates,
              extractHttpMethod,
            }
            from
            "./utils";

            import
            {
            invokeMethod,
            MethodInfo
            }
            from
            "./invokeMethod";

            import
            {
              TempTokenStrategy,
              UserTokenStrategy,
              AuthorizationStrategy,
              SsoTokenStrategy,
            }
            from
            "./authorizationStrategy";

            import
            {
            FlowThrottleBucket
            }
            from
            "./FlowThrottleBucket";

            import
            {
            BurstAwareThrottleBucket
            }
            from
            "./BurstAwareThrottleBucket";

            import
            {
            RateLimiter
            }
            from
            "./rateLimiter";


            export
            *
            from
            "./generated/models/index";


            export
            interface
            QuickbaseClient
            extends
            IQuickbaseClient
            {}


            export
            interface
            QuickbaseConfig
            {
              realm: string;
              userToken?: string;
              tempToken?: string;
              useTempTokens?: boolean;
              useSso?: boolean;
              samlToken?: string;
              debug?: boolean;
              fetchApi?: typeof fetch;
              convertDates?: boolean;
              tempTokenLifespan?: number;
              throttle?: {
                type?: "flow" | "burst-aware";
                rate?: number;
                burst?: number;
                windowSeconds?: number;
              };
              maxRetries?: number;
              retryDelay?: number;
              tokenCache?: TokenCache;
              baseUrl?: string;
              autoPaginate?: boolean;
            }


            export
            type
            ThrottleOptions
            =
            {
              type?: "flow" | "burst-aware";
              rate?: number;
              burst?: number;
              windowSeconds?: number;
            };


            type
            MethodMap
            =
            {
              [K in keyof QuickbaseClient]: MethodInfo<K>;
            };


            export
            function
            quickbase(config:
            QuickbaseConfig):
            QuickbaseClient
            {
              const {
                realm,
                userToken,
                tempToken,
                useTempTokens = false,
                useSso = false,
                samlToken,
                fetchApi,
                debug,
                convertDates = true,
                tempTokenLifespan = 290000,
                throttle = { type: "flow", rate: 5, burst: 50 },
                maxRetries = 3,
                retryDelay = 1000,
                tokenCache: providedTokenCache,
                baseUrl = "https://api.quickbase.com/v1",
                autoPaginate = true,
              } = config;

              const tokenCache = providedTokenCache || new TokenCache(tempTokenLifespan);

              const throttleOptions = throttle as ThrottleOptions;
              const throttleBucket =
                throttleOptions.type === "burst-aware"
                  ? new BurstAwareThrottleBucket({
                      maxTokens: throttleOptions.burst || 100,
                      windowSeconds: throttleOptions.windowSeconds || 10,
                    })
                  : new FlowThrottleBucket(
                      throttleOptions.rate || 5,
                      throttleOptions.burst || 50
                    );

              const rateLimiter = new RateLimiter(throttleBucket, maxRetries, retryDelay);

              const defaultFetch: typeof fetch =
                globalThis.fetch || globalThis.window?.fetch?.bind(globalThis.window);
              if (!defaultFetch && !fetchApi) {
                throw new Error(
                  "No fetch implementation available. Please provide fetchApi in a Node.js environment without native fetch."
                );
              }
              const effectiveFetch = fetchApi || defaultFetch;

              const authStrategy: AuthorizationStrategy = useSso
                ? new SsoTokenStrategy(
                    samlToken || "",
                    realm,
                    effectiveFetch,
                    debug,
                    baseUrl
                  )
                : useTempTokens
                ? new TempTokenStrategy(
                    tokenCache,
                    tempToken,
                    effectiveFetch,
                    realm,
                    baseUrl
                  )
                : new UserTokenStrategy(userToken || "", baseUrl);

              const baseHeaders: HTTPHeaders = {
                "QB-Realm-Hostname": `${realm}.quickbase.com`,
                "Content-Type": "application/json",
              };

              const configuration = new Configuration({
                basePath: baseUrl,
                headers: { ...baseHeaders },
                fetchApi: effectiveFetch,
                credentials: "omit",
              });

              const apiInstances = Object.fromEntries(
                Object.entries(apis)
                  .filter(([name]) => name.endsWith("Api"))
                  .map(([name, ApiClass]) => [
                    name.replace("Api", "").toLowerCase(),
                    new ApiClass(configuration),
                  ])
              );

              function buildMethodMap(): MethodMap {
                const methodMap: Partial<MethodMap> = {};
                const isValidMethod = (name: string) =>
                  !name.startsWith("_") &&
                  name !== "constructor" &&
                  !["Middleware", "Pre", "Post", "Raw"].some((s) => name.includes(s));

                for (const [apiName, api] of Object.entries(apiInstances)) {
                  Object.getOwnPropertyNames(Object.getPrototypeOf(api))
                    .filter(
                      (name) =>
                        isValidMethod(name) &&
                        typeof api[name as keyof typeof api] === "function"
                    )
                    .forEach((rawMethodName) => {
                      const simplifiedName = simplifyName(
                        rawMethodName
                      ) as keyof QuickbaseClient;
                      const rawMethodKey = `${rawMethodName}Raw` as keyof typeof api;
                      const method =
                        api[rawMethodKey] || api[rawMethodName as keyof typeof api];
                      const boundMethod = method.bind(api as any) as unknown;
                      if (typeof boundMethod === "function" && boundMethod.length <= 2) {
                        const httpMethod = extractHttpMethod(method);
                        methodMap[simplifiedName] = {
                          api,
                          method: boundMethod as any,
                          paramMap: getParamNames(method),
                          httpMethod,
                        };
                      }
                    });
                }
                if (debug) {
                  console.log("[buildMethodMap] Methods:", Object.keys(methodMap));
                }
                return methodMap as MethodMap;
              }

              const methodMap = buildMethodMap();

              const proxyHandler: globalThis.ProxyHandler<QuickbaseClient> = {
                get: (_: QuickbaseClient, prop: string) => {
                  if (debug) {
                    console.log(
                      "[proxy] Accessing:",
                      prop,
                      "in methodMap:",
                      prop in methodMap
                    );
                  }
                  if (prop in methodMap) {
                    const methodName = prop as keyof QuickbaseClient;
                    return (
                      params: Parameters<QuickbaseClient[typeof methodName]>[0] & {
                        disablePagination?: boolean;
                      } = {}
                    ) =>
                      invokeMethod(
                        methodName,
                        params,
                        methodMap,
                        baseHeaders,
                        authStrategy,
                        rateLimiter,
                        transformDates,
                        debug,
                        convertDates,
                        params.disablePagination !== undefined
                          ? !params.disablePagination
                          : autoPaginate // Per-call override
                      );
                  }
                  if (debug) {
                    console.log("[proxy] Method not found:", prop);
                  }
                  return undefined;
                },
              };

              const proxy = new Proxy<QuickbaseClient>({} as QuickbaseClient, proxyHandler);

              if (debug) {
                console.log("[createClient] Config:", config);
                console.log("[createClient] Returning proxy");
              }

              return proxy;
            }
        - name: >-
            rateLimiter.ts
          type: >-
            file
          contents: >
            //
            src/RateLimiter.ts

            import
            {
            ResponseError
            }
            from
            "./generated/runtime";

            import
            {
            RateThrottleBucket
            }
            from
            "./RateThrottleBucket";


            export
            class
            RateLimiter
            {
              constructor(
                private throttleBucket: RateThrottleBucket | null,
                public maxRetries: number = 3,
                private retryDelay: number = 1000
              ) {}

              async throttle(): Promise<void> {
                if (this.throttleBucket) {
                  await this.throttleBucket.acquire();
                }
              }

              release(): void {
                if (this.throttleBucket) {
                  this.throttleBucket.release();
                }
              }

              async handle429(error: ResponseError, attempt: number): Promise<number> {
                const retryAfter = error.response.headers.get("Retry-After");
                return retryAfter
                  ? parseInt(retryAfter, 10) * 1000
                  : this.retryDelay * Math.pow(2, attempt - 1);
              }
            }
        - name: >-
            tokenCache.ts
          type: >-
            file
          contents: >
            //
            src/tokenCache.ts

            interface
            CachedToken
            {
              token: string;
              expiresAt: number;
            }


            export
            class
            TokenCache
            {
              private cache: Map<string, CachedToken>;
              private readonly tempTokenLifespan: number;

              constructor(tempTokenLifespan: number = 4 * 60 * 1000 + 50 * 1000) {
                this.cache = new Map<string, CachedToken>();
                this.tempTokenLifespan = tempTokenLifespan;
              }

              get(dbid: string): string | undefined {
                const entry = this.cache.get(dbid);
                const now = Date.now();
                if (entry && entry.expiresAt > now) return entry.token;
                if (entry) this.cache.delete(dbid); // Clean up expired temp tokens
                return undefined;
              }

              set(dbid: string, token: string, lifespan?: number): void {
                const now = Date.now();
                this.cache.set(dbid, {
                  token,
                  expiresAt: now + (lifespan || this.tempTokenLifespan),
                });
              }

              delete(dbid: string): void {
                this.cache.delete(dbid);
              }

              clear(): void {
                this.cache.clear();
              }
            }
        - name: >-
            utils.ts
          type: >-
            file
          contents: >
            //
            src/utils.ts


            export
            function
            simplifyName(methodName:
            string):
            string
            {
              // Assuming this removes 'Raw' or similar suffixes as per your original logic
              return methodName
                .replace(/Raw$/, "")
                .replace(/^./, (str) => str.toLowerCase());
            }


            export
            function
            getParamNames(func:
            Function):
            string[]
            {
              // Your existing logic to extract parameter names from a function
              const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
              const ARGUMENT_NAMES = /([^\s,]+)/g;
              const fnStr = func.toString().replace(STRIP_COMMENTS, "");
              const result = fnStr
                .slice(fnStr.indexOf("(") + 1, fnStr.indexOf(")"))
                .match(ARGUMENT_NAMES);
              return result || [];
            }


            export
            function
            transformDates(obj:
            any,
            convertStringsToDates:
            boolean):
            any
            {
              // Your existing logic to transform dates
              if (!obj || typeof obj !== "object") return obj;
              if (Array.isArray(obj))
                return obj.map((item) => transformDates(item, convertStringsToDates));
              const result: any = {};
              for (const [key, value] of Object.entries(obj)) {
                if (
                  typeof value === "string" &&
                  convertStringsToDates &&
                  /^\d{4}-\d{2}-\d{2}/.test(value)
                ) {
                  result[key] = new Date(value);
                } else if (value instanceof Date) {
                  result[key] = value;
                } else if (typeof value === "object") {
                  result[key] = transformDates(value, convertStringsToDates);
                } else {
                  result[key] = value;
                }
              }
              return result;
            }


            export
            function
            extractHttpMethod(method:
            Function):
            string
            {
              const source = method.toString();
              // Match the `method: 'SOME_METHOD'` part of the `request` call
              const match = source.match(/method:\s*['"](\w+)['"]/i);
              return match ? match[1].toUpperCase() : "GET"; // Fallback to GET if no match
            }
    - name: >-
        test-artifacts
      type: >-
        directory
      children:
        - name: >-
            .playwright-artifacts-0
          type: >-
            directory
          children:
            - name: >-
                traces
              type: >-
                directory
              children: []
        - name: >-
            .playwright-artifacts-1
          type: >-
            directory
          children:
            - name: >-
                traces
              type: >-
                directory
              children: []
        - name: >-
            .playwright-artifacts-2
          type: >-
            directory
          children:
            - name: >-
                traces
              type: >-
                directory
              children: []
        - name: >-
            .playwright-artifacts-3
          type: >-
            directory
          children:
            - name: >-
                traces
              type: >-
                directory
              children: []
    - name: >-
        tests
      type: >-
        directory
      children:
        - name: >-
            playwright
          type: >-
            directory
          children:
            - name: >-
                qb
              type: >-
                directory
              children:
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        cacheSwitching.test.ts
                      type: >-
                        file
                    - name: >-
                        fetchTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithTempTokenConcurrency.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithUserToken.test.ts
                      type: >-
                        file
                    - name: >-
                        getTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        tempTokenPrefetch.test.ts
                      type: >-
                        file
                    - name: >-
                        tempTokenRenewal.test.ts
                      type: >-
                        file
        - name: >-
            setup.ts
          type: >-
            file
          contents: >
            //
            @tests/setup.ts

            import
            {
            vi
            }
            from
            "vitest";

            import
            {
            quickbase
            }
            from
            "../src/quickbaseClient.ts";

            import
            type
            {
            QuickbaseConfig
            }
            from
            "../src/quickbaseClient.ts";

            import
            dotenv
            from
            "dotenv";


            //
            Load
            environment
            variables
            from
            .env
            file

            dotenv.config({
            path:
            "./.env"
            });
            //
            Assumes
            .env
            is
            at
            project
            root


            export
            const
            mockFetch
            =
            vi.fn();


            export
            const
            QB_REALM
            =
            process.env.QB_REALM
            ||
            "test-realm";

            export
            const
            QB_USER_TOKEN
            =
              process.env.QB_USER_TOKEN || "user-token-1234567890";
            export
            const
            QB_APP_ID
            =
            process.env.QB_APP_ID
            ||
            "app-id-1234567890";

            export
            const
            QB_TABLE_ID_1
            =
              process.env.QB_TABLE_ID_1 || "table-id-1-1234567890";
            export
            const
            QB_TABLE_ID_2
            =
              process.env.QB_TABLE_ID_2 || "table-id-2-1234567890";

            //
            Mock
            env
            variables
            for
            consistency,
            using
            .env
            values
            if
            available

            vi.stubEnv("QB_REALM",
            QB_REALM);

            vi.stubEnv("QB_USER_TOKEN",
            QB_USER_TOKEN);

            vi.stubEnv("QB_APP_ID",
            QB_APP_ID);

            vi.stubEnv("QB_TABLE_ID_1",
            QB_TABLE_ID_1);

            vi.stubEnv("QB_TABLE_ID_2",
            QB_TABLE_ID_2);


            export
            const
            createClient
            =
            (
              fetchApi?: any,
              config: Partial<QuickbaseConfig> = {}
            )
            =>
            {
              // Use loaded env vars with fallbacks for safety
              const realm = QB_REALM;
              const userToken = QB_USER_TOKEN;

              const client = quickbase({
                realm,
                userToken,
                debug: true,
                fetchApi,
                throttle: { rate: 10, burst: 10 }, // Throttle at 10 req/s with 10 burst capacity
                ...config, // Allow overrides if provided
              });
              console.log("[createClient] Config:", {
                realm,
                userToken,
                debug: true,
                throttle: { rate: 10, burst: 10 },
                ...config,
              });
              console.log("[createClient] Returning:", client);
              return client;
            };
        - name: >-
            vitest
          type: >-
            directory
          children:
            - name: >-
                qb
              type: >-
                directory
              children:
                - name: >-
                    apps
                  type: >-
                    directory
                  children:
                    - name: >-
                        copyApp.test.ts
                      type: >-
                        file
                    - name: >-
                        createApp.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppEvents.test.ts
                      type: >-
                        file
                    - name: >-
                        updateApp.test.ts
                      type: >-
                        file
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        mockQuickbaseServer.ts
                      type: >-
                        file
                    - name: >-
                        retryUserToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        ssoTokenConcurrency.test.ts
                      type: >-
                        file
                    - name: >-
                        ssoTokenIntegrationWithServer.test.ts
                      type: >-
                        file
                    - name: >-
                        userTokenConcurrency.test.ts
                      type: >-
                        file
                - name: >-
                    fields
                  type: >-
                    directory
                  children:
                    - name: >-
                        createField.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getField.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        getFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldsUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        updateField.test.ts
                      type: >-
                        file
                - name: >-
                    formulas
                  type: >-
                    directory
                  children:
                    - name: >-
                        runFormula.test.ts
                      type: >-
                        file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    quickbase-js
                  type: >-
                    directory
                  children:
                    - name: >-
                        BurstAwareThrottleBucket.test.ts
                      type: >-
                        file
                    - name: >-
                        FlowBucket.test.ts
                      type: >-
                        file
                    - name: >-
                        paginationControl.test.ts
                      type: >-
                        file
                    - name: >-
                        paginationSkip.test.ts
                      type: >-
                        file
                - name: >-
                    records
                  type: >-
                    directory
                  children:
                    - name: >-
                        deleteRecords.test.ts
                      type: >-
                        file
                    - name: >-
                        runQuery.test.ts
                      type: >-
                        file
                    - name: >-
                        upsert.test.ts
                      type: >-
                        file
                - name: >-
                    tables
                  type: >-
                    directory
                  children:
                    - name: >-
                        createRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        createTable.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteTable.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppTables.test.ts
                      type: >-
                        file
                    - name: >-
                        getRelationships.test.ts
                      type: >-
                        file
                    - name: >-
                        getTable.test.ts
                      type: >-
                        file
                    - name: >-
                        updateRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        updateTable.test.ts
                      type: >-
                        file
            - name: >-
                unit
              type: >-
                directory
              children:
                - name: >-
                    apps
                  type: >-
                    directory
                  children:
                    - name: >-
                        copyApp.test.ts
                      type: >-
                        file
                    - name: >-
                        createApp.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppConcurrency.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppEvents.test.ts
                      type: >-
                        file
                    - name: >-
                        updateApp.test.ts
                      type: >-
                        file
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        fetchTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        getTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        retryTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        retryTempTokenMaxRetries.test.ts
                      type: >-
                        file
                    - name: >-
                        retryUserToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        ssoTokenRefresh.test.ts
                      type: >-
                        file
                    - name: >-
                        userTokenConcurrency.test.ts
                      type: >-
                        file
                - name: >-
                    fields
                  type: >-
                    directory
                  children:
                    - name: >-
                        createField.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getField.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        getFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldsUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        updateField.test.ts
                      type: >-
                        file
                - name: >-
                    formulas
                  type: >-
                    directory
                  children:
                    - name: >-
                        runFormula.test.ts
                      type: >-
                        file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    quickbase-js
                  type: >-
                    directory
                  children:
                    - name: >-
                        BurstAwareThrottleBucket.test.ts
                      type: >-
                        file
                    - name: >-
                        FlowBucket.test.ts
                      type: >-
                        file
                    - name: >-
                        pagination.test.ts
                      type: >-
                        file
                    - name: >-
                        quickbaseClientHttpMethods.test.ts
                      type: >-
                        file
                    - name: >-
                        rateLimit.test.ts
                      type: >-
                        file
                    - name: >-
                        tokenLifespan.test.ts
                      type: >-
                        file
                - name: >-
                    records
                  type: >-
                    directory
                  children:
                    - name: >-
                        deleteRecords.test.ts
                      type: >-
                        file
                    - name: >-
                        runQuery.test.ts
                      type: >-
                        file
                    - name: >-
                        upsert.test.ts
                      type: >-
                        file
                - name: >-
                    tables
                  type: >-
                    directory
                  children:
                    - name: >-
                        createRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        createTable.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteTable.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppTables.test.ts
                      type: >-
                        file
                    - name: >-
                        getRelationships.test.ts
                      type: >-
                        file
                    - name: >-
                        getTable.test.ts
                      type: >-
                        file
                    - name: >-
                        updateRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        updateTable.test.ts
                      type: >-
                        file
    - name: >-
        tools
      type: >-
        directory
      children:
        - name: >-
            log-gen.ts
          type: >-
            file
        - name: >-
            log-gen.yaml
          type: >-
            file
        - name: >-
            openapi-jars
          type: >-
            directory
          children:
            - name: >-
                openapi-generator-cli-7.12.0.jar
              type: >-
                file
    - name: >-
        tsconfig.build.json
      type: >-
        file
    - name: >-
        tsconfig.json
      type: >-
        file
    - name: >-
        versionrc.json
      type: >-
        file
    - name: >-
        vitest.config.ts
      type: >-
        file
      contents: >
        import
        {
        defineConfig
        }
        from
        "vitest/config";

        import
        path
        from
        "path";

        import
        dotenv
        from
        "dotenv";


        //
        Load
        .env
        variables
        before
        tests
        run

        dotenv.config({
        path:
        path.resolve(__dirname,
        ".env")
        });


        export
        default
        defineConfig({
          test: {
            environment: "jsdom",
            include: ["tests/vitest/**/**/*.test.ts"],
            setupFiles: ["tests/setup.ts"], // Relative path from root
            pool: "forks",
            poolOptions: {
              forks: {
                singleFork: true, // Run tests sequentially
              },
            },
            testTimeout: 10000, // Global timeout of 10 seconds for all tests
          },
          resolve: {
            alias: {
              "@": path.resolve(__dirname, "./src"), // For src/ imports
              "@tests": path.resolve(__dirname, "./tests"), // For tests/ imports
            },
          },
        });

project: >-
  quickbase-js
date: >-
  4/5/2025
root: >-
  /home/drew/Projects/quickbase-js
goals:
  - >-
    A
    library
    for
    interacting
    with
    the
    QuickBase
    RESTful
    API.
  - >-
    Use
    OpenAPI
    to
    generate
    types
    and
    methods
    using
    a
    proxy.
    Validate
    with
    tests.
  - >-
    Provide
    robust
    and
    intuitive
    temporary
    token
    support
    for
    browser
    environments.
  - >-
    User
    Tokens
    support
    both
    Node.js
    and
    browser
    environments.
  - >-
    Use
    case:
    JS
    frameworks
    like
    React,
    Vue,
    and
    Angular
    hosted
    in
    QuickBase
    code
    pages.
  - >-
    Enable
    a
    flexible
    or
    native
    fetch
    in
    the
    browser.
  - >-
    Enable
    a
    flexible
    fetch
    framework
    in
    Node.js.
  - >-
    #
  - >-
    No
    manual
    updating
    methods
    when
    the
    QuickBase
    API
    changes.
  - >-
    The
    proxy
    magic
    dynamically
    maps
    generated
    methods
    and
    types.
  - >-
    #
  - >-
    TokenCache
    is
    defined
    per
    quickbaseClient
    call,
    so
    each
    instance
    has
    its
    own
    isolated
    TokenCache.
  - >-
    Each
    quickbase
    client
    instance
    has
    an
    isolated
    and
    individual
    token
    cache.
pipelineOverview:
  - >-
    What
    I’m
    Trying
    to
    Do
  - >-
    My
    approach
    is
    to
    ensure
    AppsApi.ts
    is
    generated
    with
    getAppById
    so
    QuickbaseClient.ts
    can
    map
    it
    to
    client.getApp.
    Steps
    include:
  - >-
    Fix
    fix-spec.ts:
  - >-
    Add
    tags:
    ["Apps"]
    to
    /apps/*
    endpoints
    to
    group
    them
    into
    AppsApi.ts.
  - >-
    Ensure
    all
    endpoints
    and
    models
    are
    correctly
    defined
    and
    typed.
  - >-
    Debug
    regenerate-client.ts:
  - >-
    Enhance
    logging
    to
    catch
    why
    AppsApi.ts
    isn’t
    generated.
  - >-
    Test
    if
    getAppById
    appears
    in
    another
    file
    (e.g.,
    DefaultApi.ts).
  - >-
    Update
    QuickbaseClient.ts:
  - >-
    Adjust
    imports
    to
    use
    the
    correct
    API
    class
    once
    generated.
  - >-
    Test
    and
    Iterate:
  - >-
    Run
    npm
    run
    fix-spec,
    npm
    run
    regenerate,
    and
    npm
    run
    test
    to
    verify
    AppsApi.ts
    exists
    and
    test.ts
    works.
  - >-
    The
    latest
    fix-spec.ts
    with
    tags
    aims
    to
    force
    the
    generator
    to
    create
    AppsApi.ts,
    addressing
    the
    missing
    file
    issue.
  - >-
    Relevant
    Project
    Files
  - >-
    Here’s
    a
    list
    of
    files
    that
    would
    help
    understand
    and
    resolve
    this
    problem,
    along
    with
    their
    roles:
  - >-
    src/code-generation/fix-spec.ts:
  - >-
    Role:
    Modifies
    the
    original
    QuickBase
    spec
    (e.g.,
    QuickBase_RESTful_*.json)
    to
    create
    quickbase-fixed.json
    with
    required
    endpoints
    (e.g.,
    /apps/{appId}).
  - >-
    Relevance:
    Defines
    the
    spec
    fed
    to
    the
    generator;
    errors
    here
    affect
    generation.
  - >-
    src/code-generation/quickbase-fixed.json:
  - >-
    Role:
    The
    processed
    OpenAPI
    spec
    used
    by
    regenerate-client.ts
    to
    generate
    code.
  - >-
    Relevance:
    Confirms
    if
    /apps/{appId}
    is
    correctly
    structured
    with
    operationId:
    "getAppById".
  - >-
    src/code-generation/regenerate-client.ts:
  - >-
    Role:
    Runs
    OpenAPI
    Generator
    to
    produce
    src/generated/
    files
    (APIs
    and
    models)
    and
    fixes
    .ts
    extensions
    with
    ts-morph.
  - >-
    Relevance:
    Controls
    the
    generation
    process;
    logs
    reveal
    why
    AppsApi.ts
    is
    missing.
  - >-
    src/generated/apis/AppsApi.ts
    (if
    exists):
  - >-
    Role:
    Should
    contain
    getAppById
    method
    for
    /apps/{appId}
    GET.
  - >-
    Relevance:
    Missing
    file
    is
    the
    core
    issue;
    its
    absence
    breaks
    QuickbaseClient.ts.
  - >-
    src/generated/apis/DefaultApi.ts:
  - >-
    Role:
    Default
    API
    class
    for
    untagged
    operations.
  - >-
    Relevance:
    Might
    contain
    getAppById
    if
    tags
    are
    misconfigured.
  - >-
    src/QuickbaseClient.ts:
  - >-
    Role:
    Wraps
    generated
    API
    classes
    (e.g.,
    AppsApi)
    in
    a
    Proxy
    for
    ergonomic
    calls
    (e.g.,
    client.getApp).
  - >-
    Relevance:
    Fails
    to
    import
    AppsApi.ts,
    causing
    the
    runtime
    error.
  - >-
    src/test.ts:
  - >-
    Role:
    Test
    script
    calling
    client.getApp({
    appId
    }).
  - >-
    Relevance:
    Final
    validation
    point;
    shows
    if
    the
    fix
    works.
  - >-
    .env.development:
  - >-
    Role:
    Stores
    QB_REALM,
    QB_USER_TOKEN,
    QB_APP_ID
    for
    API
    authentication.
  - >-
    Relevance:
    Ensures
    the
    API
    call
    has
    valid
    credentials
    (not
    the
    current
    issue,
    but
    critical
    for
    success).
  - >-
    src/specs/QuickBase_RESTful_API_2025-03-04T06_22_39.725Z.json
    (or
    similar):
  - >-
    Role:
    Original
    QuickBase
    API
    spec
    before
    fix-spec.ts
    processing.
  - >-
    Relevance:
    Shows
    how
    /apps/{appId}
    was
    originally
    defined,
    helping
    identify
    conflicts.
  - >-
    package.json:
  - >-
    Role:
    Defines
    scripts
    (fix-spec,
    regenerate,
    test)
    and
    dependencies
    (e.g.,
    ts-node,
    openapi-generator-cli).
  - >-
    Relevance:
    Confirms
    script
    commands
    and
    versions
    align
    with
    our
    process.
  - >-
    What
    We
    Achieved
  - >-
    Goal
    Met:
    You
    can
    now
    call
    client.getApp({
    appId:
    "buwai2zpe"
    })
    and
    get
    the
    app
    details
    {
    id:
    'buwai2zpe',
    name:
    'qb-copy'
    }.
  - >-
    Fixes
    Applied:
  - >-
    Added
    tags:
    ["Apps"]
    in
    fix-spec.ts
    to
    ensure
    AppsApi.ts
    is
    generated
    with
    getAppById.
  - >-
    Updated
    QuickbaseClient.ts
    to:
  - >-
    Use
    prototype
    methods
    via
    Object.getOwnPropertyNames.
  - >-
    Bind
    methods
    to
    preserve
    context
    with
    .bind(api).
  - >-
    Handle
    getAppById’s
    direct
    JSON
    return
    instead
    of
    a
    Response
    object.
  - >-
    Result:
    The
    ergonomic
    API
    you
    wanted
    (client.getApp)
    works
    seamlessly
    with
    the
    generated
    AppsApi.ts.
  - >-
    Why
    It
    Works
    Now
  - >-
    fix-spec.ts:
  - >-
    Correctly
    defined
    /apps/{appId}
    with
    operationId:
    "getAppById"
    and
    tags:
    ["Apps"],
    ensuring
    AppsApi.ts
    generation.
  - >-
    regenerate-client.ts:
  - >-
    Successfully
    ran
    OpenAPI
    Generator
    to
    produce
    AppsApi.ts
    with
    getAppById.
  - >-
    QuickbaseClient.ts:
  - >-
    buildMethodMap
    now
    captures
    getAppById
    and
    maps
    it
    to
    getApp.
  - >-
    invokeMethod
    passes
    {
    appId:
    'buwai2zpe'
    }
    as
    requestParameters
    and
    handles
    the
    JSON
    response
    directly.
  - >-
    test.ts:
  - >-
    Calls
    client.getApp
    and
    logs
    the
    result,
    proving
    the
    end-to-end
    flow.
tree:
  name: >-
    .
  type: >-
    directory
  children:
    - name: >-
        .env
      type: >-
        file
    - name: >-
        .gitignore
      type: >-
        file
    - name: >-
        CHANGELOG.md
      type: >-
        file
    - name: >-
        LICENSE
      type: >-
        file
    - name: >-
        README.md
      type: >-
        file
    - name: >-
        build-common.js
      type: >-
        file
    - name: >-
        build-esm.js
      type: >-
        file
    - name: >-
        build-umd.js
      type: >-
        file
    - name: >-
        dist
      type: >-
        directory
      children:
        - name: >-
            esm
          type: >-
            directory
          children:
            - name: >-
                quickbase.d.ts
              type: >-
                file
            - name: >-
                quickbase.js
              type: >-
                file
            - name: >-
                quickbase.js.map
              type: >-
                file
            - name: >-
                quickbase.min.js
              type: >-
                file
            - name: >-
                quickbase.min.js.map
              type: >-
                file
        - name: >-
            umd
          type: >-
            directory
          children:
            - name: >-
                quickbase.umd.js
              type: >-
                file
            - name: >-
                quickbase.umd.js.map
              type: >-
                file
            - name: >-
                quickbase.umd.min.js
              type: >-
                file
            - name: >-
                quickbase.umd.min.js.map
              type: >-
                file
    - name: >-
        docs
      type: >-
        directory
      children:
        - name: >-
            .vitepress
          type: >-
            directory
          children:
            - name: >-
                cache
              type: >-
                directory
              children:
                - name: >-
                    deps
                  type: >-
                    directory
                  children:
                    - name: >-
                        @theme_index.js
                      type: >-
                        file
                    - name: >-
                        @theme_index.js.map
                      type: >-
                        file
                    - name: >-
                        _metadata.json
                      type: >-
                        file
                    - name: >-
                        chunk-5A67QEFC.js
                      type: >-
                        file
                    - name: >-
                        chunk-5A67QEFC.js.map
                      type: >-
                        file
                    - name: >-
                        chunk-7D4P4MMP.js
                      type: >-
                        file
                    - name: >-
                        chunk-7D4P4MMP.js.map
                      type: >-
                        file
                    - name: >-
                        package.json
                      type: >-
                        file
                    - name: >-
                        vitepress___@vue_devtools-api.js
                      type: >-
                        file
                    - name: >-
                        vitepress___@vue_devtools-api.js.map
                      type: >-
                        file
                    - name: >-
                        vitepress___@vueuse_core.js
                      type: >-
                        file
                    - name: >-
                        vitepress___@vueuse_core.js.map
                      type: >-
                        file
                    - name: >-
                        vue.js
                      type: >-
                        file
                    - name: >-
                        vue.js.map
                      type: >-
                        file
            - name: >-
                config.mts
              type: >-
                file
            - name: >-
                dist
              type: >-
                directory
              children:
                - name: >-
                    404.html
                  type: >-
                    file
                - name: >-
                    api-examples.html
                  type: >-
                    file
                - name: >-
                    assets
                  type: >-
                    directory
                  children:
                    - name: >-
                        api-examples.md.CRRh3xeI.js
                      type: >-
                        file
                    - name: >-
                        api-examples.md.CRRh3xeI.lean.js
                      type: >-
                        file
                    - name: >-
                        app.Yv9tMCdR.js
                      type: >-
                        file
                    - name: >-
                        chunks
                      type: >-
                        directory
                      children:
                        - name: >-
                            framework.Dh1jimFm.js
                          type: >-
                            file
                        - name: >-
                            theme.CDm2W-g2.js
                          type: >-
                            file
                    - name: >-
                        index.md.kvvDM3Wd.js
                      type: >-
                        file
                    - name: >-
                        index.md.kvvDM3Wd.lean.js
                      type: >-
                        file
                    - name: >-
                        inter-italic-cyrillic-ext.r48I6akx.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-cyrillic.By2_1cv3.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-greek-ext.1u6EdAuj.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-greek.DJ8dCoTZ.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-latin-ext.CN1xVJS-.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-latin.C2AdPX0b.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-vietnamese.BSbpV94h.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-cyrillic-ext.BBPuwvHQ.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-cyrillic.C5lxZ8CY.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-greek-ext.CqjqNYQ-.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-greek.BBVDIX6e.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-latin-ext.4ZJIpNVo.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-latin.Di8DUHzh.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-vietnamese.BjW4sHH5.woff2
                      type: >-
                        file
                    - name: >-
                        markdown-examples.md.ediKJOVO.js
                      type: >-
                        file
                    - name: >-
                        markdown-examples.md.ediKJOVO.lean.js
                      type: >-
                        file
                    - name: >-
                        style.BJrZ0CFW.css
                      type: >-
                        file
                - name: >-
                    hashmap.json
                  type: >-
                    file
                - name: >-
                    index.html
                  type: >-
                    file
                - name: >-
                    markdown-examples.html
                  type: >-
                    file
                - name: >-
                    vp-icons.css
                  type: >-
                    file
        - name: >-
            api-examples.md
          type: >-
            file
        - name: >-
            index.md
          type: >-
            file
        - name: >-
            markdown-examples.md
          type: >-
            file
        - name: >-
            node_modules
          type: >-
            directory
          children: []
    - name: >-
        docs-data
      type: >-
        directory
      children:
        - name: >-
            api-docs.json
          type: >-
            file
    - name: >-
        examples
      type: >-
        directory
      children:
        - name: >-
            quicbase-jsCDN.html
          type: >-
            file
        - name: >-
            react.js
          type: >-
            file
        - name: >-
            vanillajs.html
          type: >-
            file
    - name: >-
        index.md
      type: >-
        file
    - name: >-
        open-api
      type: >-
        directory
      children:
        - name: >-
            fix-generated.ts
          type: >-
            file
          contents: >
            //
            open-api/fix-generated.ts

            import
            fs
            from
            "fs";

            import
            path
            from
            "path";


            const
            generatedDir
            =
            path.join(__dirname,
            "../src/generated/models");

            const
            specPath
            =
            path.join(
              __dirname,
              "../specs/QuickBase_RESTful_API_2025-03-04T06_22_39.725Z.json"
            );

            const
            fixedSpecPath
            =
            path.join(__dirname,
            "output/quickbase-fixed.json");


            interface
            Spec
            {
              paths: { [key: string]: { [method: string]: Operation } };
              definitions?: { [key: string]: any };
            }


            interface
            Operation
            {
              operationId?: string;
              responses: { [status: string]: { schema?: any } };
            }


            function
            loadSpec(filePath:
            string):
            Spec
            {
              const specContent = fs.readFileSync(filePath, "utf8");
              return JSON.parse(specContent) as Spec;
            }


            function
            getRawArrayResponses(spec:
            Spec):
            Map<string,
            string>
            {
              const rawArrayMap = new Map<string, string>(); // operationId -> itemType

              for (const pathKey in spec.paths) {
                for (const method in spec.paths[pathKey]) {
                  const operation = spec.paths[pathKey][method];
                  const opId =
                    operation.operationId || `${method}${pathKey.replace(/\W/g, "")}`;
                  const response = operation.responses?.["200"]?.schema;

                  if (response?.type === "array" && response.items?.$ref) {
                    const itemType = response.items.$ref.split("/").pop()!;
                    rawArrayMap.set(opId, itemType);
                  }
                }
              }

              return rawArrayMap;
            }


            function
            fixRawArrayFiles()
            {
              const spec = loadSpec(fixedSpecPath); // Use the fixed spec
              const rawArrayResponses = getRawArrayResponses(spec);
              const files = fs
                .readdirSync(generatedDir)
                .filter((f) => f.endsWith("200Response.ts"));

              files.forEach((file) => {
                const filePath = path.join(generatedDir, file);
                let content = fs.readFileSync(filePath, "utf8");

                if (content.includes("extends Array<any>")) {
                  const responseName = file.replace(".ts", "");
                  const opIdMatch = responseName.match(/^([A-Za-z]+)\d+Response$/);
                  const opId = opIdMatch
                    ? opIdMatch[1]
                    : responseName.replace("200Response", "");

                  const itemType = rawArrayResponses.get(opId);
                  if (!itemType) {
                    console.warn(
                      `No item type found for ${opId} in spec, skipping ${file}`
                    );
                    return;
                  }

                  content = content
                    .replace(
                      `export interface ${responseName} extends Array<any> {}`,
                      `export type ${responseName} = Array<${itemType}>`
                    )
                    .replace(
                      `export function ${responseName}FromJSONTyped(json: any, ignoreDiscriminator: boolean): ${responseName} {\n    return json;\n}`,
                      `export function ${responseName}FromJSONTyped(json: any, ignoreDiscriminator: boolean): ${responseName} {
                        if (json == null) return [];
                        return json.map(${itemType}FromJSON);
                      }`
                    )
                    .replace(
                      `export function ${responseName}ToJSON(value?: ${responseName} | null): any {\n    return value;\n}`,
                      `export function ${responseName}ToJSON(value?: ${responseName} | null): any {
                        if (value == null) return value;
                        return value.map(${itemType}ToJSON);
                      }`
                    );

                  // Ensure import for itemType (e.g., Field, Event)
                  if (!content.includes(`import { ${itemType}FromJSON`)) {
                    content = `import { ${itemType}FromJSON, ${itemType}ToJSON } from './${itemType}';\n${content}`;
                  }

                  fs.writeFileSync(filePath, content, { encoding: "utf8" });
                  console.log(`Fixed ${file} to use Array<${itemType}>`);
                }
              });
            }


            fixRawArrayFiles();
        - name: >-
            fix-spec-main.ts
          type: >-
            file
          contents: >
            #!/usr/bin/env
            node


            import
            {
            promises
            as
            fs
            }
            from
            "fs";

            import
            path
            from
            "path";

            import
            {
            fileURLToPath
            }
            from
            "url";

            import
            *
            as
            glob
            from
            "glob";

            import
            {
            Spec
            }
            from
            "./types/spec.ts";

            import
            {
            toCamelCase
            }
            from
            "./utils/naming.ts";


            async
            function
            fixQuickBaseSpec():
            Promise<void>
            {
              const CODEGEN_DIR = path.dirname(fileURLToPath(import.meta.url));
              const SPECS_DIR = path.join(CODEGEN_DIR, "..", "specs");
              const OUTPUT_DIR = path.join(CODEGEN_DIR, "output");
              console.log("Finding latest QuickBase RESTful API spec...");
              const specFiles = glob.sync(path.join(SPECS_DIR, "QuickBase_RESTful_*.json"));
              console.log("Spec files:", specFiles);

              if (specFiles.length === 0) {
                throw new Error(
                  "No QuickBase_RESTful_*.json files found in specs/ folder."
                );
              }

              const inputFile = specFiles.sort().pop() as string;
              const outputFile = path.join(OUTPUT_DIR, "quickbase-fixed.json");

              console.log(`Reading ${path.basename(inputFile)} from specs/...`);
              const specContent = await fs.readFile(inputFile, "utf8");
              console.log("File read successfully");
              const spec: Spec = JSON.parse(specContent);
              console.log("JSON parsed successfully");

              if (!spec.definitions || typeof spec.definitions !== "object") {
                spec.definitions = {};
              }
              console.log("Spec definitions after initialization:", spec.definitions);

              console.log(
                "Original /apps/{appId}/events 200 schema:",
                JSON.stringify(
                  spec.paths["/apps/{appId}/events"]?.get?.responses?.["200"]?.schema,
                  null,
                  2
                )
              );

              console.log("Fixing parameters...");
              for (const pathKey in spec.paths) {
                for (const method in spec.paths[pathKey]) {
                  const operation = spec.paths[pathKey][method];
                  if (operation.parameters) {
                    operation.parameters = operation.parameters
                      .filter(
                        (param) =>
                          !["QB-Realm-Hostname", "Authorization", "User-Agent"].includes(
                            param.name
                          )
                      )
                      .map((param) => {
                        param.name = toCamelCase(param.name);
                        if ("example" in param) delete param.example;
                        if ("schema" in param && param.in !== "body") delete param.schema;
                        if (!param.type && param.in !== "body") {
                          param.type = param.name.includes("Id") ? "string" : "string";
                          console.log(
                            `Set default type 'string' for ${pathKey}(${method}).${param.name}`
                          );
                        }
                        return param;
                      });
                  }
                }
              }

              console.log("Spec definitions before enhanceTags:", spec.definitions);
              console.log("Enhancing raw spec with tags...");
              const { enhanceTags } = await import("./schema/tags/index.ts");
              enhanceTags(spec);
              console.log(
                "After enhanceTags:",
                JSON.stringify(
                  spec.paths["/apps/{appId}/events"]?.get?.responses?.["200"]?.schema,
                  null,
                  2
                )
              );

              console.log("Enhancing raw spec with general enhancements...");
              const { enhanceGeneral } = await import("./schema/enhance-general.ts");
              enhanceGeneral(spec);
              console.log(
                "After enhanceGeneral:",
                JSON.stringify(
                  spec.paths["/apps/{appId}/events"]?.get?.responses?.["200"]?.schema,
                  null,
                  2
                )
              );

              console.log("Fixing array schemas...");
              const { fixArrays } = await import("./schema/fix-arrays.ts");
              fixArrays(spec);
              console.log(
                "After fixArrays:",
                JSON.stringify(
                  spec.paths["/apps/{appId}/events"]?.get?.responses?.["200"]?.schema,
                  null,
                  2
                )
              );

              console.log("Removing unexpected top-level attributes...");
              delete spec.operations;
              delete spec.groups;
              delete spec.components;

              console.log(`Writing fixed spec to ${path.basename(outputFile)}...`);
              await fs.mkdir(OUTPUT_DIR, { recursive: true });
              await fs.writeFile(outputFile, JSON.stringify(spec, null, 2), "utf8");
              console.log("Spec fixed successfully! Output written to:", outputFile);
            }


            async
            function
            main()
            {
              try {
                console.log("Starting...");
                await fixQuickBaseSpec();
              } catch (error) {
                console.error("Error:", error);
                process.exit(1);
              }
            }


            main();
        - name: >-
            generate-unified-interface.ts
          type: >-
            file
          contents: >
            #!/usr/bin/env
            node


            console.log("Script
            started");


            import
            {
            readFileSync,
            writeFileSync,
            mkdirSync,
            existsSync
            }
            from
            "fs";

            console.log("FS
            modules
            imported");


            import
            {
            join,
            dirname
            }
            from
            "path";

            console.log("Path
            modules
            imported");


            import
            {
            fileURLToPath
            }
            from
            "url";

            console.log("URL
            module
            imported");


            import
            {
            generateJsDoc
            }
            from
            "./utils/generateJsDoc.ts";

            import
            {
              PropertyDetail,
              ParamDetail,
              JsDocOptions,
              mapOpenApiTypeToTs,
              mapRefToType,
              parseInterfaceProperties,
              parseOpenApiOperations,
            }
            from
            "./utils/sharedUtils.ts";

            import
            {
            writeFileSafe,
            runTask
            }
            from
            "./utils/common.ts";


            const
            __dirname
            =
            dirname(fileURLToPath(import.meta.url));

            console.log("__dirname
            set:",
            __dirname);


            const
            SPEC_FILE
            =
            join(__dirname,
            "output",
            "quickbase-fixed.json");

            const
            OUTPUT_DIR
            =
            join(__dirname,
            "..",
            "src",
            "generated-unified");

            const
            OUTPUT_FILE
            =
            join(OUTPUT_DIR,
            "QuickbaseClient.ts");

            const
            MODELS_DIR
            =
            join(__dirname,
            "..",
            "src",
            "generated",
            "models");


            function
            generateInterface(includeResponseProperties:
            boolean
            =
            false):
            void
            {
              console.log(
                "Generating interface with includeResponseProperties:",
                includeResponseProperties
              );

              console.log("Checking spec file:", SPEC_FILE);
              if (!existsSync(SPEC_FILE)) {
                console.error(
                  `Spec file ${SPEC_FILE} not found. Run 'npm run fix-spec' first.`
                );
                process.exit(1);
              }

              console.log("Checking models directory:", MODELS_DIR);
              if (!existsSync(MODELS_DIR)) {
                console.error(
                  `Models directory ${MODELS_DIR} not found. Run 'npm run gen:openapi' first.`
                );
                process.exit(1);
              }

              const { operations, modelImports, missingTypes } = parseOpenApiOperations(
                SPEC_FILE,
                MODELS_DIR
              );
              console.log("Operations parsed:", operations.length);

              const methods: string[] = operations.map((op) => {
                const params = op.parameters
                  .map((p) => `${p.name}${p.required ? "" : "?"}: ${p.type}`)
                  .join("; ");
                const jsDocOptions: JsDocOptions = {
                  summary: op.summary,
                  opId: op.name,
                  paramDetails: op.parameters,
                  returnType: op.returns,
                  returnTypeDetails: includeResponseProperties
                    ? op.returnTypeDetails || []
                    : [],
                  docLink: op.docLink,
                };
                const jsDoc = generateJsDoc(jsDocOptions);
                return `${jsDoc}\n  ${op.name}: (params: { ${params} }) => Promise<${op.returns}>;`;
              });

              console.log("Writing missing types report...");
              writeFileSafe(
                join(OUTPUT_DIR, "missing-types-report.json"),
                JSON.stringify({ missingTypes: Array.from(missingTypes) }, null, 2)
              );

              const importStatement =
                modelImports.size > 0
                  ? `import { ${Array.from(modelImports)
                      .sort()
                      .join(", ")} } from "../generated/models";`
                  : "";
              const interfaceContent = `// Generated on ${new Date().toISOString()}\n${importStatement}\n\nexport interface QuickbaseClient {\n${methods.join(
                "\n"
              )}\n}\n`;

              console.log("Ensuring output directory exists and writing interface...");
              writeFileSafe(OUTPUT_FILE, interfaceContent);
              console.log("Generated:", OUTPUT_FILE);
            }


            console.log("Entering
            runTask
            block");

            runTask("generateInterface",
            ()
            =>
            generateInterface(true));


            console.log("Script
            completed");
        - name: >-
            generateDocsJson.ts
          type: >-
            file
          contents: >
            #!/usr/bin/env
            node


            import
            {
            writeFileSync,
            existsSync,
            mkdirSync
            }
            from
            "fs";

            import
            {
            join,
            dirname
            }
            from
            "path";

            import
            {
            fileURLToPath
            }
            from
            "url";

            import
            {
            parseOpenApiOperations
            }
            from
            "./utils/sharedUtils.ts";

            import
            {
            writeFileSafe,
            runTask
            }
            from
            "./utils/common.ts";


            const
            __dirname
            =
            dirname(fileURLToPath(import.meta.url));

            const
            SPEC_FILE
            =
            join(__dirname,
            "output",
            "quickbase-fixed.json");

            const
            MODELS_DIR
            =
            join(__dirname,
            "..",
            "src",
            "generated",
            "models");

            const
            DOCS_DATA_DIR
            =
            join(__dirname,
            "..",
            "docs-data");

            const
            DOCS_JSON_FILE
            =
            join(DOCS_DATA_DIR,
            "api-docs.json");


            function
            generateDocsJson():
            void
            {
              console.log("Generating docs JSON...");
              const { operations } = parseOpenApiOperations(SPEC_FILE, MODELS_DIR);
              writeFileSafe(DOCS_JSON_FILE, JSON.stringify(operations, null, 2), "utf8");
              console.log("Generated docs JSON:", DOCS_JSON_FILE);
            }


            runTask("generateDocsJson",
            generateDocsJson);


            console.log("Script
            completed");
        - name: >-
            post-process-generated.ts
          type: >-
            file
          contents: >
            #!/usr/bin/env
            node


            import
            {
            readFileSync,
            writeFileSync,
            existsSync,
            mkdirSync
            }
            from
            "fs";

            import
            {
            join,
            dirname
            }
            from
            "path";

            import
            {
            fileURLToPath
            }
            from
            "url";


            const
            __dirname
            =
            dirname(fileURLToPath(import.meta.url));

            const
            GENERATED_DIR
            =
            join(__dirname,
            "..",
            "src",
            "generated");

            const
            MODELS_DIR
            =
            join(GENERATED_DIR,
            "models");

            const
            SPEC_FILE
            =
            join(__dirname,
            "output",
            "quickbase-fixed.json");


            function
            toPascalCase(str:
            string):
            string
            {
              return str.replace(/(^\w|_\w)/g, (match) =>
                match.replace("_", "").toUpperCase()
              );
            }


            function
            ensureDir(dir:
            string)
            {
              if (!existsSync(dir)) {
                mkdirSync(dir, { recursive: true });
              }
            }


            function
            mapOpenApiTypeToTs(openApiType:
            string):
            string
            {
              switch (openApiType) {
                case "integer":
                case "number":
                  return "number";
                case "string":
                  return "string";
                case "boolean":
                  return "boolean";
                case "object":
                  return "object";
                default:
                  return "any";
              }
            }


            function
            generateItemsInnerInterface(
              itemSchema: any,
              itemName: string
            ):
            string
            {
              const properties = itemSchema?.properties || {};
              const propsStr = Object.entries(properties)
                .map(([key, prop]: [string, any]) => {
                  let type;
                  if (key === "permissions" && prop.type === "array") {
                    type = "Permission[]";
                  } else if (key === "properties" && prop.type === "object") {
                    type = "{ [key: string]: any }";
                  } else {
                    type = mapOpenApiTypeToTs(prop.type);
                  }
                  const isRequired = itemSchema.required?.includes(key);
                  const description = prop.description ? ` * ${prop.description}` : "";
                  return `  /**
            ${description}
             * @type {${type}}
             */
              ${key}${isRequired ? "" : "?"}: ${type};`;
                })
                .join("\n");

              const additionalProps =
                itemSchema.additionalProperties === true
                  ? `  /**
               * Allows additional unspecified properties
               * @type {any}
               */
              [key: string]: any;`
                  : "";

              return `
            /*
            Auto-generated
            by
            post-process-generated.ts
            */

            import
            {
            mapValues
            }
            from
            '../runtime';

            import
            {
            Permission
            }
            from
            './Permission';


            /**
             * Auto-generated model for ${itemName}
             */
            export
            interface
            ${itemName}
            {

            ${propsStr}

            ${additionalProps}

            }


            export
            function
            ${itemName}FromJSON(json:
            any):
            ${itemName}
            {
              return json || {};
            }


            export
            function
            ${itemName}ToJSON(value?:
            ${itemName}
            |
            null):
            any
            {
              return value || {};
            }
              `.trim();
            }


            function
            postProcessGeneratedFiles()
            {
              console.log("Starting post-processing...");
              console.log("Spec file path:", SPEC_FILE);

              try {
                if (!existsSync(SPEC_FILE)) {
                  console.error(
                    `Spec file ${SPEC_FILE} not found. Run 'npm run fix-spec' first.`
                  );
                  process.exit(1);
                }

                const spec = JSON.parse(readFileSync(SPEC_FILE, "utf8"));
                console.log("Spec loaded successfully.");

                const responseMap: Record<string, string> = {};
                for (const pathKey in spec.paths) {
                  const pathObj = spec.paths[pathKey];
                  if (!pathObj || typeof pathObj !== "object") continue;
                  for (const method in pathObj) {
                    const operation = pathObj[method];
                    const opId =
                      operation.operationId || `${method}${pathKey.replace(/\W/g, "")}`;
                    const response = operation.responses?.["200"];
                    if (response && response.schema?.$ref) {
                      const refName = response.schema.$ref.split("/").pop() || "";
                      responseMap[opId] = refName;
                      console.log(`Mapped ${opId} to ${refName}`);
                    }
                  }
                }

                for (const [opId, refName] of Object.entries(responseMap)) {
                  try {
                    const def = spec.definitions[refName];
                    if (!def) {
                      console.log(`Definition for ${refName} not found; skipping`);
                      continue;
                    }

                    const responseFile = join(MODELS_DIR, `${toPascalCase(refName)}.ts`);

                    if (def.type === "array") {
                      const itemRef = def.items?.$ref
                        ? def.items.$ref.split("/").pop()
                        : `${toPascalCase(refName)}ItemsInner`;
                      const itemsFile = join(MODELS_DIR, `${itemRef}.ts`);

                      if (!existsSync(itemsFile)) {
                        console.log(`Creating missing ${itemRef}.ts`);
                        const content = def.items?.$ref
                          ? `
            /*
            Auto-generated
            by
            post-process-generated.ts
            */

            import
            {
            mapValues
            }
            from
            '../runtime';


            /**
             * Auto-generated model for ${itemRef}
             */
            export
            interface
            ${itemRef}
            {
              [key: string]: any; // Placeholder; refine as needed
            }


            export
            function
            ${itemRef}FromJSON(json:
            any):
            ${itemRef}
            {
              return json || {};
            }


            export
            function
            ${itemRef}ToJSON(value?:
            ${itemRef}
            |
            null):
            any
            {
              return value || {};
            }
                        `
                          : generateItemsInnerInterface(def.items || {}, itemRef);
                        ensureDir(MODELS_DIR);
                        writeFileSync(itemsFile, content.trim(), "utf8");
                      }

                      if (existsSync(responseFile)) {
                        console.log(`Rewriting ${refName}.ts as array`);
                        const content = `
            /*
            Auto-generated
            by
            post-process-generated.ts
            */

            import
            {
            ${itemRef},
            ${itemRef}FromJSON,
            ${itemRef}ToJSON
            }
            from
            './${itemRef}';


            /**
             * Response for ${opId}
             */
            export
            type
            ${toPascalCase(refName)}
            =
            ${itemRef}[];


            /**
             * Convert JSON to ${toPascalCase(refName)}
             */
            export
            function
            ${toPascalCase(refName)}FromJSON(json:
            any):
            ${toPascalCase(
                          refName
                        )} {
              if (!json) return [];
              return json.map(${itemRef}FromJSON);
            }


            /**
             * Convert ${toPascalCase(refName)} to JSON
             */
            export
            function
            ${toPascalCase(refName)}ToJSON(value?:
            ${toPascalCase(
                          refName
                        )} | null): any {
              if (!value) return [];
              return value.map(${itemRef}ToJSON);
            }
                        `;
                        writeFileSync(responseFile, content.trim(), "utf8");
                      }
                    } else if (def.type === "object") {
                      console.log(`Processing ${refName}.ts as object`);
                      const content = generateItemsInnerInterface(
                        def,
                        toPascalCase(refName)
                      );
                      ensureDir(MODELS_DIR);
                      writeFileSync(responseFile, content.trim(), "utf8");
                    }
                  } catch (error) {
                    console.error(`Error processing ${refName}:`, error);
                  }
                }

                console.log("Post-processing complete.");
              } catch (error) {
                console.error("Error in post-processing:", error);
                process.exit(1);
              }
            }


            postProcessGeneratedFiles();
        - name: >-
            regenerate-client.ts
          type: >-
            file
          contents: >
            #!/usr/bin/env
            node


            import
            {
            execSync
            }
            from
            "child_process";

            import
            {
            existsSync
            }
            from
            "fs";

            import
            {
            join
            }
            from
            "path";

            import
            {
            fileURLToPath
            }
            from
            "url";

            import
            fetch
            from
            "node-fetch";

            import
            readline
            from
            "readline";


            const
            CURRENT_JAR_VERSION
            =
            "7.12.0";

            const
            MAVEN_METADATA_URL
            =
              "https://repo1.maven.org/maven2/org/openapitools/openapi-generator-cli/maven-metadata.xml";
            const
            CODEGEN_DIR
            =
            join(fileURLToPath(import.meta.url),
            "..");

            const
            JARS_DIR
            =
            join(CODEGEN_DIR,
            "..",
            "tools",
            "openapi-jars");

            const
            SPEC_INPUT
            =
            join(CODEGEN_DIR,
            "output",
            "quickbase-fixed.json");

            const
            OUTPUT_DIR
            =
            join(CODEGEN_DIR,
            "..",
            "src",
            "generated");


            async
            function
            getLatestVersion():
            Promise<string>
            {
              const response = await fetch(MAVEN_METADATA_URL);
              if (!response.ok)
                throw new Error(`Failed to fetch Maven metadata: ${response.statusText}`);
              const text = await response.text();
              const match = text.match(/<latest>(.*?)<\/latest>/);
              if (!match)
                throw new Error("Couldn’t parse latest version from Maven metadata");
              return match[1];
            }


            async
            function
            checkAndPromptForUpdate(messages:
            string[]):
            Promise<string>
            {
              const latestVersion = await getLatestVersion();
              if (latestVersion === CURRENT_JAR_VERSION) {
                messages.push(`Current version (${CURRENT_JAR_VERSION}) is the latest.`);
                return CURRENT_JAR_VERSION;
              }

              messages.push(
                `Newer version available: ${latestVersion} (current: ${CURRENT_JAR_VERSION})`
              );
              const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout,
              });

              return new Promise((resolve) => {
                const prompt = "Do you want to update to the latest version? (y/n): ";
                messages.push(prompt);
                rl.question(prompt, (answer) => {
                  rl.close();
                  if (answer.toLowerCase() === "y" || answer.toLowerCase() === "yes") {
                    messages.push(`Switching to version ${latestVersion}...`);
                    resolve(latestVersion);
                  } else {
                    messages.push(`Sticking with version ${CURRENT_JAR_VERSION}.`);
                    resolve(CURRENT_JAR_VERSION);
                  }
                });
              });
            }


            async
            function
            ensureJarExists(
              version: string,
              messages: string[]
            ):
            Promise<string>
            {
              const jarPath = join(JARS_DIR, `openapi-generator-cli-${version}.jar`);
              const jarUrl = `https://repo1.maven.org/maven2/org/openapitools/openapi-generator-cli/${version}/openapi-generator-cli-${version}.jar`;

              if (!existsSync(jarPath)) {
                messages.push(`Downloading OpenAPI Generator CLI v${version}...`);
                try {
                  execSync(`curl -L -o ${jarPath} ${jarUrl}`, { stdio: "inherit" });
                  messages.push(`Downloaded ${jarPath}`);
                } catch (error) {
                  messages.push("Failed to download JAR.");
                  throw error;
                }
              } else {
                messages.push(`Using existing ${jarPath}`);
              }
              return jarPath;
            }


            function
            regenerateClient(jarPath:
            string,
            messages:
            string[])
            {
              messages.push("Regenerating client from spec...");
              const command = `java -jar ${jarPath} generate -i ${SPEC_INPUT} -g typescript-fetch -o ${OUTPUT_DIR} --additional-properties=generateAliasAsModel=true,withInterfaces=true,supportsES6=true,modelPropertyNaming=original`;
              try {
                execSync(command, { stdio: "inherit" });
                messages.push("Client regeneration complete.");
              } catch (error) {
                messages.push("Regeneration failed.");
                throw error;
              }
            }


            async
            function
            main()
            {
              const messages: string[] = [];
              try {
                if (!existsSync(SPEC_INPUT)) {
                  console.error(
                    `Spec file ${SPEC_INPUT} does not exist. Run 'npm run fix-spec' first.`
                  );
                  process.exit(1);
                }
                const versionToUse = await checkAndPromptForUpdate(messages);
                const jarPath = await ensureJarExists(versionToUse, messages);
                regenerateClient(jarPath, messages);
              } catch (error) {
                console.error("Error occurred during process:", error);
              } finally {
                console.log("\n--- Key Messages ---");
                messages.forEach((msg) => console.log(msg));
              }
            }


            main().catch((error)
            =>
            {
              console.error("Error in regeneration process:", error);
              process.exit(1);
            });
        - name: >-
            schema
          type: >-
            directory
          children:
            - name: >-
                enhance-general.ts
              type: >-
                file
              contents: >
                import
                {
                Operation,
                Parameter,
                Spec
                }
                from
                "../types/spec.ts";

                import
                {
                inferSchema
                }
                from
                "../utils/infer-schema.ts";


                export
                function
                enhanceGeneral(spec:
                Spec):
                void
                {
                  spec.definitions = spec.definitions || {};

                  if (!spec.definitions["Record"]) {
                    spec.definitions["Record"] = {
                      type: "object",
                      additionalProperties: {
                        type: "object",
                        properties: { value: { type: "string" } },
                        required: ["value"],
                      },
                      description: "A generic QuickBase record with field ID-value pairs",
                    };
                    console.log("Added Record to definitions");
                  }

                  if (!spec.definitions["Permission"]) {
                    spec.definitions["Permission"] = {
                      type: "object",
                      properties: {
                        role: { type: "string", description: "The role name" },
                        permissionType: {
                          type: "string",
                          description: "Permission type (e.g., View, Modify)",
                        },
                        roleId: { type: "integer", description: "The role identifier" },
                      },
                      required: ["role", "permissionType", "roleId"],
                      description: "A single permission entry for a field",
                    };
                    console.log("Added Permission to definitions");
                  }

                  for (const pathKey in spec.paths) {
                    for (const method in spec.paths[pathKey]) {
                      const operation: Operation = spec.paths[pathKey][method];
                      const opId =
                        operation.operationId || `${method}${pathKey.replace(/\W/g, "")}`;

                      if (operation.parameters) {
                        operation.parameters.forEach((param: Parameter) => {
                          if (param.in !== "body" && !param.type && !param.schema) {
                            param.type = param.name.includes("Id") ? "string" : "string";
                            console.log(
                              `Set default type 'string' for ${pathKey}(${method}).${param.name}`
                            );
                          }
                        });
                      }

                      if (operation.responses) {
                        for (const status in operation.responses) {
                          const response = operation.responses[status];
                          if (response.schema) {
                            const cleanStatus = status.replace("/", "_");
                            const responseName = `${opId}${cleanStatus}Response`;
                            if (!spec.definitions[responseName]) {
                              console.log(
                                `Adding ${responseName} to definitions for ${pathKey}(${method})`
                              );
                              let schemaToUse = response.schema;
                              // Only infer from example if schema is truly empty
                              if (
                                !schemaToUse.type &&
                                !schemaToUse.items &&
                                !schemaToUse.properties
                              ) {
                                if (response["x-amf-mediaType"]) {
                                  const mediaType = response["x-amf-mediaType"];
                                  if (mediaType === "application/octet-stream") {
                                    schemaToUse = {
                                      type: "object",
                                      properties: {
                                        data: { type: "string", format: "binary" },
                                      },
                                      description:
                                        schemaToUse?.description || "Binary file content",
                                    };
                                  } else if (mediaType === "application/x-yaml") {
                                    schemaToUse = {
                                      type: "object",
                                      properties: {
                                        content: { type: "string", format: "yaml" },
                                      },
                                      description: "YAML-formatted data",
                                    };
                                  } else if (
                                    mediaType === "application/json" &&
                                    schemaToUse.example
                                  ) {
                                    schemaToUse = inferSchema(
                                      schemaToUse.example,
                                      responseName
                                    );
                                    schemaToUse.description =
                                      response.description || `Response for ${opId}`;
                                  }
                                }
                              }
                              spec.definitions[responseName] = schemaToUse;
                            }
                            response.schema = { $ref: `#/definitions/${responseName}` };
                          }
                        }
                      }
                    }
                  }
                }
            - name: >-
                fix-arrays.ts
              type: >-
                file
              contents: >
                //
                schema/fix-arrays.ts

                import
                {
                Parameter,
                Spec
                }
                from
                "../types/spec.ts";


                export
                function
                fixArrays(spec:
                Spec):
                void
                {
                  for (const pathKey in spec.paths) {
                    for (const method in spec.paths[pathKey]) {
                      const operation = spec.paths[pathKey][method];
                      if (operation.parameters) {
                        operation.parameters.forEach((param: Parameter) => {
                          if (param.schema?.type === "array" && !param.schema.items) {
                            console.log(
                              `Fixing array schema for ${pathKey}(${method}).${param.name}`
                            );
                            param.schema.items = { type: "string" };
                          }
                          if (param.schema?.properties) {
                            for (const propKey in param.schema.properties) {
                              const prop = param.schema.properties[propKey];
                              if (prop.type === "array" && !prop.items) {
                                console.log(
                                  `Fixing nested array for ${pathKey}(${method}).${param.name}.${propKey}`
                                );
                                prop.items = { type: "string" };
                              }
                            }
                          }
                        });
                      }
                      if (operation.responses) {
                        for (const status in operation.responses) {
                          const response = operation.responses[status];
                          if (response.schema?.type === "array" && !response.schema.items) {
                            console.log(
                              `Fixing array schema for ${pathKey}(${method}).responses.${status}`
                            );
                            response.schema.items = { type: "string" };
                          }
                          if (response.schema?.properties) {
                            for (const propKey in response.schema.properties) {
                              const prop = response.schema.properties[propKey];
                              if (prop.type === "array" && !prop.items) {
                                console.log(
                                  `Fixing nested array for ${pathKey}(${method}).responses.${status}.${propKey}`
                                );
                                prop.items = { type: "string" };
                              }
                            }
                          }
                        }
                      }
                    }
                  }

                  console.log("Fixing array schemas in definitions...");
                  const definitions = spec.definitions || {};
                  for (const defKey in definitions) {
                    const def = definitions[defKey];
                    if (def.properties) {
                      for (const propKey in def.properties) {
                        const prop = def.properties[propKey];
                        if (prop.type === "array" && !prop.items) {
                          console.log(`Fixing missing items in ${defKey}.${propKey}`);
                          prop.items = { type: "string" };
                        }
                      }
                    }
                  }
                }
            - name: >-
                tags
              type: >-
                directory
              children:
                - name: >-
                    apps.ts
                  type: >-
                    file
                  contents: >
                    //
                    schema/tags/apps.ts

                    import
                    {
                    Operation,
                    Parameter,
                    Spec
                    }
                    from
                    "../../types/spec.ts";

                    import
                    {
                    normalizeDefinitionName
                    }
                    from
                    "../../utils/naming.ts";


                    export
                    function
                    enhanceApps(
                      spec: Spec,
                      pathKey: string,
                      method: string,
                      operation: Operation
                    ):
                    void
                    {
                      const opId =
                        operation.operationId || `${method}${pathKey.replace(/\W/g, "")}`;
                      if (operation.parameters && operation.tags?.includes("Apps")) {
                        operation.parameters.forEach((param: Parameter) => {
                          if (param.in === "body") {
                            if (!param.schema) param.schema = {};
                            let requestName =
                              param.schema.$ref?.split("/").pop() || `${opId}Request`;
                            requestName = normalizeDefinitionName(requestName);

                            if (
                              !spec.definitions[requestName] ||
                              !spec.definitions[requestName].type ||
                              Object.keys(spec.definitions[requestName]?.properties || {})
                                .length === 0
                            ) {
                              console.log(
                                `Defining schema for ${requestName} in ${pathKey}(${method})`
                              );
                              let properties;
                              if (pathKey.includes("/copy") && method === "post") {
                                properties = {
                                  name: { type: "string", description: "The name of the new app." },
                                  description: {
                                    type: "string",
                                    description: "A description for the new app.",
                                  },
                                  properties: {
                                    type: "object",
                                    properties: {
                                      keepData: {
                                        type: "boolean",
                                        description: "Whether to copy data.",
                                      },
                                      excludeFiles: {
                                        type: "boolean",
                                        description: "Whether to exclude files.",
                                      },
                                      usersAndRoles: {
                                        type: "boolean",
                                        description: "Whether to copy users and roles.",
                                      },
                                      assignUserToken: {
                                        type: "boolean",
                                        description: "Whether to assign the user token.",
                                      },
                                    },
                                    description: "Options for customizing the app copy process.",
                                  },
                                };
                              } else {
                                properties = {
                                  name: { type: "string", description: "The name of the app." },
                                  description: {
                                    type: "string",
                                    description: "A description for the app.",
                                  },
                                  assignToken: {
                                    type: "boolean",
                                    description: "Whether to assign the user token.",
                                  },
                                };
                              }
                              spec.definitions[requestName] = {
                                type: "object",
                                properties,
                                required: Object.keys(properties).filter(
                                  (key) => key !== "description" && key !== "properties"
                                ),
                                description: operation.summary || `Request body for ${opId}`,
                              };
                            }
                            param.schema = { $ref: `#/definitions/${requestName}` };
                            console.log(
                              `Ensured ${requestName} in definitions for ${pathKey}(${method})`
                            );
                          }
                        });
                      }
                    }
                - name: >-
                    fields.ts
                  type: >-
                    file
                  contents: >
                    //
                    schema/tags/fields.ts

                    import
                    {
                    Operation,
                    Parameter,
                    Spec
                    }
                    from
                    "../../types/spec.ts";

                    import
                    {
                    normalizeDefinitionName
                    }
                    from
                    "../../utils/naming.ts";


                    export
                    function
                    enhanceFields(
                      spec: Spec,
                      pathKey: string,
                      method: string,
                      operation: Operation
                    ):
                    void
                    {
                      const opId =
                        operation.operationId || `${method}${pathKey.replace(/\W/g, "")}`;
                      if (operation.parameters && operation.tags?.includes("Fields")) {
                        operation.parameters.forEach((param: Parameter) => {
                          if (param.in === "body") {
                            if (!param.schema) param.schema = {};
                            let requestName =
                              param.schema.$ref?.split("/").pop() || `${opId}Request`;
                            requestName = normalizeDefinitionName(requestName);

                            if (
                              !spec.definitions[requestName] ||
                              !spec.definitions[requestName].type ||
                              Object.keys(spec.definitions[requestName]?.properties || {})
                                .length === 0
                            ) {
                              console.log(
                                `Defining schema for ${requestName} in ${pathKey}(${method})`
                              );
                              let properties;
                              let requiredFields: string[];

                              if (method === "delete") {
                                // DELETE /fields (deleteFields)
                                properties = {
                                  fieldIds: { type: "array", items: { type: "integer" } },
                                };
                                requiredFields = ["fieldIds"];
                              } else {
                                // Common properties for createField and updateField
                                properties = {
                                  label: { type: "string", description: "The label of the field" },
                                  fieldType: {
                                    type: "string",
                                    description: "The type of the field",
                                    enum: [
                                      "text",
                                      "text-multiple-choice",
                                      "text-multi-line",
                                      "rich-text",
                                      "numeric",
                                      "currency",
                                      "percent",
                                      "rating",
                                      "date",
                                      "date-time",
                                      "time-of-day",
                                      "duration",
                                      "checkbox",
                                      "user",
                                      "multi-user",
                                      "address",
                                      "email",
                                      "phone",
                                      "url",
                                      "file",
                                      "record-id",
                                    ],
                                  },
                                  fieldHelp: {
                                    type: "string",
                                    description: "Help text for the field",
                                    nullable: true,
                                  },
                                  addToForms: {
                                    type: "boolean",
                                    description: "Whether to add the field to forms",
                                    nullable: true,
                                  },
                                  permissions: {
                                    anyOf: [
                                      {
                                        type: "array",
                                        items: { $ref: "#/definitions/Permission" },
                                      },
                                      { type: "null" },
                                    ],
                                    description: "Custom permissions for the field",
                                  },
                                  required: {
                                    type: "boolean",
                                    description: "Whether the field is required",
                                    nullable: true,
                                  },
                                  unique: {
                                    type: "boolean",
                                    description: "Whether the field must have unique values",
                                    nullable: true,
                                  },
                                  noWrap: {
                                    type: "boolean",
                                    description: "Whether text wrapping is disabled",
                                    nullable: true,
                                  },
                                  bold: {
                                    type: "boolean",
                                    description: "Whether the field is bolded",
                                    nullable: true,
                                  },
                                  appearsByDefault: {
                                    type: "boolean",
                                    description: "Whether the field appears by default in reports",
                                    nullable: true,
                                  },
                                  findEnabled: {
                                    type: "boolean",
                                    description: "Whether the field is searchable",
                                    nullable: true,
                                  },
                                  doesDataCopy: {
                                    type: "boolean",
                                    description: "Whether the field copies data",
                                    nullable: true,
                                  },
                                  audited: {
                                    type: "boolean",
                                    description: "Whether changes to the field are audited",
                                    nullable: true,
                                  },
                                  properties: {
                                    type: "object",
                                    description: "Specific field properties",
                                    properties: {
                                      numLines: {
                                        type: "integer",
                                        description:
                                          "The number of lines shown in QuickBase for this text field",
                                      },
                                      maxLength: {
                                        type: "integer",
                                        description:
                                          "The maximum number of characters allowed for entry",
                                      },
                                      appendOnly: {
                                        type: "boolean",
                                        description: "Whether this field is append-only",
                                      },
                                      sortAsGiven: {
                                        type: "boolean",
                                        description:
                                          "Indicates if the listed entries sort as entered vs alphabetically",
                                      },
                                      allowMentions: {
                                        type: "boolean",
                                        description:
                                          "If someone can @mention users in the rich text field",
                                      },
                                      comments: {
                                        type: "string",
                                        description:
                                          "The comments entered on the field properties by an administrator",
                                      },
                                      doesTotal: {
                                        type: "boolean",
                                        description:
                                          "Whether this field totals in reports within the product",
                                      },
                                      autoSave: {
                                        type: "boolean",
                                        description: "Whether the link field will auto save",
                                      },
                                      defaultValueLuid: {
                                        type: "integer",
                                        description: "Default user id value",
                                      },
                                      useI18NFormat: {
                                        type: "boolean",
                                        description:
                                          "Whether phone numbers should be in E.164 standard international format",
                                      },
                                      maxVersions: {
                                        type: "integer",
                                        description:
                                          "The maximum number of versions configured for a file attachment",
                                      },
                                      format: {
                                        type: "integer",
                                        description: "The format to display time",
                                      },
                                      carryChoices: {
                                        type: "boolean",
                                        description:
                                          "Whether the field should carry its multiple choice fields when copied",
                                      },
                                      linkText: {
                                        type: "string",
                                        description:
                                          "The configured text value that replaces the URL users see",
                                      },
                                      parentFieldId: {
                                        type: "integer",
                                        description:
                                          "The id of the parent composite field, when applicable",
                                      },
                                      displayTimezone: {
                                        type: "boolean",
                                        description:
                                          "Indicates whether to display the timezone within the product",
                                      },
                                      summaryTargetFieldId: {
                                        type: "integer",
                                        description:
                                          "The id of the field used to aggregate values from the child",
                                      },
                                      allowNewChoices: {
                                        type: "boolean",
                                        description:
                                          "Indicates if users can add new choices to a selection list",
                                      },
                                      defaultToday: {
                                        type: "boolean",
                                        description:
                                          "Indicates if the field value is defaulted today for new records",
                                      },
                                      units: {
                                        type: "string",
                                        description: "The units label",
                                      },
                                      openTargetIn: {
                                        type: "string",
                                        enum: ["sameWindow", "newWindow", "popup"],
                                        description:
                                          "Indicates which target the URL should open in when clicked",
                                      },
                                      lookupTargetFieldId: {
                                        type: "integer",
                                        description:
                                          "The id of the field that is the target on the parent table for this lookup",
                                      },
                                      summaryFunction: {
                                        type: "string",
                                        enum: [
                                          "AVG",
                                          "SUM",
                                          "MAX",
                                          "MIN",
                                          "STD-DEV",
                                          "COUNT",
                                          "COMBINED-TEXT",
                                          "COMBINED-USER",
                                          "DISTINCT-COUNT",
                                        ],
                                        description: "The accumulation type for the summary field",
                                      },
                                      sourceFieldId: {
                                        type: "integer",
                                        description: "The id of the source field",
                                      },
                                      doesAverage: {
                                        type: "boolean",
                                        description:
                                          "Whether this field averages in reports within the product",
                                      },
                                      formula: {
                                        type: "string",
                                        description:
                                          "The formula of the field as configured in QuickBase",
                                      },
                                      decimalPlaces: {
                                        type: "integer",
                                        description:
                                          "The number of decimal places displayed in the product",
                                      },
                                      defaultCountryCode: {
                                        type: "string",
                                        description:
                                          "Controls the default country shown on international phone widgets",
                                      },
                                      displayMonth: {
                                        type: "string",
                                        description: "How to display months",
                                      },
                                      seeVersions: {
                                        type: "boolean",
                                        description:
                                          "Indicates if users can see other versions of a file attachment",
                                      },
                                      defaultKind: {
                                        type: "string",
                                        description: "The user default type",
                                      },
                                      displayEmail: {
                                        type: "string",
                                        description: "How the email is displayed",
                                      },
                                      coverText: {
                                        type: "string",
                                        description:
                                          "Alternate user-friendly text for displaying a link",
                                      },
                                      currencySymbol: {
                                        type: "string",
                                        description:
                                          "The currency symbol used when displaying field values",
                                      },
                                      summaryQuery: {
                                        type: "string",
                                        description: "The summary query",
                                      },
                                      targetFieldId: {
                                        type: "integer",
                                        description: "The id of the target field",
                                      },
                                      displayUser: {
                                        type: "string",
                                        description: "The configured option for how users display",
                                      },
                                      blankIsZero: {
                                        type: "boolean",
                                        description:
                                          "Whether a blank value is treated as 0 in calculations",
                                      },
                                      exact: {
                                        type: "boolean",
                                        description:
                                          "Whether an exact match is required for a report link",
                                      },
                                      defaultDomain: {
                                        type: "string",
                                        description: "Default email domain",
                                      },
                                      defaultValue: {
                                        type: "string",
                                        description: "The default value configured for a field",
                                      },
                                      abbreviate: {
                                        type: "boolean",
                                        description:
                                          "Don't show the URL protocol when showing the URL",
                                      },
                                      numberFormat: {
                                        type: "integer",
                                        description:
                                          "The format used for displaying numeric values",
                                      },
                                      targetTableName: {
                                        type: "string",
                                        description: "The field's target table name",
                                      },
                                      appearsAs: {
                                        type: "string",
                                        description:
                                          "The link text; if empty, the URL will be used",
                                      },
                                      width: {
                                        type: "integer",
                                        description: "The field's HTML input width in the product",
                                      },
                                      currencyFormat: {
                                        type: "string",
                                        enum: ["left", "right", "middle"],
                                        description:
                                          "The currency format used when displaying field values",
                                      },
                                      displayDayOfWeek: {
                                        type: "boolean",
                                        description:
                                          "Indicates whether to display the day of the week",
                                      },
                                      summaryReferenceFieldId: {
                                        type: "integer",
                                        description:
                                          "The id of the field that is the reference in the relationship",
                                      },
                                      commaStart: {
                                        type: "integer",
                                        description: "The number of digits before commas display",
                                      },
                                      choices: {
                                        type: "array",
                                        items: { type: "string" },
                                        description:
                                          "An array of entries that exist for a field offering choices",
                                      },
                                      targetTableId: {
                                        type: "string",
                                        description: "The id of the target table",
                                      },
                                      displayRelative: {
                                        type: "boolean",
                                        description: "Whether to display time as relative",
                                      },
                                      compositeFields: {
                                        type: "array",
                                        items: { type: "object", additionalProperties: true },
                                        description:
                                          "An array of fields that make up a composite field (e.g., address)",
                                      },
                                      displayCheckboxAsText: {
                                        type: "boolean",
                                        description:
                                          "Indicates whether checkbox values are shown as text in reports",
                                      },
                                      versionMode: {
                                        type: "string",
                                        enum: ["keepallversions", "keeplastversions"],
                                        description: "Version modes for files",
                                      },
                                      snapFieldId: {
                                        type: "integer",
                                        description: "The id of the field used to snapshot values",
                                      },
                                      hours24: {
                                        type: "boolean",
                                        description:
                                          "Indicates whether to display time in 24-hour format",
                                      },
                                      sortAlpha: {
                                        type: "boolean",
                                        description:
                                          "Whether to sort alphabetically (default is by record ID)",
                                      },
                                      hasExtension: {
                                        type: "boolean",
                                        description: "Whether this field has a phone extension",
                                      },
                                      useNewWindow: {
                                        type: "boolean",
                                        description:
                                          "Indicates if the file should open a new window when clicked",
                                      },
                                      displayAsLink: {
                                        type: "boolean",
                                        description:
                                          "Indicates if the field should be shown as a hyperlink",
                                      },
                                      lookupReferenceFieldId: {
                                        type: "integer",
                                        description:
                                          "The id of the field that is the reference for this lookup",
                                      },
                                    },
                                    nullable: true,
                                  },
                                };

                                // Adjust required fields based on operation
                                if (pathKey.includes("{fieldId}") && method === "post") {
                                  // UpdateField (POST /fields/{fieldId})
                                  requiredFields = ["label"]; // fieldType is not allowed in updates
                                } else {
                                  // CreateField (POST /fields)
                                  requiredFields = ["label", "fieldType"];
                                }
                              }

                              spec.definitions[requestName] = {
                                type: "object",
                                properties,
                                required: requiredFields,
                                description: operation.summary || `Request body for ${opId}`,
                              };
                            }
                            param.schema = { $ref: `#/definitions/${requestName}` };
                            console.log(
                              `Ensured ${requestName} in definitions for ${pathKey}(${method})`
                            );
                          }
                        });
                      }
                    }
                - name: >-
                    groups.ts
                  type: >-
                    file
                  contents: >
                    //
                    schema/tags/groups.ts

                    import
                    {
                    Operation,
                    Parameter,
                    Spec
                    }
                    from
                    "../../types/spec.ts";

                    import
                    {
                    normalizeDefinitionName
                    }
                    from
                    "../../utils/naming.ts";


                    export
                    function
                    enhanceGroups(
                      spec: Spec,
                      pathKey: string,
                      method: string,
                      operation: Operation
                    ):
                    void
                    {
                      const opId =
                        operation.operationId || `${method}${pathKey.replace(/\W/g, "")}`;
                      if (
                        operation.parameters &&
                        operation.tags?.includes("Groups") &&
                        operation.summary?.toLowerCase().includes("subgroup")
                      ) {
                        operation.parameters.forEach((param: Parameter) => {
                          if (param.in === "body") {
                            if (!param.schema) param.schema = {};
                            let requestName =
                              param.schema.$ref?.split("/").pop() || `${opId}Request`;
                            requestName = normalizeDefinitionName(requestName);

                            if (
                              !spec.definitions[requestName] ||
                              !spec.definitions[requestName].type ||
                              Object.keys(spec.definitions[requestName]?.properties || {})
                                .length === 0
                            ) {
                              console.log(
                                `Defining schema for ${requestName} in ${pathKey}(${method})`
                              );
                              const properties = {
                                groupIds: { type: "array", items: { type: "string" } },
                              };
                              spec.definitions[requestName] = {
                                type: "object",
                                properties,
                                required: Object.keys(properties),
                                description: operation.summary || `Request body for ${opId}`,
                              };
                            }
                            param.schema = { $ref: `#/definitions/${requestName}` };
                            console.log(
                              `Ensured ${requestName} in definitions for ${pathKey}(${method})`
                            );
                          }
                        });
                      }
                    }
                - name: >-
                    index.ts
                  type: >-
                    file
                  contents: >
                    //
                    open-api/schema/tags/index.ts

                    import
                    {
                    Operation,
                    Parameter,
                    Spec
                    }
                    from
                    "../../types/spec.ts";

                    import
                    {
                    normalizeDefinitionName
                    }
                    from
                    "../../utils/naming.ts";

                    import
                    {
                    enhanceUsers
                    }
                    from
                    "./users.ts";

                    import
                    {
                    enhanceGroups
                    }
                    from
                    "./groups.ts";

                    import
                    {
                    enhanceRecords
                    }
                    from
                    "./records.ts";

                    import
                    {
                    enhanceApps
                    }
                    from
                    "./apps.ts";

                    import
                    {
                    enhanceFields
                    }
                    from
                    "./fields.ts";

                    import
                    {
                    enhanceTables
                    }
                    from
                    "./tables.ts";


                    export
                    function
                    enhanceTags(spec:
                    Spec):
                    void
                    {
                      console.log("enhanceTags version: 2025-03-16-fix-applied"); // Confirmation log

                      for (const pathKey in spec.paths) {
                        for (const method in spec.paths[pathKey]) {
                          const operation: Operation = spec.paths[pathKey][method];
                          const opId =
                            operation.operationId || `${method}${pathKey.replace(/\W/g, "")}`;

                          if (operation.parameters) {
                            operation.parameters.forEach((param: Parameter) => {
                              if (param.in === "body") {
                                if (!param.schema) param.schema = {};
                                let requestName =
                                  param.schema.$ref?.split("/").pop() || `${opId}Request`;
                                requestName = normalizeDefinitionName(requestName);

                                if (spec.definitions[requestName]?.type === "array") {
                                  console.log(
                                    `Wrapping array schema for ${requestName} in ${pathKey}(${method})`
                                  );
                                  const arraySchema = spec.definitions[requestName];
                                  let wrapperPropName = operation.tags?.includes("Users")
                                    ? "userIds"
                                    : "items";
                                  if (
                                    operation.tags?.includes("Groups") &&
                                    operation.summary?.toLowerCase().includes("subgroup")
                                  ) {
                                    wrapperPropName = "groupIds";
                                  }
                                  spec.definitions[requestName] = {
                                    type: "object",
                                    properties: { [wrapperPropName]: arraySchema },
                                    required: arraySchema.minItems > 0 ? [wrapperPropName] : [],
                                    description:
                                      arraySchema.description || `Request body for ${opId}`,
                                  };
                                  param.schema = { $ref: `#/definitions/${requestName}` };
                                  console.log(
                                    `Ensured ${requestName} in definitions for ${pathKey}(${method})`
                                  );
                                }
                              }
                            });
                          }

                          enhanceUsers(spec, pathKey, method, operation);
                          enhanceGroups(spec, pathKey, method, operation);
                          enhanceRecords(spec, pathKey, method, operation);
                          enhanceApps(spec, pathKey, method, operation);
                          enhanceFields(spec, pathKey, method, operation);
                          enhanceTables(spec, pathKey, method, operation);
                        }
                      }
                    }
                - name: >-
                    records.ts
                  type: >-
                    file
                  contents: >
                    //
                    open-api/schema/tags/records.ts

                    import
                    {
                    Operation,
                    Parameter,
                    Spec
                    }
                    from
                    "../../types/spec.ts";

                    import
                    {
                    normalizeDefinitionName
                    }
                    from
                    "../../utils/naming.ts";
                    //
                    Ensure
                    this
                    import
                    is
                    present


                    export
                    function
                    enhanceRecords(
                      spec: Spec,
                      pathKey: string,
                      method: string,
                      operation: Operation
                    ):
                    void
                    {
                      const opId =
                        operation.operationId || `${method}${pathKey.replace(/\W/g, "")}`;
                      if (operation.parameters && operation.tags?.includes("Records")) {
                        operation.parameters.forEach((param: Parameter) => {
                          if (param.in === "body") {
                            if (!param.schema) param.schema = {};
                            let requestName =
                              param.schema.$ref?.split("/").pop() || `${opId}Request`;
                            requestName = normalizeDefinitionName(requestName);

                            if (
                              !spec.definitions[requestName] ||
                              !spec.definitions[requestName].type ||
                              Object.keys(spec.definitions[requestName]?.properties || {})
                                .length === 0
                            ) {
                              console.log(
                                `Defining schema for ${requestName} in ${pathKey}(${method})`
                              );
                              let properties;
                              // Upsert endpoint (/records)
                              if (pathKey === "/records" && method === "post") {
                                properties = {
                                  data: { type: "array", items: { $ref: "#/definitions/Record" } },
                                  to: { type: "string" },
                                  fieldsToReturn: { type: "array", items: { type: "integer" } },
                                };
                              }
                              // Query endpoint (/records/query)
                              else if (pathKey === "/records/query" && method === "post") {
                                properties = {
                                  from: { type: "string", description: "The table identifier." },
                                  select: {
                                    type: "array",
                                    items: { type: "integer" },
                                    description: "An array of field ids...",
                                  },
                                  where: {
                                    type: "string",
                                    description:
                                      "The filter, using the Quickbase query language...",
                                  },
                                  sortBy: {
                                    type: "array",
                                    items: {
                                      type: "object",
                                      properties: {
                                        fieldId: { type: "integer" },
                                        order: {
                                          type: "string",
                                          enum: ["ASC", "DESC", "equal-values"],
                                        },
                                      },
                                      required: ["fieldId", "order"],
                                    },
                                    description: "An array of field IDs and sort directions...",
                                  },
                                  groupBy: {
                                    type: "array",
                                    items: {
                                      type: "object",
                                      properties: {
                                        fieldId: { type: "integer" },
                                        grouping: { type: "string", enum: ["equal-values"] },
                                      },
                                      required: ["fieldId", "grouping"],
                                    },
                                    description:
                                      "An array that contains the fields to group the records by.",
                                  },
                                  options: {
                                    type: "object",
                                    properties: {
                                      skip: { type: "integer" },
                                      top: { type: "integer" },
                                      compareWithAppLocalTime: { type: "boolean" },
                                    },
                                    description: "Additional query options.",
                                  },
                                };
                              }
                              // Delete endpoint (/records)
                              else if (method === "delete") {
                                properties = {
                                  from: { type: "string" },
                                  where: { type: "string" },
                                };
                              }
                              if (properties) {
                                spec.definitions[requestName] = {
                                  type: "object",
                                  properties,
                                  required: ["from"], // Only 'from' is required per the spec
                                  description: operation.summary || `Request body for ${opId}`,
                                };
                              }
                            }
                            param.schema = { $ref: `#/definitions/${requestName}` };
                            console.log(
                              `Ensured ${requestName} in definitions for ${pathKey}(${method})`
                            );
                          }
                        });
                      }
                    }
                - name: >-
                    tables.ts
                  type: >-
                    file
                  contents: >
                    //
                    schema/tags/tables.ts

                    import
                    {
                    Operation,
                    Parameter,
                    Spec
                    }
                    from
                    "../../types/spec.ts";

                    import
                    {
                    normalizeDefinitionName
                    }
                    from
                    "../../utils/naming.ts";


                    export
                    function
                    enhanceTables(
                      spec: Spec,
                      pathKey: string,
                      method: string,
                      operation: Operation
                    ):
                    void
                    {
                      const opId =
                        operation.operationId || `${method}${pathKey.replace(/\W/g, "")}`;
                      if (operation.parameters && operation.tags?.includes("Tables")) {
                        operation.parameters.forEach((param: Parameter) => {
                          if (param.in === "body") {
                            if (!param.schema) param.schema = {};
                            let requestName =
                              param.schema.$ref?.split("/").pop() || `${opId}Request`;
                            requestName = normalizeDefinitionName(requestName);

                            if (
                              !spec.definitions[requestName] ||
                              !spec.definitions[requestName].type ||
                              Object.keys(spec.definitions[requestName]?.properties || {})
                                .length === 0
                            ) {
                              console.log(
                                `Defining schema for ${requestName} in ${pathKey}(${method})`
                              );
                              let properties;

                              // Existing logic for other endpoints remains unchanged
                              if (pathKey === "/tables" && method === "post") {
                                properties = {
                                  name: {
                                    type: "string",
                                    description: "The name for the table.",
                                    minLength: 1,
                                  },
                                  description: {
                                    type: "string",
                                    description: "The description for the table...",
                                  },
                                  singleRecordName: {
                                    type: "string",
                                    description: "The singular noun for records...",
                                  },
                                  pluralRecordName: {
                                    type: "string",
                                    description: "The plural noun for records...",
                                  },
                                };
                              } else if (pathKey === "/tables/{tableId}" && method === "post") {
                                properties = {
                                  name: {
                                    type: "string",
                                    description: "The updated name of the table.",
                                  },
                                  description: {
                                    type: "string",
                                    description: "The updated description for the table.",
                                  },
                                };
                              }
                              // Add minimal fix for relationship endpoints
                              else if (
                                pathKey === "/tables/{tableId}/relationship" &&
                                method === "post"
                              ) {
                                requestName = "CreateRelationshipRequest"; // Force correct name
                                if (!spec.definitions[requestName]) {
                                  properties = {
                                    parentTableId: {
                                      type: "string",
                                      description: "The parent table id for the relationship.",
                                    },
                                    foreignKeyField: {
                                      type: "object",
                                      properties: {
                                        label: {
                                          type: "string",
                                          description: "The label for the foreign key field.",
                                        },
                                      },
                                      additionalProperties: true,
                                    },
                                    lookupFieldIds: {
                                      type: "array",
                                      items: { type: "integer" },
                                      description: "Array of field ids...",
                                    },
                                    summaryFields: {
                                      type: "array",
                                      items: {
                                        type: "object",
                                        properties: {
                                          summaryFid: {
                                            type: "number",
                                            description: "The field id to summarize.",
                                          },
                                          label: {
                                            type: "string",
                                            description: "The label for the summary field.",
                                          },
                                          accumulationType: {
                                            type: "string",
                                            enum: [
                                              "AVG",
                                              "SUM",
                                              "MAX",
                                              "MIN",
                                              "STD-DEV",
                                              "COUNT",
                                              "COMBINED-TEXT",
                                              "COMBINED-USER",
                                              "DISTINCT-COUNT",
                                            ],
                                            description: "The accumulation type...",
                                          },
                                          where: { type: "string", description: "The filter..." },
                                        },
                                        required: ["accumulationType"],
                                        additionalProperties: true,
                                      },
                                      description: "Array of summary field objects...",
                                    },
                                  };
                                }
                              } else if (
                                pathKey === "/tables/{tableId}/relationship/{relationshipId}" &&
                                method === "post"
                              ) {
                                requestName = "UpdateRelationshipRequest"; // Force correct name
                                if (!spec.definitions[requestName]) {
                                  properties = {
                                    parentTableId: {
                                      type: "string",
                                      description: "The updated parent table id...",
                                    },
                                    foreignKeyField: {
                                      type: "object",
                                      properties: {
                                        label: {
                                          type: "string",
                                          description: "The updated label...",
                                        },
                                      },
                                      additionalProperties: true,
                                    },
                                    lookupFieldIds: {
                                      type: "array",
                                      items: { type: "integer" },
                                      description: "Updated array of field ids...",
                                    },
                                    summaryFields: {
                                      type: "array",
                                      items: {
                                        type: "object",
                                        properties: {
                                          summaryFid: { type: "number" },
                                          label: { type: "string" },
                                          accumulationType: {
                                            type: "string",
                                            enum: [
                                              "AVG",
                                              "SUM",
                                              "MAX",
                                              "MIN",
                                              "STD-DEV",
                                              "COUNT",
                                              "COMBINED-TEXT",
                                              "COMBINED-USER",
                                              "DISTINCT-COUNT",
                                            ],
                                          },
                                          where: { type: "string" },
                                        },
                                        required: ["accumulationType"],
                                        additionalProperties: true,
                                      },
                                    },
                                  };
                                }
                              }

                              if (properties) {
                                spec.definitions[requestName] = {
                                  type: "object",
                                  properties,
                                  required:
                                    pathKey.includes("relationship") &&
                                    pathKey.endsWith("/relationship")
                                      ? ["parentTableId"]
                                      : pathKey === "/tables"
                                      ? ["name"]
                                      : [],
                                  additionalProperties: pathKey.includes("relationship")
                                    ? false
                                    : true, // Match raw spec
                                  description: operation.summary || `Request body for ${opId}`,
                                };
                              }
                            }
                            param.schema = { $ref: `#/definitions/${requestName}` };
                            console.log(
                              `Ensured ${requestName} in definitions for ${pathKey}(${method})`
                            );
                          }
                        });
                      }
                    }
                - name: >-
                    users.ts
                  type: >-
                    file
                  contents: >
                    //
                    schema/tags/users.ts

                    import
                    {
                    Operation,
                    Parameter,
                    Spec
                    }
                    from
                    "../../types/spec.ts";

                    import
                    {
                    normalizeDefinitionName
                    }
                    from
                    "../../utils/naming.ts";


                    export
                    function
                    enhanceUsers(
                      spec: Spec,
                      pathKey: string,
                      method: string,
                      operation: Operation
                    ):
                    void
                    {
                      const opId =
                        operation.operationId || `${method}${pathKey.replace(/\W/g, "")}`;
                      if (operation.parameters && operation.tags?.includes("Users")) {
                        operation.parameters.forEach((param: Parameter) => {
                          if (param.in === "body") {
                            if (!param.schema) param.schema = {};
                            let requestName =
                              param.schema.$ref?.split("/").pop() || `${opId}Request`;
                            requestName = normalizeDefinitionName(requestName);

                            if (
                              !spec.definitions[requestName] ||
                              !spec.definitions[requestName].type ||
                              Object.keys(spec.definitions[requestName]?.properties || {})
                                .length === 0
                            ) {
                              console.log(
                                `Defining schema for ${requestName} in ${pathKey}(${method})`
                              );
                              const properties = {
                                userIds: { type: "array", items: { type: "string" } },
                              };
                              spec.definitions[requestName] = {
                                type: "object",
                                properties,
                                required: Object.keys(properties),
                                description: operation.summary || `Request body for ${opId}`,
                              };
                            }
                            param.schema = { $ref: `#/definitions/${requestName}` };
                            console.log(
                              `Ensured ${requestName} in definitions for ${pathKey}(${method})`
                            );
                          }
                        });
                      }
                    }
        - name: >-
            types
          type: >-
            directory
          children:
            - name: >-
                spec.ts
              type: >-
                file
              contents: >
                //
                open-api/types/spec.ts

                export
                interface
                Parameter
                {
                  name: string;
                  in: string;
                  required?: boolean;
                  type?: string;
                  schema?: {
                    type?: string;
                    items?: any;
                    $ref?: string;
                    properties?: any;
                    example?: any;
                  };
                  example?: any;
                }


                export
                interface
                Operation
                {
                  parameters?: Parameter[];
                  responses?: Record<
                    string,
                    { description: string; schema?: any; "x-amf-mediaType"?: string }
                  >;
                  operationId?: string;
                  summary?: string;
                  tags?: string[];
                }


                export
                interface
                Spec
                {
                  paths: Record<string, Record<string, Operation>>;
                  definitions: Record<string, any>; // Required, no longer optional
                  swagger: string;
                  info: any;
                  operations?: any;
                  groups?: any;
                  components?: any;
                }


                export
                interface
                FixSpecConfig
                {
                  applyOverrides?: boolean;
                  overridePaths?: string[];
                  overrideDefinitions?: string[];
                }
        - name: >-
            utils
          type: >-
            directory
          children:
            - name: >-
                common.ts
              type: >-
                file
              contents: >
                #!/usr/bin/env
                node


                import
                {
                existsSync,
                mkdirSync,
                writeFileSync
                }
                from
                "fs";

                import
                {
                dirname
                }
                from
                "path";


                export
                function
                writeFileSafe(
                  filePath: string,
                  content: string,
                  encoding: BufferEncoding = "utf8"
                ):
                void
                {
                  console.log(`writeFileSafe: Writing to ${filePath}`);
                  const dir = dirname(filePath);
                  if (!existsSync(dir)) {
                    console.log(`writeFileSafe: Creating directory ${dir}`);
                    mkdirSync(dir, { recursive: true });
                  }
                  writeFileSync(filePath, content, encoding);
                }


                export
                function
                runTask(taskName:
                string,
                task:
                ()
                =>
                void):
                void
                {
                  console.log(`runTask: Starting ${taskName}`);
                  try {
                    task();
                    console.log(`runTask: ${taskName} completed`);
                  } catch (error) {
                    console.error(`runTask: Error in ${taskName}:`, error);
                    process.exit(1);
                  }
                }
            - name: >-
                generateJsDoc.ts
              type: >-
                file
              contents: >
                #!/usr/bin/env
                node


                import
                {
                ParamDetail,
                PropertyDetail,
                JsDocOptions
                }
                from
                "./sharedUtils.ts";

                import
                {
                getPropertyDescription
                }
                from
                "./sharedUtils.ts";


                export
                function
                generateJsDoc({
                  summary,
                  opId,
                  paramDetails,
                  returnType,
                  returnTypeDetails,
                  docLink,
                }:
                JsDocOptions):
                string
                {
                  const jsDocLines: string[] = [`  /**`, `   * ${summary}`, `   *`];

                  if (paramDetails.length > 0) {
                    jsDocLines.push(
                      `   * @param {Object} params - Object containing the parameters for ${opId}.`
                    );
                    paramDetails.forEach((p) => {
                      const paramDesc = p.description || "No description provided.";
                      const optionalMark = p.required ? "" : " (Optional)";
                      jsDocLines.push(
                        `   * @param {${p.type}} ${p.required ? "" : "["}params.${p.name}${
                          p.required ? "" : "]"
                        } - ${paramDesc}${optionalMark}`
                      );
                      if (p.properties.length > 0) {
                        p.properties.forEach((prop) => {
                          const propDesc = getPropertyDescription(prop);
                          jsDocLines.push(
                            `   *   - **${prop.name}** (\`${prop.type}\`, ${
                              prop.required ? "required" : "optional"
                            }) - ${propDesc}`
                          );
                        });
                      }
                    });
                  } else {
                    jsDocLines.push(`   * No parameters.`);
                  }

                  jsDocLines.push(`   *`);
                  if (returnTypeDetails.length > 0) {
                    jsDocLines.push(
                      `   * @returns {Promise<${returnType}>} - Promise resolving to the ${opId} response.`
                    );
                    const renderProperties = (props: PropertyDetail[], indent: string) => {
                      props.forEach((prop) => {
                        const propDesc = getPropertyDescription(prop);
                        jsDocLines.push(
                          `${indent}*   - **${prop.name}** (\`${prop.type}\`, ${
                            prop.required ? "required" : "optional"
                          }) - ${propDesc}`
                        );
                        if (prop.properties && prop.properties.length > 0) {
                          renderProperties(prop.properties, `${indent}*     `);
                        }
                      });
                    };
                    renderProperties(returnTypeDetails, `   `);
                  } else {
                    jsDocLines.push(
                      `   * @returns {Promise<${returnType}>} - Promise resolving to the ${opId} response.`
                    );
                  }

                  jsDocLines.push(
                    `   *`,
                    `   * @see ${docLink} - Official Quickbase API documentation`
                  );
                  jsDocLines.push(`   */`);
                  return jsDocLines.join("\n");
                }
            - name: >-
                infer-schema.ts
              type: >-
                file
              contents: >
                //
                utils/infer-schema.ts

                export
                function
                inferSchema(example:
                any,
                operationId?:
                string):
                any
                {
                  if (!example || typeof example !== "object") {
                    return { type: "string" };
                  }
                  if (Array.isArray(example)) {
                    return {
                      type: "array",
                      items:
                        example.length > 0
                          ? inferSchema(example[0], operationId)
                          : { type: "string" },
                    };
                  }
                  const properties: Record<string, any> = {};
                  for (const [key, value] of Object.entries(example)) {
                    if (Array.isArray(value)) {
                      properties[key] = {
                        type: "array",
                        items:
                          value.length > 0
                            ? inferSchema(value[0], operationId)
                            : { type: "string" },
                      };
                    } else if (typeof value === "object" && value !== null) {
                      properties[key] = inferSchema(value, operationId);
                    } else {
                      properties[key] = {
                        type:
                          typeof value === "object" && value === null
                            ? "object"
                            : typeof value || "string",
                      };
                    }
                  }
                  if (operationId && operationId.endsWith("200Response")) {
                    return { type: "array", items: { type: "object", properties } };
                  }
                  return { type: "object", properties };
                }
            - name: >-
                naming.ts
              type: >-
                file
              contents: >
                //
                utils/naming.ts

                export
                function
                toCamelCase(str:
                string):
                string
                {
                  return str
                    .replace(/[-_](.)/g, (_, char) => char.toUpperCase())
                    .replace(/^./, (str) => str.toLowerCase());
                }


                export
                function
                normalizeDefinitionName(name:
                string):
                string
                {
                  return name.charAt(0).toUpperCase() + name.slice(1);
                }
            - name: >-
                sharedUtils.ts
              type: >-
                file
              contents: >
                #!/usr/bin/env
                node


                import
                {
                OpenAPIV2
                }
                from
                "openapi-types";

                import
                {
                join
                }
                from
                "path";

                import
                {
                existsSync,
                readdirSync,
                readFileSync
                }
                from
                "fs";

                import
                {
                Project,
                PropertySignature,
                ts
                }
                from
                "ts-morph";
                //
                Import
                ts
                from
                ts-morph

                import
                {
                simplifyName
                }
                from
                "../../src/utils.ts";


                //
                (Existing
                interfaces
                remain
                unchanged)

                export
                interface
                PropertyDetail
                {
                  name: string;
                  type: string;
                  required: boolean;
                  jsdoc?: string;
                  properties?: PropertyDetail[];
                }


                export
                interface
                ParamDetail
                {
                  name: string;
                  type: string;
                  required: boolean;
                  properties: PropertyDetail[];
                  description?: string;
                }


                export
                interface
                JsDocOptions
                {
                  summary: string;
                  opId: string;
                  paramDetails: ParamDetail[];
                  returnType: string;
                  returnTypeDetails: PropertyDetail[];
                  docLink: string;
                }


                export
                function
                mapOpenApiTypeToTs(
                  openApiType: string | string[] | undefined
                ):
                string
                {
                  const type = Array.isArray(openApiType)
                    ? openApiType[0]
                    : openApiType || "any";
                  switch (type.toLowerCase()) {
                    case "integer":
                    case "int":
                    case "number":
                      return "number";
                    case "string":
                      return "string";
                    case "boolean":
                      return "boolean";
                    default:
                      return "any";
                  }
                }


                export
                function
                mapRefToType(
                  schema: OpenAPIV2.SchemaObject | OpenAPIV2.ReferenceObject | undefined,
                  modelImports: Set<string>,
                  spec: OpenAPIV2.Document,
                  depth: number = 0,
                  availableModels: string[],
                  missingTypes: Set<string>
                ):
                string
                {
                  if (!schema) return "any";
                  if ("$ref" in schema && schema.$ref) {
                    const refParts = schema.$ref.split("/");
                    const model = refParts[refParts.length - 1];
                    const pascalModel = model.charAt(0).toUpperCase() + model.slice(1);
                    if (availableModels.includes(pascalModel)) {
                      modelImports.add(pascalModel);
                      return pascalModel;
                    }
                    missingTypes.add(pascalModel);
                    console.warn(`Type ${pascalModel} not found, defaulting to 'any'`);
                    return "any";
                  }
                  if ("type" in schema) {
                    if (schema.type === "object" && schema.properties) {
                      const props = schema.properties;
                      const propTypes = Object.entries(props).map(([key, prop]) => {
                        const propSchema = prop as OpenAPIV2.SchemaObject;
                        const propType = mapRefToType(
                          propSchema,
                          modelImports,
                          spec,
                          depth + 1,
                          availableModels,
                          missingTypes
                        );
                        return `${key}${propSchema.required ? "" : "?"}: ${propType}`;
                      });
                      return `{ ${propTypes.join("; ")} }`;
                    }
                    if (schema.type === "array" && schema.items) {
                      const items = schema.items as
                        | OpenAPIV2.SchemaObject
                        | OpenAPIV2.ReferenceObject;
                      const itemType = mapRefToType(
                        items,
                        modelImports,
                        spec,
                        depth + 1,
                        availableModels,
                        missingTypes
                      );
                      return `${itemType}[]`;
                    }
                    return mapOpenApiTypeToTs(schema.type);
                  }
                  return "any";
                }


                export
                function
                parseInterfaceProperties(
                  modelName: string,
                  modelsDir: string,
                  availableModels?: string[],
                  depth: number = 0,
                  visited: Set<string> = new Set()
                ):
                PropertyDetail[]
                {
                  if (availableModels && (depth > 10 || visited.has(modelName))) {
                    console.warn(
                      `Recursion limit reached or circular reference detected for ${modelName}`
                    );
                    return [];
                  }
                  if (availableModels) visited.add(modelName);

                  const project = new Project();
                  const filePath = join(modelsDir, `${modelName}.ts`);
                  if (!existsSync(filePath)) {
                    console.warn(`Model file ${filePath} not found for ${modelName}`);
                    return [];
                  }
                  const sourceFile = project.addSourceFileAtPath(filePath);

                  // Try to get the interface first
                  let interfaceDec = sourceFile.getInterface(modelName);
                  if (!interfaceDec) {
                    // If no interface, check for a type alias (e.g., array type)
                    const typeAlias = sourceFile.getTypeAlias(modelName);
                    if (typeAlias) {
                      const typeNode = typeAlias.getTypeNode();
                      if (typeNode && typeNode.getKindName() === "ArrayType") {
                        const elementType = typeNode.getFirstChildByKindOrThrow(
                          ts.SyntaxKind.TypeReference // Use ts.SyntaxKind from ts-morph
                        );
                        const innerType = elementType.getText(); // e.g., "GetFields200ResponseItemsInner"
                        if (availableModels?.includes(innerType)) {
                          console.log(
                            `Detected array type alias ${modelName}, parsing inner type ${innerType}`
                          );
                          // Recursively parse the inner interface
                          return parseInterfaceProperties(
                            innerType,
                            modelsDir,
                            availableModels,
                            depth + 1,
                            visited
                          );
                        } else {
                          console.warn(
                            `Inner type ${innerType} not found in available models for ${modelName}`
                          );
                          return [];
                        }
                      }
                    }
                    console.warn(
                      `Interface or supported type alias ${modelName} not found in ${filePath}`
                    );
                    return [];
                  }

                  // Parse properties of the interface
                  return interfaceDec.getProperties().map((prop: PropertySignature) => {
                    const jsDocs = prop.getJsDocs();
                    const jsdocText =
                      jsDocs.length > 0 ? jsDocs[0].getDescription().trim() : undefined;
                    const propType = prop.getType().getText(prop);
                    let properties: PropertyDetail[] | undefined = undefined;

                    if (availableModels) {
                      const arrayMatch = propType.match(/(.+)\[\]$/);
                      if (arrayMatch) {
                        const innerType = arrayMatch[1].trim();
                        if (availableModels.includes(innerType) && !innerType.includes("[]")) {
                          properties = parseInterfaceProperties(
                            innerType,
                            modelsDir,
                            availableModels,
                            depth + 1,
                            visited
                          );
                        }
                      }
                    }

                    return {
                      name: prop.getName(),
                      type: propType,
                      required: !prop.hasQuestionToken(),
                      jsdoc: jsdocText,
                      properties: properties && properties.length > 0 ? properties : undefined,
                    };
                  });
                }


                export
                interface
                OperationDoc
                {
                  name: string;
                  summary: string;
                  method: string;
                  path: string;
                  parameters: ParamDetail[];
                  returns: string;
                  returnTypeDetails: PropertyDetail[] | undefined;
                  docLink: string;
                }


                export
                function
                parseOpenApiOperations(
                  specFile: string,
                  modelsDir: string
                ):
                {
                  operations: OperationDoc[];
                  modelImports: Set<string>;
                  missingTypes: Set<string>;
                }
                {
                  if (!existsSync(specFile)) {
                    throw new Error(
                      `Spec file ${specFile} not found. Run 'npm run fix-spec' first.`
                    );
                  }
                  const spec: OpenAPIV2.Document = JSON.parse(readFileSync(specFile, "utf8"));
                  const availableModels = readdirSync(modelsDir)
                    .filter((file) => file.endsWith(".ts") && !file.startsWith("index"))
                    .map((file) => file.replace(".ts", ""));
                  const modelImports = new Set<string>();
                  const missingTypes = new Set<string>();
                  const operations: OperationDoc[] = [];
                  for (const [path, methodsObj] of Object.entries(
                    spec.paths as OpenAPIV2.PathsObject
                  )) {
                    if (!methodsObj) continue;
                    for (const [method, operation] of Object.entries(
                      methodsObj as OpenAPIV2.PathItemObject
                    )) {
                      const op = operation as OpenAPIV2.OperationObject | undefined;
                      if (!op || !op.operationId) continue;
                      const opId = simplifyName(op.operationId);
                      console.log(`Processing operation ${opId} (${method} ${path})`);
                      const paramDetails = (op.parameters || [])
                        .filter(
                          (p) =>
                            !["QB-Realm-Hostname", "Authorization", "User-Agent"].includes(
                              (p as OpenAPIV2.ParameterObject).name || ""
                            )
                        )
                        .map((p) => {
                          const param = p as OpenAPIV2.ParameterObject;
                          let type = "any";
                          let properties: PropertyDetail[] | undefined = undefined;
                          if ("schema" in p && p.schema) {
                            type = mapRefToType(
                              p.schema,
                              modelImports,
                              spec,
                              1,
                              availableModels,
                              missingTypes
                            );
                            if ("$ref" in p.schema && p.schema.$ref) {
                              const refParts = p.schema.$ref.split("/");
                              const model = refParts[refParts.length - 1];
                              const pascalModel =
                                model.charAt(0).toUpperCase() + model.slice(1);
                              properties = parseInterfaceProperties(
                                pascalModel,
                                modelsDir,
                                availableModels
                              );
                            } else if (type !== "any" && availableModels.includes(type)) {
                              properties = parseInterfaceProperties(
                                type,
                                modelsDir,
                                availableModels
                              );
                            }
                          } else if ("type" in p) {
                            type = mapOpenApiTypeToTs(p.type);
                          }
                          return {
                            name: param.in === "body" ? "body" : param.name,
                            type,
                            required: param.required || false,
                            description: param.description || "",
                            properties: properties || [],
                          };
                        });
                      const returnTypes = ["200", "207"]
                        .map(
                          (code) => (op.responses?.[code] as OpenAPIV2.ResponseObject)?.schema
                        )
                        .filter(Boolean)
                        .map((schema) =>
                          mapRefToType(
                            schema!,
                            modelImports,
                            spec,
                            1,
                            availableModels,
                            missingTypes
                          )
                        );
                      const returnType =
                        returnTypes.length > 1
                          ? returnTypes.join(" | ")
                          : returnTypes[0] || "void";
                      const returnTypeDetailsRaw = returnTypes
                        .filter((type) => type !== "void" && availableModels.includes(type))
                        .map((type) =>
                          parseInterfaceProperties(type, modelsDir, availableModels)
                        )
                        .flat();
                      const returnTypeDetails =
                        returnTypeDetailsRaw.length > 0
                          ? returnTypeDetailsRaw.map((prop) => ({
                              ...prop,
                              properties:
                                prop.properties && prop.properties.length > 0
                                  ? [...prop.properties]
                                  : undefined,
                            }))
                          : undefined;
                      operations.push({
                        name: opId,
                        summary: op.summary || "No description.",
                        method: method.toUpperCase(),
                        path,
                        parameters: paramDetails,
                        returns: returnType,
                        returnTypeDetails,
                        docLink: `https://developer.quickbase.com/operation/${op.operationId}`,
                      });
                    }
                  }
                  return { operations, modelImports, missingTypes };
                }


                //
                New
                shared
                function

                export
                function
                getPropertyDescription(prop:
                PropertyDetail):
                string
                {
                  return prop.jsdoc
                    ? prop.jsdoc.replace(/@type\s*{[^}]+}\s*@memberof\s*\w+/, "").trim()
                    : `Type: ${prop.type}`;
                }
    - name: >-
        openapitools.json
      type: >-
        file
    - name: >-
        package-lock.json
      type: >-
        file
    - name: >-
        package.json
      type: >-
        file
    - name: >-
        playwright.config.ts
      type: >-
        file
    - name: >-
        quickbase-js-0.1.0-beta.13.tgz
      type: >-
        file
    - name: >-
        rollup.config.js
      type: >-
        file
    - name: >-
        src
      type: >-
        directory
      children:
        - name: >-
            BurstAwareThrottleBucket.ts
          type: >-
            file
        - name: >-
            FlowThrottleBucket.ts
          type: >-
            file
        - name: >-
            RateLimitError.ts
          type: >-
            file
        - name: >-
            RateThrottleBucket.ts
          type: >-
            file
        - name: >-
            Semaphore.ts
          type: >-
            file
        - name: >-
            authorizationStrategy.ts
          type: >-
            file
        - name: >-
            generated
          type: >-
            directory
          children:
            - name: >-
                .openapi-generator
              type: >-
                directory
              children:
                - name: >-
                    FILES
                  type: >-
                    file
                - name: >-
                    VERSION
                  type: >-
                    file
            - name: >-
                .openapi-generator-ignore
              type: >-
                file
            - name: >-
                apis
              type: >-
                directory
              children:
                - name: >-
                    AppsApi.ts
                  type: >-
                    file
                - name: >-
                    AuditApi.ts
                  type: >-
                    file
                - name: >-
                    AuthApi.ts
                  type: >-
                    file
                - name: >-
                    DocumentTemplatesApi.ts
                  type: >-
                    file
                - name: >-
                    FieldsApi.ts
                  type: >-
                    file
                - name: >-
                    FilesApi.ts
                  type: >-
                    file
                - name: >-
                    FormulasApi.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticsApi.ts
                  type: >-
                    file
                - name: >-
                    RecordsApi.ts
                  type: >-
                    file
                - name: >-
                    ReportsApi.ts
                  type: >-
                    file
                - name: >-
                    SolutionsApi.ts
                  type: >-
                    file
                - name: >-
                    TablesApi.ts
                  type: >-
                    file
                - name: >-
                    UserTokenApi.ts
                  type: >-
                    file
                - name: >-
                    UsersApi.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
            - name: >-
                index.ts
              type: >-
                file
            - name: >-
                models
              type: >-
                directory
              children:
                - name: >-
                    AddManagersToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddManagersToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    AddMembersToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddMembersToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    AddSubgroupsToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddSubgroupsToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    Audit200Response.ts
                  type: >-
                    file
                - name: >-
                    Audit202Response.ts
                  type: >-
                    file
                - name: >-
                    AuditRequest.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200ResponseInnerChangesInnerInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution404Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CloneUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    CloneUserTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    CopyApp200Response.ts
                  type: >-
                    file
                - name: >-
                    CopyAppRequest.ts
                  type: >-
                    file
                - name: >-
                    CopyAppRequestProperties.ts
                  type: >-
                    file
                - name: >-
                    CreateApp200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateAppRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateField200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateFieldRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateFieldRequestProperties.ts
                  type: >-
                    file
                - name: >-
                    CreateRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateRelationshipRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInnerCreatedResourcesInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInnerCreatedResourcesInnerAppsInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CreateTable200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateTableRequest.ts
                  type: >-
                    file
                - name: >-
                    DeactivateUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteApp200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteAppRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteFields200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteFieldsRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteFile200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteRecords200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteRecordsRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteTable200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersAndGroups200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersAndGroupsRequest.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    DownloadFile200Response.ts
                  type: >-
                    file
                - name: >-
                    ExchangeSsoToken200Response.ts
                  type: >-
                    file
                - name: >-
                    ExchangeSsoTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution404Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    GenerateDocument200Response.ts
                  type: >-
                    file
                - name: >-
                    GetApp200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppEvents200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppEvents200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetAppTables200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppTables200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetField200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFieldUsage200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFieldUsage200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetFields200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFields200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetFieldsUsage200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFieldsUsage200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetRelationships200Response.ts
                  type: >-
                    file
                - name: >-
                    GetReport200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTable200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTableReports200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTableReports200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetTempTokenDBID200Response.ts
                  type: >-
                    file
                - name: >-
                    GetUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    GetUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    Permission.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200Response.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseMetadata.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseTotals.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseWhereInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummariesRequest.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummariesRequestWhereInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticReads200Response.ts
                  type: >-
                    file
                - name: >-
                    Record.ts
                  type: >-
                    file
                - name: >-
                    RecordValue.ts
                  type: >-
                    file
                - name: >-
                    RemoveManagersFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveManagersFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RemoveMembersFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveMembersFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RemoveSubgroupsFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveSubgroupsFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RunFormula200Response.ts
                  type: >-
                    file
                - name: >-
                    RunFormulaRequest.ts
                  type: >-
                    file
                - name: >-
                    RunQuery200Response.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequest.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestGroupByInner.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestOptions.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestSortByInner.ts
                  type: >-
                    file
                - name: >-
                    RunReport200Response.ts
                  type: >-
                    file
                - name: >-
                    TransferUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    TransferUserTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    UndenyUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    UndenyUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateApp200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateAppRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateField200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateFieldRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateRelationshipRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200ResponseInnerCreatedResourcesInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    UpdateTable200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateTableRequest.ts
                  type: >-
                    file
                - name: >-
                    Upsert200Response.ts
                  type: >-
                    file
                - name: >-
                    Upsert207Response.ts
                  type: >-
                    file
                - name: >-
                    Upsert400Response.ts
                  type: >-
                    file
                - name: >-
                    UpsertRequest.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
            - name: >-
                runtime.ts
              type: >-
                file
        - name: >-
            generated-unified
          type: >-
            directory
          children:
            - name: >-
                QuickbaseClient.ts
              type: >-
                file
            - name: >-
                missing-types-report.json
              type: >-
                file
        - name: >-
            index.ts
          type: >-
            file
        - name: >-
            invokeMethod.ts
          type: >-
            file
        - name: >-
            pagination.ts
          type: >-
            file
        - name: >-
            quickbaseClient.ts
          type: >-
            file
        - name: >-
            rateLimiter.ts
          type: >-
            file
        - name: >-
            tokenCache.ts
          type: >-
            file
        - name: >-
            utils.ts
          type: >-
            file
    - name: >-
        test-artifacts
      type: >-
        directory
      children:
        - name: >-
            .last-run.json
          type: >-
            file
    - name: >-
        tests
      type: >-
        directory
      children:
        - name: >-
            playwright
          type: >-
            directory
          children:
            - name: >-
                qb
              type: >-
                directory
              children:
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        cacheSwitching.test.ts
                      type: >-
                        file
                    - name: >-
                        fetchTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithTempTokenConcurrency.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithUserToken.test.ts
                      type: >-
                        file
                    - name: >-
                        getTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        tempTokenPrefetch.test.ts
                      type: >-
                        file
                    - name: >-
                        tempTokenRenewal.test.ts
                      type: >-
                        file
        - name: >-
            setup.ts
          type: >-
            file
        - name: >-
            vitest
          type: >-
            directory
          children:
            - name: >-
                qb
              type: >-
                directory
              children:
                - name: >-
                    apps
                  type: >-
                    directory
                  children:
                    - name: >-
                        copyApp.test.ts
                      type: >-
                        file
                    - name: >-
                        createApp.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppEvents.test.ts
                      type: >-
                        file
                    - name: >-
                        updateApp.test.ts
                      type: >-
                        file
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        mockQuickbaseServer.ts
                      type: >-
                        file
                    - name: >-
                        retryUserToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        ssoTokenConcurrency.test.ts
                      type: >-
                        file
                    - name: >-
                        ssoTokenIntegrationWithServer.test.ts
                      type: >-
                        file
                    - name: >-
                        userTokenConcurrency.test.ts
                      type: >-
                        file
                - name: >-
                    fields
                  type: >-
                    directory
                  children:
                    - name: >-
                        createField.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getField.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        getFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldsUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        updateField.test.ts
                      type: >-
                        file
                - name: >-
                    formulas
                  type: >-
                    directory
                  children:
                    - name: >-
                        runFormula.test.ts
                      type: >-
                        file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    quickbase-js
                  type: >-
                    directory
                  children:
                    - name: >-
                        BurstAwareThrottleBucket.test.ts
                      type: >-
                        file
                    - name: >-
                        FlowBucket.test.ts
                      type: >-
                        file
                    - name: >-
                        paginationControl.test.ts
                      type: >-
                        file
                    - name: >-
                        paginationSkip.test.ts
                      type: >-
                        file
                - name: >-
                    records
                  type: >-
                    directory
                  children:
                    - name: >-
                        deleteRecords.test.ts
                      type: >-
                        file
                    - name: >-
                        runQuery.test.ts
                      type: >-
                        file
                    - name: >-
                        upsert.test.ts
                      type: >-
                        file
                - name: >-
                    tables
                  type: >-
                    directory
                  children:
                    - name: >-
                        createRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        createTable.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteTable.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppTables.test.ts
                      type: >-
                        file
                    - name: >-
                        getRelationships.test.ts
                      type: >-
                        file
                    - name: >-
                        getTable.test.ts
                      type: >-
                        file
                    - name: >-
                        updateRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        updateTable.test.ts
                      type: >-
                        file
            - name: >-
                unit
              type: >-
                directory
              children:
                - name: >-
                    apps
                  type: >-
                    directory
                  children:
                    - name: >-
                        copyApp.test.ts
                      type: >-
                        file
                    - name: >-
                        createApp.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppConcurrency.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppEvents.test.ts
                      type: >-
                        file
                    - name: >-
                        updateApp.test.ts
                      type: >-
                        file
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        fetchTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        getTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        retryTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        retryTempTokenMaxRetries.test.ts
                      type: >-
                        file
                    - name: >-
                        retryUserToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        ssoTokenRefresh.test.ts
                      type: >-
                        file
                    - name: >-
                        userTokenConcurrency.test.ts
                      type: >-
                        file
                - name: >-
                    fields
                  type: >-
                    directory
                  children:
                    - name: >-
                        createField.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getField.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        getFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldsUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        updateField.test.ts
                      type: >-
                        file
                - name: >-
                    formulas
                  type: >-
                    directory
                  children:
                    - name: >-
                        runFormula.test.ts
                      type: >-
                        file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    quickbase-js
                  type: >-
                    directory
                  children:
                    - name: >-
                        BurstAwareThrottleBucket.test.ts
                      type: >-
                        file
                    - name: >-
                        FlowBucket.test.ts
                      type: >-
                        file
                    - name: >-
                        pagination.test.ts
                      type: >-
                        file
                    - name: >-
                        quickbaseClientHttpMethods.test.ts
                      type: >-
                        file
                    - name: >-
                        rateLimit.test.ts
                      type: >-
                        file
                    - name: >-
                        tokenLifespan.test.ts
                      type: >-
                        file
                - name: >-
                    records
                  type: >-
                    directory
                  children:
                    - name: >-
                        deleteRecords.test.ts
                      type: >-
                        file
                    - name: >-
                        runQuery.test.ts
                      type: >-
                        file
                    - name: >-
                        upsert.test.ts
                      type: >-
                        file
                - name: >-
                    tables
                  type: >-
                    directory
                  children:
                    - name: >-
                        createRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        createTable.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteTable.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppTables.test.ts
                      type: >-
                        file
                    - name: >-
                        getRelationships.test.ts
                      type: >-
                        file
                    - name: >-
                        getTable.test.ts
                      type: >-
                        file
                    - name: >-
                        updateRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        updateTable.test.ts
                      type: >-
                        file
    - name: >-
        tools
      type: >-
        directory
      children:
        - name: >-
            log-gen.ts
          type: >-
            file
        - name: >-
            log-gen.yaml
          type: >-
            file
        - name: >-
            openapi-jars
          type: >-
            directory
          children:
            - name: >-
                openapi-generator-cli-7.12.0.jar
              type: >-
                file
    - name: >-
        tsconfig.build.json
      type: >-
        file
    - name: >-
        tsconfig.json
      type: >-
        file
    - name: >-
        versionrc.json
      type: >-
        file
    - name: >-
        vitest.config.ts
      type: >-
        file

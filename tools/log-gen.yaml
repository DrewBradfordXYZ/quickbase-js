project: >-
  quickbase-js
date: >-
  3/21/2025
root: >-
  /home/drew/Projects/quickbase-js
goals:
  - >-
    A
    library
    for
    interacting
    with
    the
    QuickBase
    RESTful
    API.
  - >-
    Use
    OpenAPI
    to
    generate
    types
    and
    methods
    using
    a
    proxy.
    Validate
    with
    tests.
  - >-
    Provide
    robust
    and
    intuitive
    temporary
    token
    support
    for
    browser
    environments.
  - >-
    User
    Tokens
    support
    both
    Node.js
    and
    browser
    environments.
  - >-
    Use
    case:
    JS
    frameworks
    like
    React,
    Vue,
    and
    Angular
    hosted
    in
    QuickBase
    code
    pages.
  - >-
    Enable
    a
    flexible
    or
    native
    fetch
    in
    the
    browser.
  - >-
    Enable
    a
    flexible
    fetch
    framework
    in
    Node.js.
  - >-
    #
  - >-
    No
    manual
    updating
    methods
    when
    the
    QuickBase
    API
    changes.
  - >-
    The
    proxy
    magic
    dynamically
    maps
    generated
    methods
    and
    types.
  - >-
    #
  - >-
    TokenCache
    is
    defined
    per
    quickbaseClient
    call,
    so
    each
    instance
    has
    its
    own
    isolated
    TokenCache.
  - >-
    Each
    quickbase
    client
    instance
    has
    an
    isolated
    and
    individual
    token
    cache.
pipelineOverview:
  - >-
    What
    I’m
    Trying
    to
    Do
  - >-
    My
    approach
    is
    to
    ensure
    AppsApi.ts
    is
    generated
    with
    getAppById
    so
    QuickbaseClient.ts
    can
    map
    it
    to
    client.getApp.
    Steps
    include:
  - >-
    Fix
    fix-spec.ts:
  - >-
    Add
    tags:
    ["Apps"]
    to
    /apps/*
    endpoints
    to
    group
    them
    into
    AppsApi.ts.
  - >-
    Ensure
    all
    endpoints
    and
    models
    are
    correctly
    defined
    and
    typed.
  - >-
    Debug
    regenerate-client.ts:
  - >-
    Enhance
    logging
    to
    catch
    why
    AppsApi.ts
    isn’t
    generated.
  - >-
    Test
    if
    getAppById
    appears
    in
    another
    file
    (e.g.,
    DefaultApi.ts).
  - >-
    Update
    QuickbaseClient.ts:
  - >-
    Adjust
    imports
    to
    use
    the
    correct
    API
    class
    once
    generated.
  - >-
    Test
    and
    Iterate:
  - >-
    Run
    npm
    run
    fix-spec,
    npm
    run
    regenerate,
    and
    npm
    run
    test
    to
    verify
    AppsApi.ts
    exists
    and
    test.ts
    works.
  - >-
    The
    latest
    fix-spec.ts
    with
    tags
    aims
    to
    force
    the
    generator
    to
    create
    AppsApi.ts,
    addressing
    the
    missing
    file
    issue.
  - >-
    Relevant
    Project
    Files
  - >-
    Here’s
    a
    list
    of
    files
    that
    would
    help
    understand
    and
    resolve
    this
    problem,
    along
    with
    their
    roles:
  - >-
    src/code-generation/fix-spec.ts:
  - >-
    Role:
    Modifies
    the
    original
    QuickBase
    spec
    (e.g.,
    QuickBase_RESTful_*.json)
    to
    create
    quickbase-fixed.json
    with
    required
    endpoints
    (e.g.,
    /apps/{appId}).
  - >-
    Relevance:
    Defines
    the
    spec
    fed
    to
    the
    generator;
    errors
    here
    affect
    generation.
  - >-
    src/code-generation/quickbase-fixed.json:
  - >-
    Role:
    The
    processed
    OpenAPI
    spec
    used
    by
    regenerate-client.ts
    to
    generate
    code.
  - >-
    Relevance:
    Confirms
    if
    /apps/{appId}
    is
    correctly
    structured
    with
    operationId:
    "getAppById".
  - >-
    src/code-generation/regenerate-client.ts:
  - >-
    Role:
    Runs
    OpenAPI
    Generator
    to
    produce
    src/generated/
    files
    (APIs
    and
    models)
    and
    fixes
    .ts
    extensions
    with
    ts-morph.
  - >-
    Relevance:
    Controls
    the
    generation
    process;
    logs
    reveal
    why
    AppsApi.ts
    is
    missing.
  - >-
    src/generated/apis/AppsApi.ts
    (if
    exists):
  - >-
    Role:
    Should
    contain
    getAppById
    method
    for
    /apps/{appId}
    GET.
  - >-
    Relevance:
    Missing
    file
    is
    the
    core
    issue;
    its
    absence
    breaks
    QuickbaseClient.ts.
  - >-
    src/generated/apis/DefaultApi.ts:
  - >-
    Role:
    Default
    API
    class
    for
    untagged
    operations.
  - >-
    Relevance:
    Might
    contain
    getAppById
    if
    tags
    are
    misconfigured.
  - >-
    src/QuickbaseClient.ts:
  - >-
    Role:
    Wraps
    generated
    API
    classes
    (e.g.,
    AppsApi)
    in
    a
    Proxy
    for
    ergonomic
    calls
    (e.g.,
    client.getApp).
  - >-
    Relevance:
    Fails
    to
    import
    AppsApi.ts,
    causing
    the
    runtime
    error.
  - >-
    src/test.ts:
  - >-
    Role:
    Test
    script
    calling
    client.getApp({
    appId
    }).
  - >-
    Relevance:
    Final
    validation
    point;
    shows
    if
    the
    fix
    works.
  - >-
    .env.development:
  - >-
    Role:
    Stores
    QB_REALM,
    QB_USER_TOKEN,
    QB_APP_ID
    for
    API
    authentication.
  - >-
    Relevance:
    Ensures
    the
    API
    call
    has
    valid
    credentials
    (not
    the
    current
    issue,
    but
    critical
    for
    success).
  - >-
    src/specs/QuickBase_RESTful_API_2025-03-04T06_22_39.725Z.json
    (or
    similar):
  - >-
    Role:
    Original
    QuickBase
    API
    spec
    before
    fix-spec.ts
    processing.
  - >-
    Relevance:
    Shows
    how
    /apps/{appId}
    was
    originally
    defined,
    helping
    identify
    conflicts.
  - >-
    package.json:
  - >-
    Role:
    Defines
    scripts
    (fix-spec,
    regenerate,
    test)
    and
    dependencies
    (e.g.,
    ts-node,
    openapi-generator-cli).
  - >-
    Relevance:
    Confirms
    script
    commands
    and
    versions
    align
    with
    our
    process.
  - >-
    What
    We
    Achieved
  - >-
    Goal
    Met:
    You
    can
    now
    call
    client.getApp({
    appId:
    "buwai2zpe"
    })
    and
    get
    the
    app
    details
    {
    id:
    'buwai2zpe',
    name:
    'qb-copy'
    }.
  - >-
    Fixes
    Applied:
  - >-
    Added
    tags:
    ["Apps"]
    in
    fix-spec.ts
    to
    ensure
    AppsApi.ts
    is
    generated
    with
    getAppById.
  - >-
    Updated
    QuickbaseClient.ts
    to:
  - >-
    Use
    prototype
    methods
    via
    Object.getOwnPropertyNames.
  - >-
    Bind
    methods
    to
    preserve
    context
    with
    .bind(api).
  - >-
    Handle
    getAppById’s
    direct
    JSON
    return
    instead
    of
    a
    Response
    object.
  - >-
    Result:
    The
    ergonomic
    API
    you
    wanted
    (client.getApp)
    works
    seamlessly
    with
    the
    generated
    AppsApi.ts.
  - >-
    Why
    It
    Works
    Now
  - >-
    fix-spec.ts:
  - >-
    Correctly
    defined
    /apps/{appId}
    with
    operationId:
    "getAppById"
    and
    tags:
    ["Apps"],
    ensuring
    AppsApi.ts
    generation.
  - >-
    regenerate-client.ts:
  - >-
    Successfully
    ran
    OpenAPI
    Generator
    to
    produce
    AppsApi.ts
    with
    getAppById.
  - >-
    QuickbaseClient.ts:
  - >-
    buildMethodMap
    now
    captures
    getAppById
    and
    maps
    it
    to
    getApp.
  - >-
    invokeMethod
    passes
    {
    appId:
    'buwai2zpe'
    }
    as
    requestParameters
    and
    handles
    the
    JSON
    response
    directly.
  - >-
    test.ts:
  - >-
    Calls
    client.getApp
    and
    logs
    the
    result,
    proving
    the
    end-to-end
    flow.
tree:
  name: >-
    .
  type: >-
    directory
  children:
    - name: >-
        .env
      type: >-
        file
    - name: >-
        .gitignore
      type: >-
        file
    - name: >-
        CHANGELOG.md
      type: >-
        file
    - name: >-
        LICENSE
      type: >-
        file
    - name: >-
        README.md
      type: >-
        file
    - name: >-
        api-examples.md
      type: >-
        file
    - name: >-
        build-common.js
      type: >-
        file
    - name: >-
        build-esm.js
      type: >-
        file
    - name: >-
        build-umd.js
      type: >-
        file
    - name: >-
        debug.log
      type: >-
        file
    - name: >-
        dist
      type: >-
        directory
      children:
        - name: >-
            esm
          type: >-
            directory
          children:
            - name: >-
                quickbase.d.ts
              type: >-
                file
            - name: >-
                quickbase.js
              type: >-
                file
            - name: >-
                quickbase.js.map
              type: >-
                file
            - name: >-
                quickbase.min.js
              type: >-
                file
            - name: >-
                quickbase.min.js.map
              type: >-
                file
        - name: >-
            umd
          type: >-
            directory
          children:
            - name: >-
                quickbase.umd.js
              type: >-
                file
            - name: >-
                quickbase.umd.js.map
              type: >-
                file
            - name: >-
                quickbase.umd.min.js
              type: >-
                file
            - name: >-
                quickbase.umd.min.js.map
              type: >-
                file
    - name: >-
        docs
      type: >-
        directory
      children:
        - name: >-
            .vitepress
          type: >-
            directory
          children:
            - name: >-
                cache
              type: >-
                directory
              children:
                - name: >-
                    deps
                  type: >-
                    directory
                  children:
                    - name: >-
                        @theme_index.js
                      type: >-
                        file
                    - name: >-
                        @theme_index.js.map
                      type: >-
                        file
                    - name: >-
                        _metadata.json
                      type: >-
                        file
                    - name: >-
                        chunk-5A67QEFC.js
                      type: >-
                        file
                    - name: >-
                        chunk-5A67QEFC.js.map
                      type: >-
                        file
                    - name: >-
                        chunk-7D4P4MMP.js
                      type: >-
                        file
                    - name: >-
                        chunk-7D4P4MMP.js.map
                      type: >-
                        file
                    - name: >-
                        package.json
                      type: >-
                        file
                    - name: >-
                        vitepress___@vue_devtools-api.js
                      type: >-
                        file
                    - name: >-
                        vitepress___@vue_devtools-api.js.map
                      type: >-
                        file
                    - name: >-
                        vitepress___@vueuse_core.js
                      type: >-
                        file
                    - name: >-
                        vitepress___@vueuse_core.js.map
                      type: >-
                        file
                    - name: >-
                        vue.js
                      type: >-
                        file
                    - name: >-
                        vue.js.map
                      type: >-
                        file
            - name: >-
                config.mts
              type: >-
                file
            - name: >-
                dist
              type: >-
                directory
              children:
                - name: >-
                    404.html
                  type: >-
                    file
                - name: >-
                    api-examples.html
                  type: >-
                    file
                - name: >-
                    assets
                  type: >-
                    directory
                  children:
                    - name: >-
                        api-examples.md.CRRh3xeI.js
                      type: >-
                        file
                    - name: >-
                        api-examples.md.CRRh3xeI.lean.js
                      type: >-
                        file
                    - name: >-
                        app.Yv9tMCdR.js
                      type: >-
                        file
                    - name: >-
                        chunks
                      type: >-
                        directory
                      children:
                        - name: >-
                            framework.Dh1jimFm.js
                          type: >-
                            file
                        - name: >-
                            theme.CDm2W-g2.js
                          type: >-
                            file
                    - name: >-
                        index.md.7e0F_hhC.js
                      type: >-
                        file
                    - name: >-
                        index.md.7e0F_hhC.lean.js
                      type: >-
                        file
                    - name: >-
                        inter-italic-cyrillic-ext.r48I6akx.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-cyrillic.By2_1cv3.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-greek-ext.1u6EdAuj.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-greek.DJ8dCoTZ.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-latin-ext.CN1xVJS-.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-latin.C2AdPX0b.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-vietnamese.BSbpV94h.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-cyrillic-ext.BBPuwvHQ.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-cyrillic.C5lxZ8CY.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-greek-ext.CqjqNYQ-.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-greek.BBVDIX6e.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-latin-ext.4ZJIpNVo.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-latin.Di8DUHzh.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-vietnamese.BjW4sHH5.woff2
                      type: >-
                        file
                    - name: >-
                        markdown-examples.md.ediKJOVO.js
                      type: >-
                        file
                    - name: >-
                        markdown-examples.md.ediKJOVO.lean.js
                      type: >-
                        file
                    - name: >-
                        style.BJrZ0CFW.css
                      type: >-
                        file
                - name: >-
                    hashmap.json
                  type: >-
                    file
                - name: >-
                    index.html
                  type: >-
                    file
                - name: >-
                    markdown-examples.html
                  type: >-
                    file
                - name: >-
                    vp-icons.css
                  type: >-
                    file
        - name: >-
            api-examples.md
          type: >-
            file
        - name: >-
            index.md
          type: >-
            file
        - name: >-
            markdown-examples.md
          type: >-
            file
        - name: >-
            node_modules
          type: >-
            directory
          children: []
    - name: >-
        docs-data
      type: >-
        directory
      children:
        - name: >-
            api-docs.json
          type: >-
            file
    - name: >-
        examples
      type: >-
        directory
      children:
        - name: >-
            quicbase-jsCDN.html
          type: >-
            file
        - name: >-
            react.js
          type: >-
            file
        - name: >-
            vanillajs.html
          type: >-
            file
    - name: >-
        index.md
      type: >-
        file
    - name: >-
        markdown-examples.md
      type: >-
        file
    - name: >-
        open-api
      type: >-
        directory
      children:
        - name: >-
            fix-spec-main.ts
          type: >-
            file
          contents: >
            #!/usr/bin/env
            node


            import
            {
            promises
            as
            fs
            }
            from
            "fs";

            import
            path
            from
            "path";

            import
            {
            fileURLToPath
            }
            from
            "url";

            import
            *
            as
            glob
            from
            "glob";

            import
            {
            Spec
            }
            from
            "./types/spec.ts";

            import
            {
            toCamelCase
            }
            from
            "./utils/naming.ts";


            async
            function
            fixQuickBaseSpec():
            Promise<void>
            {
              const CODEGEN_DIR = path.dirname(fileURLToPath(import.meta.url));
              const SPECS_DIR = path.join(CODEGEN_DIR, "..", "specs");
              const OUTPUT_DIR = path.join(CODEGEN_DIR, "output");
              console.log("Finding latest QuickBase RESTful API spec...");
              const specFiles = glob.sync(path.join(SPECS_DIR, "QuickBase_RESTful_*.json"));
              console.log("Spec files:", specFiles);

              if (specFiles.length === 0) {
                throw new Error(
                  "No QuickBase_RESTful_*.json files found in specs/ folder."
                );
              }

              const inputFile = specFiles.sort().pop() as string;
              const outputFile = path.join(OUTPUT_DIR, "quickbase-fixed.json");

              console.log(`Reading ${path.basename(inputFile)} from specs/...`);
              const specContent = await fs.readFile(inputFile, "utf8");
              console.log("File read successfully");
              const spec: Spec = JSON.parse(specContent);
              console.log("JSON parsed successfully");

              if (!spec.definitions || typeof spec.definitions !== "object") {
                spec.definitions = {};
              }
              console.log("Spec definitions after initialization:", spec.definitions);

              console.log(
                "Original /apps/{appId}/events 200 schema:",
                JSON.stringify(
                  spec.paths["/apps/{appId}/events"]?.get?.responses?.["200"]?.schema,
                  null,
                  2
                )
              );

              console.log("Fixing parameters...");
              for (const pathKey in spec.paths) {
                for (const method in spec.paths[pathKey]) {
                  const operation = spec.paths[pathKey][method];
                  if (operation.parameters) {
                    operation.parameters = operation.parameters
                      .filter(
                        (param) =>
                          !["QB-Realm-Hostname", "Authorization", "User-Agent"].includes(
                            param.name
                          )
                      )
                      .map((param) => {
                        param.name = toCamelCase(param.name);
                        if ("example" in param) delete param.example;
                        if ("schema" in param && param.in !== "body") delete param.schema;
                        if (!param.type && param.in !== "body") {
                          param.type = param.name.includes("Id") ? "string" : "string";
                          console.log(
                            `Set default type 'string' for ${pathKey}(${method}).${param.name}`
                          );
                        }
                        return param;
                      });
                  }
                }
              }

              console.log("Spec definitions before enhanceTags:", spec.definitions);
              console.log("Enhancing raw spec with tags...");
              const { enhanceTags } = await import("./schema/tags/index.ts");
              enhanceTags(spec);
              console.log(
                "After enhanceTags:",
                JSON.stringify(
                  spec.paths["/apps/{appId}/events"]?.get?.responses?.["200"]?.schema,
                  null,
                  2
                )
              );

              console.log("Enhancing raw spec with general enhancements...");
              const { enhanceGeneral } = await import("./schema/enhance-general.ts");
              enhanceGeneral(spec);
              console.log(
                "After enhanceGeneral:",
                JSON.stringify(
                  spec.paths["/apps/{appId}/events"]?.get?.responses?.["200"]?.schema,
                  null,
                  2
                )
              );

              console.log("Fixing array schemas...");
              const { fixArrays } = await import("./schema/fix-arrays.ts");
              fixArrays(spec);
              console.log(
                "After fixArrays:",
                JSON.stringify(
                  spec.paths["/apps/{appId}/events"]?.get?.responses?.["200"]?.schema,
                  null,
                  2
                )
              );

              console.log("Removing unexpected top-level attributes...");
              delete spec.operations;
              delete spec.groups;
              delete spec.components;

              console.log(`Writing fixed spec to ${path.basename(outputFile)}...`);
              await fs.mkdir(OUTPUT_DIR, { recursive: true });
              await fs.writeFile(outputFile, JSON.stringify(spec, null, 2), "utf8");
              console.log("Spec fixed successfully! Output written to:", outputFile);
            }


            async
            function
            main()
            {
              try {
                console.log("Starting...");
                await fixQuickBaseSpec();
              } catch (error) {
                console.error("Error:", error);
                process.exit(1);
              }
            }


            main();
        - name: >-
            generate-unified-interface.ts
          type: >-
            file
          contents: >
            #!/usr/bin/env
            node


            console.log("Script
            started");


            import
            {
            readFileSync,
            writeFileSync,
            mkdirSync,
            existsSync
            }
            from
            "fs";

            console.log("FS
            modules
            imported");


            import
            {
            join,
            dirname
            }
            from
            "path";

            console.log("Path
            modules
            imported");


            import
            {
            fileURLToPath
            }
            from
            "url";

            console.log("URL
            module
            imported");


            import
            {
            generateJsDoc
            }
            from
            "./utils/generateJsDoc.ts";

            import
            {
              PropertyDetail,
              ParamDetail,
              JsDocOptions,
              mapOpenApiTypeToTs,
              mapRefToType,
              parseInterfaceProperties,
              parseOpenApiOperations,
            }
            from
            "./utils/sharedUtils.ts";

            import
            {
            writeFileSafe,
            runTask
            }
            from
            "./utils/common.ts";


            const
            __dirname
            =
            dirname(fileURLToPath(import.meta.url));

            console.log("__dirname
            set:",
            __dirname);


            const
            SPEC_FILE
            =
            join(__dirname,
            "output",
            "quickbase-fixed.json");

            const
            OUTPUT_DIR
            =
            join(__dirname,
            "..",
            "src",
            "generated-unified");

            const
            OUTPUT_FILE
            =
            join(OUTPUT_DIR,
            "QuickbaseClient.ts");

            const
            MODELS_DIR
            =
            join(__dirname,
            "..",
            "src",
            "generated",
            "models");


            function
            generateInterface(includeResponseProperties:
            boolean
            =
            false):
            void
            {
              console.log(
                "Generating interface with includeResponseProperties:",
                includeResponseProperties
              );

              console.log("Checking spec file:", SPEC_FILE);
              if (!existsSync(SPEC_FILE)) {
                console.error(
                  `Spec file ${SPEC_FILE} not found. Run 'npm run fix-spec' first.`
                );
                process.exit(1);
              }

              console.log("Checking models directory:", MODELS_DIR);
              if (!existsSync(MODELS_DIR)) {
                console.error(
                  `Models directory ${MODELS_DIR} not found. Run 'npm run gen:openapi' first.`
                );
                process.exit(1);
              }

              const { operations, modelImports, missingTypes } = parseOpenApiOperations(
                SPEC_FILE,
                MODELS_DIR
              );
              console.log("Operations parsed:", operations.length);

              const methods: string[] = operations.map((op) => {
                const params = op.parameters
                  .map((p) => `${p.name}${p.required ? "" : "?"}: ${p.type}`)
                  .join("; ");
                const jsDocOptions: JsDocOptions = {
                  summary: op.summary,
                  opId: op.name,
                  paramDetails: op.parameters,
                  returnType: op.returns,
                  returnTypeDetails: includeResponseProperties
                    ? op.returnTypeDetails || []
                    : [],
                  docLink: op.docLink,
                };
                const jsDoc = generateJsDoc(jsDocOptions);
                return `${jsDoc}\n  ${op.name}: (params: { ${params} }) => Promise<${op.returns}>;`;
              });

              console.log("Writing missing types report...");
              writeFileSafe(
                join(OUTPUT_DIR, "missing-types-report.json"),
                JSON.stringify({ missingTypes: Array.from(missingTypes) }, null, 2)
              );

              const importStatement =
                modelImports.size > 0
                  ? `import { ${Array.from(modelImports)
                      .sort()
                      .join(", ")} } from "../generated/models";`
                  : "";
              const interfaceContent = `// Generated on ${new Date().toISOString()}\n${importStatement}\n\nexport interface QuickbaseClient {\n${methods.join(
                "\n"
              )}\n}\n`;

              console.log("Ensuring output directory exists and writing interface...");
              writeFileSafe(OUTPUT_FILE, interfaceContent);
              console.log("Generated:", OUTPUT_FILE);
            }


            console.log("Entering
            runTask
            block");

            runTask("generateInterface",
            ()
            =>
            generateInterface(true));


            console.log("Script
            completed");
        - name: >-
            generateDocsJson.ts
          type: >-
            file
          contents: >
            #!/usr/bin/env
            node


            import
            {
            writeFileSync,
            existsSync,
            mkdirSync
            }
            from
            "fs";

            import
            {
            join,
            dirname
            }
            from
            "path";

            import
            {
            fileURLToPath
            }
            from
            "url";

            import
            {
            parseOpenApiOperations
            }
            from
            "./utils/sharedUtils.ts";

            import
            {
            writeFileSafe,
            runTask
            }
            from
            "./utils/common.ts";


            const
            __dirname
            =
            dirname(fileURLToPath(import.meta.url));

            const
            SPEC_FILE
            =
            join(__dirname,
            "output",
            "quickbase-fixed.json");

            const
            MODELS_DIR
            =
            join(__dirname,
            "..",
            "src",
            "generated",
            "models");

            const
            DOCS_DATA_DIR
            =
            join(__dirname,
            "..",
            "docs-data");

            const
            DOCS_JSON_FILE
            =
            join(DOCS_DATA_DIR,
            "api-docs.json");


            function
            generateDocsJson():
            void
            {
              console.log("Generating docs JSON...");
              const { operations } = parseOpenApiOperations(SPEC_FILE, MODELS_DIR);
              writeFileSafe(DOCS_JSON_FILE, JSON.stringify(operations, null, 2), "utf8");
              console.log("Generated docs JSON:", DOCS_JSON_FILE);
            }


            runTask("generateDocsJson",
            generateDocsJson);


            console.log("Script
            completed");
        - name: >-
            regenerate-client.ts
          type: >-
            file
          contents: >
            #!/usr/bin/env
            node


            import
            {
            execSync
            }
            from
            "child_process";

            import
            {
            existsSync
            }
            from
            "fs";

            import
            {
            join
            }
            from
            "path";

            import
            {
            fileURLToPath
            }
            from
            "url";

            import
            fetch
            from
            "node-fetch";

            import
            readline
            from
            "readline";


            const
            CURRENT_JAR_VERSION
            =
            "7.12.0";

            const
            MAVEN_METADATA_URL
            =
              "https://repo1.maven.org/maven2/org/openapitools/openapi-generator-cli/maven-metadata.xml";
            const
            CODEGEN_DIR
            =
            join(fileURLToPath(import.meta.url),
            "..");

            const
            JARS_DIR
            =
            join(CODEGEN_DIR,
            "..",
            "tools",
            "openapi-jars");

            const
            SPEC_INPUT
            =
            join(CODEGEN_DIR,
            "output",
            "quickbase-fixed.json");

            const
            OUTPUT_DIR
            =
            join(CODEGEN_DIR,
            "..",
            "src",
            "generated");


            async
            function
            getLatestVersion():
            Promise<string>
            {
              const response = await fetch(MAVEN_METADATA_URL);
              if (!response.ok)
                throw new Error(`Failed to fetch Maven metadata: ${response.statusText}`);
              const text = await response.text();
              const match = text.match(/<latest>(.*?)<\/latest>/);
              if (!match)
                throw new Error("Couldn’t parse latest version from Maven metadata");
              return match[1];
            }


            async
            function
            checkAndPromptForUpdate(messages:
            string[]):
            Promise<string>
            {
              const latestVersion = await getLatestVersion();
              if (latestVersion === CURRENT_JAR_VERSION) {
                messages.push(`Current version (${CURRENT_JAR_VERSION}) is the latest.`);
                return CURRENT_JAR_VERSION;
              }

              messages.push(
                `Newer version available: ${latestVersion} (current: ${CURRENT_JAR_VERSION})`
              );
              const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout,
              });

              return new Promise((resolve) => {
                const prompt = "Do you want to update to the latest version? (y/n): ";
                messages.push(prompt);
                rl.question(prompt, (answer) => {
                  rl.close();
                  if (answer.toLowerCase() === "y" || answer.toLowerCase() === "yes") {
                    messages.push(`Switching to version ${latestVersion}...`);
                    resolve(latestVersion);
                  } else {
                    messages.push(`Sticking with version ${CURRENT_JAR_VERSION}.`);
                    resolve(CURRENT_JAR_VERSION);
                  }
                });
              });
            }


            async
            function
            ensureJarExists(
              version: string,
              messages: string[]
            ):
            Promise<string>
            {
              const jarPath = join(JARS_DIR, `openapi-generator-cli-${version}.jar`);
              const jarUrl = `https://repo1.maven.org/maven2/org/openapitools/openapi-generator-cli/${version}/openapi-generator-cli-${version}.jar`;

              if (!existsSync(jarPath)) {
                messages.push(`Downloading OpenAPI Generator CLI v${version}...`);
                try {
                  execSync(`curl -L -o ${jarPath} ${jarUrl}`, { stdio: "inherit" });
                  messages.push(`Downloaded ${jarPath}`);
                } catch (error) {
                  messages.push("Failed to download JAR.");
                  throw error;
                }
              } else {
                messages.push(`Using existing ${jarPath}`);
              }
              return jarPath;
            }


            function
            regenerateClient(jarPath:
            string,
            messages:
            string[])
            {
              messages.push("Regenerating client from spec...");
              const command = `java -jar ${jarPath} generate -i ${SPEC_INPUT} -g typescript-fetch -o ${OUTPUT_DIR} --additional-properties=generateAliasAsModel=true,withInterfaces=true,supportsES6=true,modelPropertyNaming=original`;
              try {
                execSync(command, { stdio: "inherit" });
                messages.push("Client regeneration complete.");
              } catch (error) {
                messages.push("Regeneration failed.");
                throw error;
              }
            }


            async
            function
            main()
            {
              const messages: string[] = [];
              try {
                if (!existsSync(SPEC_INPUT)) {
                  console.error(
                    `Spec file ${SPEC_INPUT} does not exist. Run 'npm run fix-spec' first.`
                  );
                  process.exit(1);
                }
                const versionToUse = await checkAndPromptForUpdate(messages);
                const jarPath = await ensureJarExists(versionToUse, messages);
                regenerateClient(jarPath, messages);
              } catch (error) {
                console.error("Error occurred during process:", error);
              } finally {
                console.log("\n--- Key Messages ---");
                messages.forEach((msg) => console.log(msg));
              }
            }


            main().catch((error)
            =>
            {
              console.error("Error in regeneration process:", error);
              process.exit(1);
            });
        - name: >-
            schema
          type: >-
            directory
          children:
            - name: >-
                enhance-general.ts
              type: >-
                file
              contents: >
                //
                schema/enhance-general.ts

                import
                {
                Operation,
                Parameter,
                Spec
                }
                from
                "../types/spec.ts";

                import
                {
                inferSchema
                }
                from
                "../utils/infer-schema.ts";


                export
                function
                enhanceGeneral(spec:
                Spec):
                void
                {
                  spec.definitions = spec.definitions || {};

                  // Local function to wrap top-level arrays and refine items
                  function wrapTopLevelArrays(schema: any, responseName: string): any {
                    if (schema.type === "array") {
                      console.log(
                        `Wrapping ${responseName} in an object with 'items' property`
                      );
                      // Remove additionalProperties from items to ensure typing
                      if (schema.items && "additionalProperties" in schema.items) {
                        delete schema.items.additionalProperties;
                        console.log(`Removed additionalProperties from ${responseName}.items`);
                      }
                      return {
                        type: "object",
                        properties: {
                          items: schema,
                        },
                        description: `A response containing a list for ${responseName}`,
                      };
                    }
                    return schema; // Return unchanged if not a top-level array
                  }

                  if (!spec.definitions["Record"]) {
                    spec.definitions["Record"] = {
                      type: "object",
                      additionalProperties: {
                        type: "object",
                        properties: { value: { type: "string" } },
                        required: ["value"],
                      },
                      description: "A generic QuickBase record with field ID-value pairs",
                    };
                    console.log("Added Record to definitions");
                  }

                  if (!spec.definitions["Permission"]) {
                    spec.definitions["Permission"] = {
                      type: "object",
                      properties: {
                        role: { type: "string", description: "The role name" },
                        permissionType: {
                          type: "string",
                          description: "Permission type (e.g., View, Modify)",
                        },
                        roleId: { type: "integer", description: "The role identifier" },
                      },
                      required: ["role", "permissionType", "roleId"],
                      description: "A single permission entry for a field",
                    };
                    console.log("Added Permission to definitions");
                  }

                  for (const pathKey in spec.paths) {
                    for (const method in spec.paths[pathKey]) {
                      const operation: Operation = spec.paths[pathKey][method];
                      const opId =
                        operation.operationId || `${method}${pathKey.replace(/\W/g, "")}`;

                      if (operation.parameters) {
                        operation.parameters.forEach((param: Parameter) => {
                          if (param.in !== "body" && !param.type && !param.schema) {
                            param.type = param.name.includes("Id") ? "string" : "string";
                            console.log(
                              `Set default type 'string' for ${pathKey}(${method}).${param.name}`
                            );
                          }
                        });
                      }

                      if (operation.responses) {
                        for (const status in operation.responses) {
                          const response = operation.responses[status];
                          if (response.schema) {
                            const cleanStatus = status.replace("/", "_");
                            const responseName = `${opId}${cleanStatus}Response`;
                            if (!spec.definitions[responseName]) {
                              console.log(
                                `Adding ${responseName} to definitions for ${pathKey}(${method})`
                              );
                              let schemaToUse = response.schema;
                              // Apply general fix for top-level arrays
                              schemaToUse = wrapTopLevelArrays(schemaToUse, responseName);
                              if (
                                !schemaToUse.type ||
                                (schemaToUse.type === "array" && !schemaToUse.items)
                              ) {
                                if (response["x-amf-mediaType"]) {
                                  const mediaType = response["x-amf-mediaType"];
                                  if (mediaType === "application/octet-stream") {
                                    schemaToUse = {
                                      type: "object",
                                      properties: {
                                        data: { type: "string", format: "binary" },
                                      },
                                      description:
                                        schemaToUse?.description || "Binary file content",
                                    };
                                  } else if (mediaType === "application/x-yaml") {
                                    schemaToUse = {
                                      type: "object",
                                      properties: {
                                        content: { type: "string", format: "yaml" },
                                      },
                                      description: "YAML-formatted data",
                                    };
                                  } else if (
                                    mediaType === "application/json" &&
                                    schemaToUse.example
                                  ) {
                                    schemaToUse = inferSchema(
                                      schemaToUse.example,
                                      responseName
                                    );
                                    schemaToUse.description =
                                      response.description || `Response for ${opId}`;
                                  }
                                }
                              }
                              spec.definitions[responseName] = schemaToUse;
                            }
                            response.schema = { $ref: `#/definitions/${responseName}` };
                          }
                        }
                      }
                    }
                  }
                }
            - name: >-
                enhance-general.ts.bak
              type: >-
                file
              contents: >
                //
                schema/enhance-general.ts

                import
                {
                Operation,
                Parameter,
                Spec
                }
                from
                "../types/spec.ts";

                import
                {
                inferSchema
                }
                from
                "../utils/infer-schema.ts";


                export
                function
                enhanceGeneral(spec:
                Spec):
                void
                {
                  spec.definitions = spec.definitions || {};

                  // Local function to wrap top-level arrays and refine items
                  function wrapTopLevelArrays(schema: any, responseName: string): any {
                    if (schema.type === "array") {
                      console.log(
                        `Wrapping ${responseName} in an object with 'items' property`
                      );
                      // Remove additionalProperties from items to ensure typing
                      if (schema.items && "additionalProperties" in schema.items) {
                        delete schema.items.additionalProperties;
                        console.log(`Removed additionalProperties from ${responseName}.items`);
                      }
                      return {
                        type: "object",
                        properties: {
                          items: schema,
                        },
                        description: `A response containing a list for ${responseName}`,
                      };
                    }
                    return schema; // Return unchanged if not a top-level array
                  }

                  if (!spec.definitions["Record"]) {
                    spec.definitions["Record"] = {
                      type: "object",
                      additionalProperties: {
                        type: "object",
                        properties: { value: { type: "string" } },
                        required: ["value"],
                      },
                      description: "A generic QuickBase record with field ID-value pairs",
                    };
                    console.log("Added Record to definitions");
                  }

                  if (!spec.definitions["Permission"]) {
                    spec.definitions["Permission"] = {
                      type: "object",
                      properties: {
                        role: { type: "string", description: "The role name" },
                        permissionType: {
                          type: "string",
                          description: "Permission type (e.g., View, Modify)",
                        },
                        roleId: { type: "integer", description: "The role identifier" },
                      },
                      required: ["role", "permissionType", "roleId"],
                      description: "A single permission entry for a field",
                    };
                    console.log("Added Permission to definitions");
                  }

                  for (const pathKey in spec.paths) {
                    for (const method in spec.paths[pathKey]) {
                      const operation: Operation = spec.paths[pathKey][method];
                      const opId =
                        operation.operationId || `${method}${pathKey.replace(/\W/g, "")}`;

                      if (operation.parameters) {
                        operation.parameters.forEach((param: Parameter) => {
                          if (param.in !== "body" && !param.type && !param.schema) {
                            param.type = param.name.includes("Id") ? "string" : "string";
                            console.log(
                              `Set default type 'string' for ${pathKey}(${method}).${param.name}`
                            );
                          }
                        });
                      }

                      if (operation.responses) {
                        for (const status in operation.responses) {
                          const response = operation.responses[status];
                          if (response.schema) {
                            const cleanStatus = status.replace("/", "_");
                            const responseName = `${opId}${cleanStatus}Response`;
                            if (!spec.definitions[responseName]) {
                              console.log(
                                `Adding ${responseName} to definitions for ${pathKey}(${method})`
                              );
                              let schemaToUse = response.schema;
                              // Apply general fix for top-level arrays
                              schemaToUse = wrapTopLevelArrays(schemaToUse, responseName);
                              if (
                                !schemaToUse.type ||
                                (schemaToUse.type === "array" && !schemaToUse.items)
                              ) {
                                if (response["x-amf-mediaType"]) {
                                  const mediaType = response["x-amf-mediaType"];
                                  if (mediaType === "application/octet-stream") {
                                    schemaToUse = {
                                      type: "object",
                                      properties: {
                                        data: { type: "string", format: "binary" },
                                      },
                                      description:
                                        schemaToUse?.description || "Binary file content",
                                    };
                                  } else if (mediaType === "application/x-yaml") {
                                    schemaToUse = {
                                      type: "object",
                                      properties: {
                                        content: { type: "string", format: "yaml" },
                                      },
                                      description: "YAML-formatted data",
                                    };
                                  } else if (
                                    mediaType === "application/json" &&
                                    schemaToUse.example
                                  ) {
                                    schemaToUse = inferSchema(
                                      schemaToUse.example,
                                      responseName
                                    );
                                    schemaToUse.description =
                                      response.description || `Response for ${opId}`;
                                  }
                                }
                              }
                              spec.definitions[responseName] = schemaToUse;
                            }
                            response.schema = { $ref: `#/definitions/${responseName}` };
                          }
                        }
                      }
                    }
                  }
                }
            - name: >-
                fix-arrays.ts
              type: >-
                file
              contents: >
                //
                schema/fix-arrays.ts

                import
                {
                Parameter,
                Spec
                }
                from
                "../types/spec.ts";


                export
                function
                fixArrays(spec:
                Spec):
                void
                {
                  for (const pathKey in spec.paths) {
                    for (const method in spec.paths[pathKey]) {
                      const operation = spec.paths[pathKey][method];
                      if (operation.parameters) {
                        operation.parameters.forEach((param: Parameter) => {
                          if (param.schema?.type === "array" && !param.schema.items) {
                            console.log(
                              `Fixing array schema for ${pathKey}(${method}).${param.name}`
                            );
                            param.schema.items = { type: "string" };
                          }
                          if (param.schema?.properties) {
                            for (const propKey in param.schema.properties) {
                              const prop = param.schema.properties[propKey];
                              if (prop.type === "array" && !prop.items) {
                                console.log(
                                  `Fixing nested array for ${pathKey}(${method}).${param.name}.${propKey}`
                                );
                                prop.items = { type: "string" };
                              }
                            }
                          }
                        });
                      }
                      if (operation.responses) {
                        for (const status in operation.responses) {
                          const response = operation.responses[status];
                          if (response.schema?.type === "array" && !response.schema.items) {
                            console.log(
                              `Fixing array schema for ${pathKey}(${method}).responses.${status}`
                            );
                            response.schema.items = { type: "string" };
                          }
                          if (response.schema?.properties) {
                            for (const propKey in response.schema.properties) {
                              const prop = response.schema.properties[propKey];
                              if (prop.type === "array" && !prop.items) {
                                console.log(
                                  `Fixing nested array for ${pathKey}(${method}).responses.${status}.${propKey}`
                                );
                                prop.items = { type: "string" };
                              }
                            }
                          }
                        }
                      }
                    }
                  }

                  console.log("Fixing array schemas in definitions...");
                  const definitions = spec.definitions || {};
                  for (const defKey in definitions) {
                    const def = definitions[defKey];
                    if (def.properties) {
                      for (const propKey in def.properties) {
                        const prop = def.properties[propKey];
                        if (prop.type === "array" && !prop.items) {
                          console.log(`Fixing missing items in ${defKey}.${propKey}`);
                          prop.items = { type: "string" };
                        }
                      }
                    }
                  }
                }
            - name: >-
                tags
              type: >-
                directory
              children:
                - name: >-
                    apps.ts
                  type: >-
                    file
                - name: >-
                    fields.ts
                  type: >-
                    file
                - name: >-
                    groups.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    records.ts
                  type: >-
                    file
                - name: >-
                    tables.ts
                  type: >-
                    file
                - name: >-
                    users.ts
                  type: >-
                    file
        - name: >-
            types
          type: >-
            directory
          children:
            - name: >-
                spec.ts
              type: >-
                file
        - name: >-
            utils
          type: >-
            directory
          children:
            - name: >-
                common.ts
              type: >-
                file
              contents: >
                #!/usr/bin/env
                node


                import
                {
                existsSync,
                mkdirSync,
                writeFileSync
                }
                from
                "fs";

                import
                {
                dirname
                }
                from
                "path";


                export
                function
                writeFileSafe(
                  filePath: string,
                  content: string,
                  encoding: BufferEncoding = "utf8"
                ):
                void
                {
                  console.log(`writeFileSafe: Writing to ${filePath}`);
                  const dir = dirname(filePath);
                  if (!existsSync(dir)) {
                    console.log(`writeFileSafe: Creating directory ${dir}`);
                    mkdirSync(dir, { recursive: true });
                  }
                  writeFileSync(filePath, content, encoding);
                }


                export
                function
                runTask(taskName:
                string,
                task:
                ()
                =>
                void):
                void
                {
                  console.log(`runTask: Starting ${taskName}`);
                  try {
                    task();
                    console.log(`runTask: ${taskName} completed`);
                  } catch (error) {
                    console.error(`runTask: Error in ${taskName}:`, error);
                    process.exit(1);
                  }
                }
            - name: >-
                generateJsDoc.ts
              type: >-
                file
              contents: >
                #!/usr/bin/env
                node


                import
                {
                ParamDetail,
                PropertyDetail,
                JsDocOptions
                }
                from
                "./sharedUtils.ts";

                import
                {
                getPropertyDescription
                }
                from
                "./sharedUtils.ts";


                export
                function
                generateJsDoc({
                  summary,
                  opId,
                  paramDetails,
                  returnType,
                  returnTypeDetails,
                  docLink,
                }:
                JsDocOptions):
                string
                {
                  const jsDocLines: string[] = [
                    `  /**`,
                    `   * ${summary}`,
                    `   *`,
                    `   * @param {Object} params _Object containing the parameters for_ ${opId}`,
                  ];

                  if (paramDetails.length > 0) {
                    paramDetails.forEach((p) => {
                      jsDocLines.push(
                        `   *   @param {${p.type}} params.${p.name} _${
                          p.required ? "Required" : "Optional"
                        } parameter with properties_`
                      );
                      if (p.properties.length > 0) {
                        p.properties.forEach((prop) => {
                          const propDesc = getPropertyDescription(prop);
                          jsDocLines.push(
                            `   *     - **${prop.name}** (\`${prop.type}\`${
                              prop.required ? ", required" : ", optional"
                            }) _${propDesc}_`
                          );
                        });
                      }
                    });
                  } else {
                    jsDocLines.push(`   *   No parameters`);
                  }

                  jsDocLines.push(`   *`);
                  if (returnTypeDetails.length > 0) {
                    jsDocLines.push(
                      `   * @returns {Promise<${returnType}>} _Promise resolving to the ${opId} response with properties_`
                    );
                    const renderProperties = (props: PropertyDetail[], indent: string) => {
                      props.forEach((prop) => {
                        // Only include description if it’s not just repeating the type
                        const propDesc =
                          prop.properties && prop.properties.length > 0
                            ? "" // Skip description for complex types with nested properties
                            : getPropertyDescription(prop);
                        jsDocLines.push(
                          `${indent}*   - **${prop.name}** (\`${prop.type}\`${
                            prop.required ? ", required" : ", optional"
                          }) _${propDesc}_`
                        );
                        if (prop.properties && prop.properties.length > 0) {
                          renderProperties(prop.properties, `${indent}*     `);
                        }
                      });
                    };
                    renderProperties(returnTypeDetails, `   `);
                  } else {
                    jsDocLines.push(
                      `   * @returns {Promise<${returnType}>} _Promise resolving to the ${opId} response_`
                    );
                  }

                  jsDocLines.push(
                    `   *`,
                    `   * @see {@link ${docLink}} Official Quickbase API documentation`,
                    `   */`
                  );
                  return jsDocLines.join("\n");
                }
            - name: >-
                infer-schema.ts
              type: >-
                file
              contents: >
                //
                utils/infer-schema.ts

                export
                function
                inferSchema(example:
                any,
                operationId?:
                string):
                any
                {
                  if (!example || typeof example !== "object") {
                    return { type: "string" };
                  }
                  if (Array.isArray(example)) {
                    return {
                      type: "array",
                      items:
                        example.length > 0
                          ? inferSchema(example[0], operationId)
                          : { type: "string" },
                    };
                  }
                  const properties: Record<string, any> = {};
                  for (const [key, value] of Object.entries(example)) {
                    if (Array.isArray(value)) {
                      properties[key] = {
                        type: "array",
                        items:
                          value.length > 0
                            ? inferSchema(value[0], operationId)
                            : { type: "string" },
                      };
                    } else if (typeof value === "object" && value !== null) {
                      properties[key] = inferSchema(value, operationId);
                    } else {
                      properties[key] = {
                        type:
                          typeof value === "object" && value === null
                            ? "object"
                            : typeof value || "string",
                      };
                    }
                  }
                  if (operationId && operationId.endsWith("200Response")) {
                    return { type: "array", items: { type: "object", properties } };
                  }
                  return { type: "object", properties };
                }
            - name: >-
                naming.ts
              type: >-
                file
              contents: >
                //
                utils/naming.ts

                export
                function
                toCamelCase(str:
                string):
                string
                {
                  return str
                    .replace(/[-_](.)/g, (_, char) => char.toUpperCase())
                    .replace(/^./, (str) => str.toLowerCase());
                }


                export
                function
                normalizeDefinitionName(name:
                string):
                string
                {
                  return name.charAt(0).toUpperCase() + name.slice(1);
                }
            - name: >-
                sharedUtils.ts
              type: >-
                file
              contents: >
                #!/usr/bin/env
                node


                import
                {
                OpenAPIV2
                }
                from
                "openapi-types";

                import
                {
                join
                }
                from
                "path";

                import
                {
                existsSync,
                readdirSync,
                readFileSync
                }
                from
                "fs";

                import
                {
                Project,
                PropertySignature
                }
                from
                "ts-morph";

                import
                {
                simplifyName
                }
                from
                "../../src/utils.ts";


                //
                (Existing
                interfaces
                remain
                unchanged)

                export
                interface
                PropertyDetail
                {
                  name: string;
                  type: string;
                  required: boolean;
                  jsdoc?: string;
                  properties?: PropertyDetail[];
                }


                export
                interface
                ParamDetail
                {
                  name: string;
                  type: string;
                  required: boolean;
                  properties: PropertyDetail[];
                  description?: string;
                }


                export
                interface
                JsDocOptions
                {
                  summary: string;
                  opId: string;
                  paramDetails: ParamDetail[];
                  returnType: string;
                  returnTypeDetails: PropertyDetail[];
                  docLink: string;
                }


                export
                function
                mapOpenApiTypeToTs(
                  openApiType: string | string[] | undefined
                ):
                string
                {
                  const type = Array.isArray(openApiType)
                    ? openApiType[0]
                    : openApiType || "any";
                  switch (type.toLowerCase()) {
                    case "integer":
                    case "int":
                    case "number":
                      return "number";
                    case "string":
                      return "string";
                    case "boolean":
                      return "boolean";
                    default:
                      return "any";
                  }
                }


                export
                function
                mapRefToType(
                  schema: OpenAPIV2.SchemaObject | OpenAPIV2.ReferenceObject | undefined,
                  modelImports: Set<string>,
                  spec: OpenAPIV2.Document,
                  depth: number = 0,
                  availableModels: string[],
                  missingTypes: Set<string>
                ):
                string
                {
                  if (!schema) return "any";
                  if ("$ref" in schema && schema.$ref) {
                    const refParts = schema.$ref.split("/");
                    const model = refParts[refParts.length - 1];
                    const pascalModel = model.charAt(0).toUpperCase() + model.slice(1);
                    if (availableModels.includes(pascalModel)) {
                      modelImports.add(pascalModel);
                      return pascalModel;
                    }
                    missingTypes.add(pascalModel);
                    console.warn(`Type ${pascalModel} not found, defaulting to 'any'`);
                    return "any";
                  }
                  if ("type" in schema) {
                    if (schema.type === "object" && schema.properties) {
                      const props = schema.properties;
                      const propTypes = Object.entries(props).map(([key, prop]) => {
                        const propSchema = prop as OpenAPIV2.SchemaObject;
                        const propType = mapRefToType(
                          propSchema,
                          modelImports,
                          spec,
                          depth + 1,
                          availableModels,
                          missingTypes
                        );
                        return `${key}${propSchema.required ? "" : "?"}: ${propType}`;
                      });
                      return `{ ${propTypes.join("; ")} }`;
                    }
                    if (schema.type === "array" && schema.items) {
                      const items = schema.items as
                        | OpenAPIV2.SchemaObject
                        | OpenAPIV2.ReferenceObject;
                      const itemType = mapRefToType(
                        items,
                        modelImports,
                        spec,
                        depth + 1,
                        availableModels,
                        missingTypes
                      );
                      return `${itemType}[]`;
                    }
                    return mapOpenApiTypeToTs(schema.type);
                  }
                  return "any";
                }


                export
                function
                parseInterfaceProperties(
                  modelName: string,
                  modelsDir: string,
                  availableModels?: string[],
                  depth: number = 0,
                  visited: Set<string> = new Set()
                ):
                PropertyDetail[]
                {
                  if (availableModels && (depth > 10 || visited.has(modelName))) {
                    console.warn(
                      `Recursion limit reached or circular reference detected for ${modelName}`
                    );
                    return [];
                  }
                  if (availableModels) visited.add(modelName);
                  const project = new Project();
                  const filePath = join(modelsDir, `${modelName}.ts`);
                  if (!existsSync(filePath)) {
                    console.warn(`Model file ${filePath} not found for ${modelName}`);
                    return [];
                  }
                  const sourceFile = project.addSourceFileAtPath(filePath);
                  const interfaceDec = sourceFile.getInterface(modelName);
                  if (!interfaceDec) {
                    console.warn(`Interface ${modelName} not found in ${filePath}`);
                    return [];
                  }
                  return interfaceDec.getProperties().map((prop: PropertySignature) => {
                    const jsDocs = prop.getJsDocs();
                    const jsdocText =
                      jsDocs.length > 0 ? jsDocs[0].getDescription().trim() : undefined;
                    const propType = prop.getType().getText(prop);
                    let properties: PropertyDetail[] | undefined = undefined;
                    if (availableModels) {
                      const arrayMatch = propType.match(/(.+)\[\]$/);
                      if (arrayMatch) {
                        const innerType = arrayMatch[1].trim();
                        if (availableModels.includes(innerType) && !innerType.includes("[]")) {
                          properties = parseInterfaceProperties(
                            innerType,
                            modelsDir,
                            availableModels,
                            depth + 1,
                            visited
                          );
                        }
                      }
                    }
                    return {
                      name: prop.getName(),
                      type: propType,
                      required: !prop.hasQuestionToken(),
                      jsdoc: jsdocText,
                      properties: properties && properties.length > 0 ? properties : undefined,
                    };
                  });
                }


                export
                interface
                OperationDoc
                {
                  name: string;
                  summary: string;
                  method: string;
                  path: string;
                  parameters: ParamDetail[];
                  returns: string;
                  returnTypeDetails: PropertyDetail[] | undefined;
                  docLink: string;
                }


                export
                function
                parseOpenApiOperations(
                  specFile: string,
                  modelsDir: string
                ):
                {
                  operations: OperationDoc[];
                  modelImports: Set<string>;
                  missingTypes: Set<string>;
                }
                {
                  if (!existsSync(specFile)) {
                    throw new Error(
                      `Spec file ${specFile} not found. Run 'npm run fix-spec' first.`
                    );
                  }
                  const spec: OpenAPIV2.Document = JSON.parse(readFileSync(specFile, "utf8"));
                  const availableModels = readdirSync(modelsDir)
                    .filter((file) => file.endsWith(".ts") && !file.startsWith("index"))
                    .map((file) => file.replace(".ts", ""));
                  const modelImports = new Set<string>();
                  const missingTypes = new Set<string>();
                  const operations: OperationDoc[] = [];
                  for (const [path, methodsObj] of Object.entries(
                    spec.paths as OpenAPIV2.PathsObject
                  )) {
                    if (!methodsObj) continue;
                    for (const [method, operation] of Object.entries(
                      methodsObj as OpenAPIV2.PathItemObject
                    )) {
                      const op = operation as OpenAPIV2.OperationObject | undefined;
                      if (!op || !op.operationId) continue;
                      const opId = simplifyName(op.operationId);
                      console.log(`Processing operation ${opId} (${method} ${path})`);
                      const paramDetails = (op.parameters || [])
                        .filter(
                          (p) =>
                            !["QB-Realm-Hostname", "Authorization", "User-Agent"].includes(
                              (p as OpenAPIV2.ParameterObject).name || ""
                            )
                        )
                        .map((p) => {
                          const param = p as OpenAPIV2.ParameterObject;
                          let type = "any";
                          let properties: PropertyDetail[] | undefined = undefined;
                          if ("schema" in p && p.schema) {
                            type = mapRefToType(
                              p.schema,
                              modelImports,
                              spec,
                              1,
                              availableModels,
                              missingTypes
                            );
                            if ("$ref" in p.schema && p.schema.$ref) {
                              const refParts = p.schema.$ref.split("/");
                              const model = refParts[refParts.length - 1];
                              const pascalModel =
                                model.charAt(0).toUpperCase() + model.slice(1);
                              properties = parseInterfaceProperties(
                                pascalModel,
                                modelsDir,
                                availableModels
                              );
                            } else if (type !== "any" && availableModels.includes(type)) {
                              properties = parseInterfaceProperties(
                                type,
                                modelsDir,
                                availableModels
                              );
                            }
                          } else if ("type" in p) {
                            type = mapOpenApiTypeToTs(p.type);
                          }
                          return {
                            name: param.in === "body" ? "body" : param.name,
                            type,
                            required: param.required || false,
                            description: param.description || "",
                            properties: properties || [],
                          };
                        });
                      const returnTypes = ["200", "207"]
                        .map(
                          (code) => (op.responses?.[code] as OpenAPIV2.ResponseObject)?.schema
                        )
                        .filter(Boolean)
                        .map((schema) =>
                          mapRefToType(
                            schema!,
                            modelImports,
                            spec,
                            1,
                            availableModels,
                            missingTypes
                          )
                        );
                      const returnType =
                        returnTypes.length > 1
                          ? returnTypes.join(" | ")
                          : returnTypes[0] || "void";
                      const returnTypeDetailsRaw = returnTypes
                        .filter((type) => type !== "void" && availableModels.includes(type))
                        .map((type) =>
                          parseInterfaceProperties(type, modelsDir, availableModels)
                        )
                        .flat();
                      const returnTypeDetails =
                        returnTypeDetailsRaw.length > 0
                          ? returnTypeDetailsRaw.map((prop) => ({
                              ...prop,
                              properties:
                                prop.properties && prop.properties.length > 0
                                  ? [...prop.properties]
                                  : undefined,
                            }))
                          : undefined;
                      operations.push({
                        name: opId,
                        summary: op.summary || "No description.",
                        method: method.toUpperCase(),
                        path,
                        parameters: paramDetails,
                        returns: returnType,
                        returnTypeDetails,
                        docLink: `https://developer.quickbase.com/operation/${op.operationId}`,
                      });
                    }
                  }
                  return { operations, modelImports, missingTypes };
                }


                //
                New
                shared
                function

                export
                function
                getPropertyDescription(prop:
                PropertyDetail):
                string
                {
                  return prop.jsdoc
                    ? prop.jsdoc.replace(/@type\s*{[^}]+}\s*@memberof\s*\w+/, "").trim()
                    : `Type: ${prop.type}`;
                }
    - name: >-
        openapitools.json
      type: >-
        file
    - name: >-
        package-lock.json
      type: >-
        file
    - name: >-
        package.json
      type: >-
        file
    - name: >-
        playwright.config.ts
      type: >-
        file
    - name: >-
        rollup.config.js
      type: >-
        file
    - name: >-
        src
      type: >-
        directory
      children:
        - name: >-
            RateLimitError.ts
          type: >-
            file
        - name: >-
            ThrottleBucket.ts
          type: >-
            file
        - name: >-
            authorizationStrategy.ts
          type: >-
            file
        - name: >-
            generated
          type: >-
            directory
          children:
            - name: >-
                .openapi-generator
              type: >-
                directory
              children:
                - name: >-
                    FILES
                  type: >-
                    file
                - name: >-
                    VERSION
                  type: >-
                    file
            - name: >-
                .openapi-generator-ignore
              type: >-
                file
            - name: >-
                apis
              type: >-
                directory
              children:
                - name: >-
                    AppsApi.ts
                  type: >-
                    file
                - name: >-
                    AuditApi.ts
                  type: >-
                    file
                - name: >-
                    AuthApi.ts
                  type: >-
                    file
                - name: >-
                    DocumentTemplatesApi.ts
                  type: >-
                    file
                - name: >-
                    FieldsApi.ts
                  type: >-
                    file
                - name: >-
                    FilesApi.ts
                  type: >-
                    file
                - name: >-
                    FormulasApi.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticsApi.ts
                  type: >-
                    file
                - name: >-
                    RecordsApi.ts
                  type: >-
                    file
                - name: >-
                    ReportsApi.ts
                  type: >-
                    file
                - name: >-
                    SolutionsApi.ts
                  type: >-
                    file
                - name: >-
                    TablesApi.ts
                  type: >-
                    file
                - name: >-
                    UserTokenApi.ts
                  type: >-
                    file
                - name: >-
                    UsersApi.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
            - name: >-
                index.ts
              type: >-
                file
            - name: >-
                models
              type: >-
                directory
              children:
                - name: >-
                    AddManagersToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddManagersToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    AddMembersToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddMembersToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    AddSubgroupsToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddSubgroupsToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    Audit200Response.ts
                  type: >-
                    file
                - name: >-
                    Audit202Response.ts
                  type: >-
                    file
                - name: >-
                    AuditRequest.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200ResponseInnerChangesInnerInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution404Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CloneUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    CloneUserTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    CopyApp200Response.ts
                  type: >-
                    file
                - name: >-
                    CopyAppRequest.ts
                  type: >-
                    file
                - name: >-
                    CopyAppRequestProperties.ts
                  type: >-
                    file
                - name: >-
                    CreateApp200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateAppRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateField200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateFieldRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateFieldRequestProperties.ts
                  type: >-
                    file
                - name: >-
                    CreateRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateRelationshipRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInnerCreatedResourcesInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInnerCreatedResourcesInnerAppsInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CreateTable200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateTableRequest.ts
                  type: >-
                    file
                - name: >-
                    DeactivateUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteApp200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteAppRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteFields200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteFieldsRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteFile200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteRecords200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteRecordsRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteTable200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersAndGroups200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersAndGroupsRequest.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    DownloadFile200Response.ts
                  type: >-
                    file
                - name: >-
                    ExchangeSsoToken200Response.ts
                  type: >-
                    file
                - name: >-
                    ExchangeSsoTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution404Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    GenerateDocument200Response.ts
                  type: >-
                    file
                - name: >-
                    GetApp200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppEvents200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppEvents200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetAppTables200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppTables200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetField200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFieldUsage200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFields200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFields200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetFieldsUsage200Response.ts
                  type: >-
                    file
                  contents: >+
                    /*
                    tslint:disable
                    */

                    /*
                    eslint-disable
                    */

                    /**
                     * Quick Base API
                     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
                     *
                     * The version of the OpenAPI document: 1.0.0
                     * 
                     *
                     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
                     * https://openapi-generator.tech
                     * Do not edit the class manually.
                     */

                    import
                    {
                    mapValues
                    }
                    from
                    '../runtime';

                    import
                    type
                    {
                    GetFieldsUsage200ResponseItemsInner
                    }
                    from
                    './GetFieldsUsage200ResponseItemsInner';

                    import
                    {
                        GetFieldsUsage200ResponseItemsInnerFromJSON,
                        GetFieldsUsage200ResponseItemsInnerFromJSONTyped,
                        GetFieldsUsage200ResponseItemsInnerToJSON,
                        GetFieldsUsage200ResponseItemsInnerToJSONTyped,
                    }
                    from
                    './GetFieldsUsage200ResponseItemsInner';


                    /**
                     * A response containing a list for getFieldsUsage200Response
                     * @export
                     * @interface GetFieldsUsage200Response
                     */
                    export
                    interface
                    GetFieldsUsage200Response
                    {
                        /**
                         * 
                         * @type {Array<GetFieldsUsage200ResponseItemsInner>}
                         * @memberof GetFieldsUsage200Response
                         */
                        items?: Array<GetFieldsUsage200ResponseItemsInner>;
                    }


                    /**
                     * Check if a given object implements the GetFieldsUsage200Response interface.
                     */
                    export
                    function
                    instanceOfGetFieldsUsage200Response(value:
                    object):
                    value
                    is
                    GetFieldsUsage200Response
                    {
                        return true;
                    }


                    export
                    function
                    GetFieldsUsage200ResponseFromJSON(json:
                    any):
                    GetFieldsUsage200Response
                    {
                        return GetFieldsUsage200ResponseFromJSONTyped(json, false);
                    }


                    export
                    function
                    GetFieldsUsage200ResponseFromJSONTyped(json:
                    any,
                    ignoreDiscriminator:
                    boolean):
                    GetFieldsUsage200Response
                    {
                        if (json == null) {
                            return json;
                        }
                        return {
                            
                            'items': json['items'] == null ? undefined : ((json['items'] as Array<any>).map(GetFieldsUsage200ResponseItemsInnerFromJSON)),
                        };
                    }


                    export
                    function
                    GetFieldsUsage200ResponseToJSON(json:
                    any):
                    GetFieldsUsage200Response
                    {
                        return GetFieldsUsage200ResponseToJSONTyped(json, false);
                    }


                    export
                    function
                    GetFieldsUsage200ResponseToJSONTyped(value?:
                    GetFieldsUsage200Response
                    |
                    null,
                    ignoreDiscriminator:
                    boolean
                    =
                    false):
                    any
                    {
                        if (value == null) {
                            return value;
                        }

                        return {
                            
                            'items': value['items'] == null ? undefined : ((value['items'] as Array<any>).map(GetFieldsUsage200ResponseItemsInnerToJSON)),
                        };
                    }

                - name: >-
                    GetFieldsUsage200ResponseItemsInner.ts
                  type: >-
                    file
                  contents: >+
                    /*
                    tslint:disable
                    */

                    /*
                    eslint-disable
                    */

                    /**
                     * Quick Base API
                     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
                     *
                     * The version of the OpenAPI document: 1.0.0
                     * 
                     *
                     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
                     * https://openapi-generator.tech
                     * Do not edit the class manually.
                     */

                    import
                    {
                    mapValues
                    }
                    from
                    '../runtime';

                    /**
                     * 
                     * @export
                     * @interface GetFieldsUsage200ResponseItemsInner
                     */
                    export
                    interface
                    GetFieldsUsage200ResponseItemsInner
                    {
                        /**
                         * Basic information about the field.
                         * @type {{ [key: string]: any; }}
                         * @memberof GetFieldsUsage200ResponseItemsInner
                         */
                        field: { [key: string]: any; };
                        /**
                         * Usage Information about the field.
                         * @type {{ [key: string]: any; }}
                         * @memberof GetFieldsUsage200ResponseItemsInner
                         */
                        usage: { [key: string]: any; };
                    }


                    /**
                     * Check if a given object implements the GetFieldsUsage200ResponseItemsInner interface.
                     */
                    export
                    function
                    instanceOfGetFieldsUsage200ResponseItemsInner(value:
                    object):
                    value
                    is
                    GetFieldsUsage200ResponseItemsInner
                    {
                        if (!('field' in value) || value['field'] === undefined) return false;
                        if (!('usage' in value) || value['usage'] === undefined) return false;
                        return true;
                    }


                    export
                    function
                    GetFieldsUsage200ResponseItemsInnerFromJSON(json:
                    any):
                    GetFieldsUsage200ResponseItemsInner
                    {
                        return GetFieldsUsage200ResponseItemsInnerFromJSONTyped(json, false);
                    }


                    export
                    function
                    GetFieldsUsage200ResponseItemsInnerFromJSONTyped(json:
                    any,
                    ignoreDiscriminator:
                    boolean):
                    GetFieldsUsage200ResponseItemsInner
                    {
                        if (json == null) {
                            return json;
                        }
                        return {
                            
                            'field': json['field'],
                            'usage': json['usage'],
                        };
                    }


                    export
                    function
                    GetFieldsUsage200ResponseItemsInnerToJSON(json:
                    any):
                    GetFieldsUsage200ResponseItemsInner
                    {
                        return GetFieldsUsage200ResponseItemsInnerToJSONTyped(json, false);
                    }


                    export
                    function
                    GetFieldsUsage200ResponseItemsInnerToJSONTyped(value?:
                    GetFieldsUsage200ResponseItemsInner
                    |
                    null,
                    ignoreDiscriminator:
                    boolean
                    =
                    false):
                    any
                    {
                        if (value == null) {
                            return value;
                        }

                        return {
                            
                            'field': value['field'],
                            'usage': value['usage'],
                        };
                    }

                - name: >-
                    GetRelationships200Response.ts
                  type: >-
                    file
                - name: >-
                    GetReport200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTable200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTableReports200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTableReports200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetTempTokenDBID200Response.ts
                  type: >-
                    file
                - name: >-
                    GetUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    GetUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    Permission.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200Response.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseMetadata.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseTotals.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseWhereInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummariesRequest.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummariesRequestWhereInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticReads200Response.ts
                  type: >-
                    file
                - name: >-
                    Record.ts
                  type: >-
                    file
                - name: >-
                    RecordValue.ts
                  type: >-
                    file
                - name: >-
                    RemoveManagersFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveManagersFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RemoveMembersFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveMembersFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RemoveSubgroupsFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveSubgroupsFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RunFormula200Response.ts
                  type: >-
                    file
                - name: >-
                    RunFormulaRequest.ts
                  type: >-
                    file
                - name: >-
                    RunQuery200Response.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequest.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestGroupByInner.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestOptions.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestSortByInner.ts
                  type: >-
                    file
                - name: >-
                    RunReport200Response.ts
                  type: >-
                    file
                - name: >-
                    TransferUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    TransferUserTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    UndenyUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    UndenyUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateApp200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateAppRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateField200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateFieldRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateRelationshipRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200ResponseInnerCreatedResourcesInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    UpdateTable200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateTableRequest.ts
                  type: >-
                    file
                - name: >-
                    Upsert200Response.ts
                  type: >-
                    file
                - name: >-
                    Upsert207Response.ts
                  type: >-
                    file
                - name: >-
                    Upsert400Response.ts
                  type: >-
                    file
                - name: >-
                    UpsertRequest.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
            - name: >-
                runtime.ts
              type: >-
                file
        - name: >-
            generated-unified
          type: >-
            directory
          children:
            - name: >-
                QuickbaseClient.ts
              type: >-
                file
              contents: >
                //
                Generated
                on
                2025-03-21T19:56:12.122Z

                import
                {
                AddManagersToGroup200Response,
                AddManagersToGroupRequest,
                AddMembersToGroup200Response,
                AddMembersToGroupRequest,
                AddSubgroupsToGroup200Response,
                AddSubgroupsToGroupRequest,
                Audit200Response,
                ChangesetSolution200Response,
                ChangesetSolutionFromRecord200Response,
                CloneUserToken200Response,
                CopyApp200Response,
                CopyAppRequest,
                CreateApp200Response,
                CreateAppRequest,
                CreateField200Response,
                CreateFieldRequest,
                CreateRelationship200Response,
                CreateRelationshipRequest,
                CreateSolution200Response,
                CreateSolutionFromRecord200Response,
                CreateTable200Response,
                CreateTableRequest,
                DeactivateUserToken200Response,
                DeleteApp200Response,
                DeleteAppRequest,
                DeleteFields200Response,
                DeleteFieldsRequest,
                DeleteFile200Response,
                DeleteRecords200Response,
                DeleteRecordsRequest,
                DeleteRelationship200Response,
                DeleteTable200Response,
                DeleteUserToken200Response,
                DenyUsers200Response,
                DenyUsersAndGroups200Response,
                DenyUsersAndGroupsRequest,
                DenyUsersRequest,
                DownloadFile200Response,
                ExchangeSsoToken200Response,
                ExportSolution200Response,
                ExportSolutionToRecord200Response,
                GenerateDocument200Response,
                GetApp200Response,
                GetAppEvents200Response,
                GetAppTables200Response,
                GetField200Response,
                GetFieldUsage200Response,
                GetFields200Response,
                GetFieldsUsage200Response,
                GetRelationships200Response,
                GetReport200Response,
                GetTable200Response,
                GetTableReports200Response,
                GetTempTokenDBID200Response,
                GetUsers200Response,
                GetUsersRequest,
                PlatformAnalyticEventSummaries200Response,
                PlatformAnalyticReads200Response,
                RemoveManagersFromGroup200Response,
                RemoveManagersFromGroupRequest,
                RemoveMembersFromGroup200Response,
                RemoveMembersFromGroupRequest,
                RemoveSubgroupsFromGroup200Response,
                RemoveSubgroupsFromGroupRequest,
                RunFormula200Response,
                RunQuery200Response,
                RunQueryRequest,
                RunReport200Response,
                TransferUserToken200Response,
                UndenyUsers200Response,
                UndenyUsersRequest,
                UpdateApp200Response,
                UpdateAppRequest,
                UpdateField200Response,
                UpdateFieldRequest,
                UpdateRelationship200Response,
                UpdateRelationshipRequest,
                UpdateSolution200Response,
                UpdateSolutionToRecord200Response,
                UpdateTable200Response,
                UpdateTableRequest,
                Upsert200Response,
                Upsert207Response,
                UpsertRequest
                }
                from
                "../generated/models";


                export
                interface
                QuickbaseClient
                {
                  /**
                   * Create an app
                   *
                   * @param {Object} params _Object containing the parameters for_ createApp
                   *   @param {CreateAppRequest} params.body _Optional parameter with properties_
                   *     - **name** (`string`, required) _The name of the app._
                   *     - **description** (`string`, optional) _A description for the app._
                   *     - **assignToken** (`boolean`, required) _Whether to assign the user token._
                   *
                   * @returns {Promise<CreateApp200Response>} _Promise resolving to the createApp response with properties_
                   *   - **name** (`string`, required) _The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this._
                   *   - **description** (`string`, optional) _The description for the app. If this property is left out, the app description will be blank._
                   *   - **created** (`string`, optional) _The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **updated** (`string`, optional) _The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **dateFormat** (`string`, optional) _A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/user-assistance/about_localizing_dates_numbers.html) to set the app’s date format._
                   *   - **timeZone** (`string`, optional) _A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/user-assistance/application_local_timezone.html) to set the application’s time zone._
                   *   - **memoryInfo** (`object`, optional) _Application memory info_
                   *   - **id** (`string`, optional) _The unique identifier for this application._
                   *   - **hasEveryoneOnTheInternet** (`boolean`, optional) _Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/user-assistance/share_with_everyone_on_internet.html)_
                   *   - **variables** (`{ [key: string]: any; }[]`, optional) _The app variables. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)_
                   *   - **dataClassification** (`string`, optional) _The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return “None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans._
                   *   - **securityProperties** (`{ [key: string]: any; }`, optional) _Security properties of the application_
                   *
                   * @see {@link https://developer.quickbase.com/operation/createApp} Official Quickbase API documentation
                   */
                  createApp: (params: { body?: CreateAppRequest }) => Promise<CreateApp200Response>;
                  /**
                   * Get an app
                   *
                   * @param {Object} params _Object containing the parameters for_ getApp
                   *   @param {string} params.appId _Required parameter with properties_
                   *
                   * @returns {Promise<GetApp200Response>} _Promise resolving to the getApp response with properties_
                   *   - **ancestorId** (`string`, optional) _The id of the app from which this app was copied_
                   *   - **name** (`string`, required) _The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this._
                   *   - **description** (`string`, optional) _The description for the app. If this property is left out, the app description will be blank._
                   *   - **created** (`string`, optional) _The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **updated** (`string`, optional) _The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **dateFormat** (`string`, optional) _A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/user-assistance/about_localizing_dates_numbers.html) to set the app’s date format._
                   *   - **timeZone** (`string`, optional) _A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/user-assistance/application_local_timezone.html) to set the application’s time zone._
                   *   - **memoryInfo** (`object`, optional) _Application memory info_
                   *   - **id** (`string`, optional) _The unique identifier for this application._
                   *   - **hasEveryoneOnTheInternet** (`boolean`, optional) _Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/user-assistance/share_with_everyone_on_internet.html)_
                   *   - **variables** (`{ [key: string]: any; }[]`, optional) _The app variables. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)_
                   *   - **dataClassification** (`string`, optional) _The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return “None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans._
                   *   - **securityProperties** (`{ [key: string]: any; }`, optional) _Security properties of the application_
                   *
                   * @see {@link https://developer.quickbase.com/operation/getApp} Official Quickbase API documentation
                   */
                  getApp: (params: { appId: string }) => Promise<GetApp200Response>;
                  /**
                   * Update an app
                   *
                   * @param {Object} params _Object containing the parameters for_ updateApp
                   *   @param {string} params.appId _Required parameter with properties_
                   *   @param {UpdateAppRequest} params.body _Optional parameter with properties_
                   *     - **name** (`string`, required) _The name of the app._
                   *     - **description** (`string`, optional) _A description for the app._
                   *     - **assignToken** (`boolean`, required) _Whether to assign the user token._
                   *
                   * @returns {Promise<UpdateApp200Response>} _Promise resolving to the updateApp response with properties_
                   *   - **ancestorId** (`string`, optional) _The id of the app from which this app was copied_
                   *   - **name** (`string`, required) _The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this._
                   *   - **description** (`string`, optional) _The description for the app. If this property is left out, the app description will be blank._
                   *   - **created** (`string`, optional) _The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **updated** (`string`, optional) _The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **dateFormat** (`string`, optional) _A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/user-assistance/about_localizing_dates_numbers.html) to set the app’s date format._
                   *   - **timeZone** (`string`, optional) _A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/user-assistance/application_local_timezone.html) to set the application’s time zone._
                   *   - **memoryInfo** (`object`, optional) _Application memory info_
                   *   - **id** (`string`, optional) _The unique identifier for this application._
                   *   - **hasEveryoneOnTheInternet** (`boolean`, optional) _Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/user-assistance/share_with_everyone_on_internet.html)_
                   *   - **variables** (`{ [key: string]: any; }[]`, optional) _The app variables. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)_
                   *   - **dataClassification** (`string`, optional) _The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return “None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans._
                   *   - **securityProperties** (`{ [key: string]: any; }`, optional) _Security properties of the application_
                   *
                   * @see {@link https://developer.quickbase.com/operation/updateApp} Official Quickbase API documentation
                   */
                  updateApp: (params: { appId: string; body?: UpdateAppRequest }) => Promise<UpdateApp200Response>;
                  /**
                   * Delete an app
                   *
                   * @param {Object} params _Object containing the parameters for_ deleteApp
                   *   @param {string} params.appId _Required parameter with properties_
                   *   @param {DeleteAppRequest} params.body _Optional parameter with properties_
                   *     - **name** (`string`, required) _The name of the app._
                   *     - **description** (`string`, optional) _A description for the app._
                   *     - **assignToken** (`boolean`, required) _Whether to assign the user token._
                   *
                   * @returns {Promise<DeleteApp200Response>} _Promise resolving to the deleteApp response with properties_
                   *   - **deletedAppId** (`string`, optional) _An ID of deleted application._
                   *
                   * @see {@link https://developer.quickbase.com/operation/deleteApp} Official Quickbase API documentation
                   */
                  deleteApp: (params: { appId: string; body?: DeleteAppRequest }) => Promise<DeleteApp200Response>;
                  /**
                   * Get app events
                   *
                   * @param {Object} params _Object containing the parameters for_ getAppEvents
                   *   @param {string} params.appId _Required parameter with properties_
                   *
                   * @returns {Promise<GetAppEvents200Response>} _Promise resolving to the getAppEvents response with properties_
                   *   - **items** (`GetAppEvents200ResponseItemsInner[]`, optional) __
                   *     *   - **isActive** (`boolean`, optional) _Indication of whether current event is active._
                   *     *   - **type** (`GetAppEvents200ResponseItemsInnerTypeEnum`, optional) _Type of an event._
                   *     *   - **name** (`string`, optional) _The name of the event. This property is not returned for automations._
                   *     *   - **url** (`string`, optional) _The url to automation that can be accessed from the browser. Only returned for automations._
                   *     *   - **owner** (`{ [key: string]: any; }`, optional) _The user that owns the event._
                   *     *   - **tableId** (`string`, optional) _The unique identifier of the table to which event belongs to._
                   *
                   * @see {@link https://developer.quickbase.com/operation/getAppEvents} Official Quickbase API documentation
                   */
                  getAppEvents: (params: { appId: string }) => Promise<GetAppEvents200Response>;
                  /**
                   * Copy an app
                   *
                   * @param {Object} params _Object containing the parameters for_ copyApp
                   *   @param {string} params.appId _Required parameter with properties_
                   *   @param {CopyAppRequest} params.body _Optional parameter with properties_
                   *     - **name** (`string`, required) _The name of the new app._
                   *     - **description** (`string`, optional) _A description for the new app._
                   *     - **properties** (`CopyAppRequestProperties`, optional) _Type: CopyAppRequestProperties_
                   *
                   * @returns {Promise<CopyApp200Response>} _Promise resolving to the copyApp response with properties_
                   *   - **name** (`string`, required) _The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this._
                   *   - **description** (`string`, optional) _The description for the app_
                   *   - **created** (`string`, optional) _The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **updated** (`string`, optional) _The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **dateFormat** (`string`, optional) _A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/user-assistance/about_localizing_dates_numbers.html) to set the app’s date format._
                   *   - **timeZone** (`string`, optional) _A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/user-assistance/application_local_timezone.html) to set the application’s time zone._
                   *   - **id** (`string`, optional) _The unique identifier for this application._
                   *   - **hasEveryoneOnTheInternet** (`boolean`, optional) _Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/user-assistance/share_with_everyone_on_internet.html)_
                   *   - **variables** (`{ [key: string]: any; }[]`, optional) _The app variables. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)_
                   *   - **ancestorId** (`string`, optional) _The id of the app from which this app was copied_
                   *   - **dataClassification** (`string`, optional) _The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return “None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans._
                   *
                   * @see {@link https://developer.quickbase.com/operation/copyApp} Official Quickbase API documentation
                   */
                  copyApp: (params: { appId: string; body?: CopyAppRequest }) => Promise<CopyApp200Response>;
                  /**
                   * Create a table
                   *
                   * @param {Object} params _Object containing the parameters for_ createTable
                   *   @param {string} params.appId _Required parameter with properties_
                   *   @param {CreateTableRequest} params.body _Optional parameter with properties_
                   *     - **name** (`string`, required) _The name for the table._
                   *     - **description** (`string`, optional) _The description for the table..._
                   *     - **singleRecordName** (`string`, optional) _The singular noun for records..._
                   *     - **pluralRecordName** (`string`, optional) _The plural noun for records..._
                   *
                   * @returns {Promise<CreateTable200Response>} _Promise resolving to the createTable response with properties_
                   *   - **name** (`string`, optional) _The name of the table._
                   *   - **id** (`string`, optional) _The unique identifier (dbid) of the table._
                   *   - **alias** (`string`, optional) _The automatically-created table alias for the table._
                   *   - **description** (`string`, optional) _The description of the table, as configured by an application administrator._
                   *   - **created** (`string`, optional) _The time and date when the table was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **updated** (`string`, optional) _The time and date when the table schema or data was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **nextRecordId** (`number`, optional) _The incremental Record ID that will be used when the next record is created, as determined when the API call was ran._
                   *   - **nextFieldId** (`number`, optional) _The incremental Field ID that will be used when the next field is created, as determined when the API call was ran._
                   *   - **defaultSortFieldId** (`number`, optional) _The id of the field that is configured for default sorting._
                   *   - **defaultSortOrder** (`CreateTable200ResponseDefaultSortOrderEnum`, optional) _The configuration of the default sort order on the table._
                   *   - **keyFieldId** (`number`, optional) _The id of the field that is configured to be the key on this table, which is usually the Quickbase Record ID._
                   *   - **singleRecordName** (`string`, optional) _The builder-configured singular noun of the table._
                   *   - **pluralRecordName** (`string`, optional) _The builder-configured plural noun of the table._
                   *   - **sizeLimit** (`string`, optional) _The size limit for the table._
                   *   - **spaceUsed** (`string`, optional) _The amount of space currently being used by the table._
                   *   - **spaceRemaining** (`string`, optional) _The amount of space remaining for use by the table._
                   *
                   * @see {@link https://developer.quickbase.com/operation/createTable} Official Quickbase API documentation
                   */
                  createTable: (params: { appId: string; body?: CreateTableRequest }) => Promise<CreateTable200Response>;
                  /**
                   * Get tables for an app
                   *
                   * @param {Object} params _Object containing the parameters for_ getAppTables
                   *   @param {string} params.appId _Required parameter with properties_
                   *
                   * @returns {Promise<GetAppTables200Response>} _Promise resolving to the getAppTables response with properties_
                   *   - **items** (`GetAppTables200ResponseItemsInner[]`, optional) __
                   *     *   - **name** (`string`, optional) _The name of the table._
                   *     *   - **id** (`string`, optional) _The unique identifier (dbid) of the table._
                   *     *   - **alias** (`string`, optional) _The automatically-created table alias for the table._
                   *     *   - **description** (`string`, optional) _The description of the table, as configured by an application administrator._
                   *     *   - **created** (`string`, optional) _The time and date when the table was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *     *   - **updated** (`string`, optional) _The time and date when the table schema or data was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *     *   - **nextRecordId** (`number`, optional) _The incremental Record ID that will be used when the next record is created, as determined when the API call was ran._
                   *     *   - **nextFieldId** (`number`, optional) _The incremental Field ID that will be used when the next field is created, as determined when the API call was ran._
                   *     *   - **defaultSortFieldId** (`number`, optional) _The id of the field that is configured for default sorting._
                   *     *   - **defaultSortOrder** (`GetAppTables200ResponseItemsInnerDefaultSortOrderEnum`, optional) _The configuration of the default sort order on the table._
                   *     *   - **keyFieldId** (`number`, optional) _The id of the field that is configured to be the key on this table, which is usually the Quickbase Record ID._
                   *     *   - **singleRecordName** (`string`, optional) _The builder-configured singular noun of the table._
                   *     *   - **pluralRecordName** (`string`, optional) _The builder-configured plural noun of the table._
                   *     *   - **sizeLimit** (`string`, optional) _The size limit for the table._
                   *     *   - **spaceUsed** (`string`, optional) _The amount of space currently being used by the table._
                   *     *   - **spaceRemaining** (`string`, optional) _The amount of space remaining for use by the table._
                   *
                   * @see {@link https://developer.quickbase.com/operation/getAppTables} Official Quickbase API documentation
                   */
                  getAppTables: (params: { appId: string }) => Promise<GetAppTables200Response>;
                  /**
                   * Get a table
                   *
                   * @param {Object} params _Object containing the parameters for_ getTable
                   *   @param {string} params.appId _Required parameter with properties_
                   *   @param {string} params.tableId _Required parameter with properties_
                   *
                   * @returns {Promise<GetTable200Response>} _Promise resolving to the getTable response with properties_
                   *   - **name** (`string`, optional) _The name of the table._
                   *   - **id** (`string`, optional) _The unique identifier (dbid) of the table._
                   *   - **alias** (`string`, optional) _The automatically-created table alias for the table._
                   *   - **description** (`string`, optional) _The description of the table, as configured by an application administrator._
                   *   - **created** (`string`, optional) _The time and date when the table was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **updated** (`string`, optional) _The time and date when the table schema or data was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **nextRecordId** (`number`, optional) _The incremental Record ID that will be used when the next record is created, as determined when the API call was ran._
                   *   - **nextFieldId** (`number`, optional) _The incremental Field ID that will be used when the next field is created, as determined when the API call was ran._
                   *   - **defaultSortFieldId** (`number`, optional) _The id of the field that is configured for default sorting._
                   *   - **defaultSortOrder** (`GetTable200ResponseDefaultSortOrderEnum`, optional) _The configuration of the default sort order on the table._
                   *   - **keyFieldId** (`number`, optional) _The id of the field that is configured to be the key on this table, which is usually the Quickbase Record ID._
                   *   - **singleRecordName** (`string`, optional) _The builder-configured singular noun of the table._
                   *   - **pluralRecordName** (`string`, optional) _The builder-configured plural noun of the table._
                   *   - **sizeLimit** (`string`, optional) _The size limit for the table._
                   *   - **spaceUsed** (`string`, optional) _The amount of space currently being used by the table._
                   *   - **spaceRemaining** (`string`, optional) _The amount of space remaining for use by the table._
                   *
                   * @see {@link https://developer.quickbase.com/operation/getTable} Official Quickbase API documentation
                   */
                  getTable: (params: { appId: string; tableId: string }) => Promise<GetTable200Response>;
                  /**
                   * Update a table
                   *
                   * @param {Object} params _Object containing the parameters for_ updateTable
                   *   @param {string} params.appId _Required parameter with properties_
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {UpdateTableRequest} params.body _Optional parameter with properties_
                   *     - **name** (`string`, optional) _The updated name of the table._
                   *     - **description** (`string`, optional) _The updated description for the table._
                   *
                   * @returns {Promise<UpdateTable200Response>} _Promise resolving to the updateTable response with properties_
                   *   - **name** (`string`, optional) _The name of the table._
                   *   - **id** (`string`, optional) _The unique identifier (dbid) of the table._
                   *   - **alias** (`string`, optional) _The automatically-created table alias for the table._
                   *   - **description** (`string`, optional) _The description of the table, as configured by an application administrator._
                   *   - **created** (`string`, optional) _The time and date when the table was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **updated** (`string`, optional) _The time and date when the table schema or data was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **nextRecordId** (`number`, optional) _The incremental Record ID that will be used when the next record is created, as determined when the API call was ran._
                   *   - **nextFieldId** (`number`, optional) _The incremental Field ID that will be used when the next field is created, as determined when the API call was ran._
                   *   - **defaultSortFieldId** (`number`, optional) _The id of the field that is configured for default sorting._
                   *   - **defaultSortOrder** (`UpdateTable200ResponseDefaultSortOrderEnum`, optional) _The configuration of the default sort order on the table._
                   *   - **keyFieldId** (`number`, optional) _The id of the field that is configured to be the key on this table, which is usually the Quickbase Record ID._
                   *   - **singleRecordName** (`string`, optional) _The builder-configured singular noun of the table._
                   *   - **pluralRecordName** (`string`, optional) _The builder-configured plural noun of the table._
                   *   - **sizeLimit** (`string`, optional) _The size limit for the table._
                   *   - **spaceUsed** (`string`, optional) _The amount of space currently being used by the table._
                   *   - **spaceRemaining** (`string`, optional) _The amount of space remaining for use by the table._
                   *
                   * @see {@link https://developer.quickbase.com/operation/updateTable} Official Quickbase API documentation
                   */
                  updateTable: (params: { appId: string; tableId: string; body?: UpdateTableRequest }) => Promise<UpdateTable200Response>;
                  /**
                   * Delete a table
                   *
                   * @param {Object} params _Object containing the parameters for_ deleteTable
                   *   @param {string} params.appId _Required parameter with properties_
                   *   @param {string} params.tableId _Required parameter with properties_
                   *
                   * @returns {Promise<DeleteTable200Response>} _Promise resolving to the deleteTable response with properties_
                   *   - **deletedTableId** (`string`, optional) _The deleted table id._
                   *
                   * @see {@link https://developer.quickbase.com/operation/deleteTable} Official Quickbase API documentation
                   */
                  deleteTable: (params: { appId: string; tableId: string }) => Promise<DeleteTable200Response>;
                  /**
                   * Get all relationships
                   *
                   * @param {Object} params _Object containing the parameters for_ getRelationships
                   *   @param {number} params.skip _Optional parameter with properties_
                   *   @param {string} params.tableId _Required parameter with properties_
                   *
                   * @returns {Promise<GetRelationships200Response>} _Promise resolving to the getRelationships response with properties_
                   *   - **relationships** (`{ [key: string]: any; }[]`, required) _The relationships in a table._
                   *   - **metadata** (`{ [key: string]: any; }`, optional) _Additional information about the results that may be helpful._
                   *
                   * @see {@link https://developer.quickbase.com/operation/getRelationships} Official Quickbase API documentation
                   */
                  getRelationships: (params: { skip?: number; tableId: string }) => Promise<GetRelationships200Response>;
                  /**
                   * Create a relationship
                   *
                   * @param {Object} params _Object containing the parameters for_ createRelationship
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {CreateRelationshipRequest} params.body _Optional parameter with properties_
                   *     - **parentTableId** (`string`, required) _The parent table id for the relationship._
                   *     - **foreignKeyField** (`{ [key: string]: any; }`, optional) _Type: { [key: string]: any; }_
                   *     - **lookupFieldIds** (`number[]`, optional) _Array of field ids..._
                   *     - **summaryFields** (`{ [key: string]: any; }[]`, optional) _Array of summary field objects..._
                   *
                   * @returns {Promise<CreateRelationship200Response>} _Promise resolving to the createRelationship response with properties_
                   *   - **id** (`number`, required) _The relationship id (foreign key field id)._
                   *   - **parentTableId** (`string`, required) _The parent table id of the relationship._
                   *   - **childTableId** (`string`, required) _The child table id of the relationship._
                   *   - **foreignKeyField** (`{ [key: string]: any; }`, optional) _The foreign key field information._
                   *   - **isCrossApp** (`boolean`, required) _Whether this is a cross-app relationship._
                   *   - **lookupFields** (`{ [key: string]: any; }[]`, optional) _The lookup fields array._
                   *   - **summaryFields** (`{ [key: string]: any; }[]`, optional) _The summary fields array._
                   *
                   * @see {@link https://developer.quickbase.com/operation/createRelationship} Official Quickbase API documentation
                   */
                  createRelationship: (params: { tableId: string; body?: CreateRelationshipRequest }) => Promise<CreateRelationship200Response>;
                  /**
                   * Update a relationship
                   *
                   * @param {Object} params _Object containing the parameters for_ updateRelationship
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {number} params.relationshipId _Required parameter with properties_
                   *   @param {UpdateRelationshipRequest} params.body _Optional parameter with properties_
                   *     - **parentTableId** (`string`, optional) _The updated parent table id..._
                   *     - **foreignKeyField** (`{ [key: string]: any; }`, optional) _Type: { [key: string]: any; }_
                   *     - **lookupFieldIds** (`number[]`, optional) _Updated array of field ids..._
                   *     - **summaryFields** (`{ [key: string]: any; }[]`, optional) _Type: { [key: string]: any; }[]_
                   *
                   * @returns {Promise<UpdateRelationship200Response>} _Promise resolving to the updateRelationship response with properties_
                   *   - **id** (`number`, required) _The relationship id (foreign key field id)._
                   *   - **parentTableId** (`string`, required) _The parent table id of the relationship._
                   *   - **childTableId** (`string`, required) _The child table id of the relationship._
                   *   - **foreignKeyField** (`{ [key: string]: any; }`, optional) _The foreign key field information._
                   *   - **isCrossApp** (`boolean`, required) _Whether this is a cross-app relationship._
                   *   - **lookupFields** (`{ [key: string]: any; }[]`, optional) _The lookup fields array._
                   *   - **summaryFields** (`{ [key: string]: any; }[]`, optional) _The summary fields array._
                   *
                   * @see {@link https://developer.quickbase.com/operation/updateRelationship} Official Quickbase API documentation
                   */
                  updateRelationship: (params: { tableId: string; relationshipId: number; body?: UpdateRelationshipRequest }) => Promise<UpdateRelationship200Response>;
                  /**
                   * Delete a relationship
                   *
                   * @param {Object} params _Object containing the parameters for_ deleteRelationship
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {number} params.relationshipId _Required parameter with properties_
                   *
                   * @returns {Promise<DeleteRelationship200Response>} _Promise resolving to the deleteRelationship response with properties_
                   *   - **relationshipId** (`number`, required) _The relationship id._
                   *
                   * @see {@link https://developer.quickbase.com/operation/deleteRelationship} Official Quickbase API documentation
                   */
                  deleteRelationship: (params: { tableId: string; relationshipId: number }) => Promise<DeleteRelationship200Response>;
                  /**
                   * Get reports for a table
                   *
                   * @param {Object} params _Object containing the parameters for_ getTableReports
                   *   @param {string} params.tableId _Required parameter with properties_
                   *
                   * @returns {Promise<GetTableReports200Response>} _Promise resolving to the getTableReports response with properties_
                   *   - **items** (`GetTableReports200ResponseItemsInner[]`, optional) __
                   *     *   - **id** (`string`, optional) _The identifier of the report, unique to the table._
                   *     *   - **name** (`string`, optional) _The configured name of the report._
                   *     *   - **type** (`string`, optional) _The type of report in Quickbase (e.g., chart)._
                   *     *   - **description** (`string`, optional) _The configured description of a report._
                   *     *   - **ownerId** (`number`, optional) _Optional, showed only for personal reports. The user ID of report owner._
                   *     *   - **query** (`{ [key: string]: any; }`, optional) _The query definition as configured in Quickbase that gets executed when the report is run._
                   *     *   - **properties** (`{ [key: string]: any; }`, optional) _A list of properties specific to the report type. To see a detailed description of the properties for each report type, See [Report Types.](../reportTypes)_
                   *     *   - **usedLast** (`string`, optional) _The instant at which a report was last used._
                   *     *   - **usedCount** (`number`, optional) _The number of times a report has been used._
                   *
                   * @see {@link https://developer.quickbase.com/operation/getTableReports} Official Quickbase API documentation
                   */
                  getTableReports: (params: { tableId: string }) => Promise<GetTableReports200Response>;
                  /**
                   * Get a report
                   *
                   * @param {Object} params _Object containing the parameters for_ getReport
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {string} params.reportId _Required parameter with properties_
                   *
                   * @returns {Promise<GetReport200Response>} _Promise resolving to the getReport response with properties_
                   *   - **id** (`string`, optional) _The identifier of the report, unique to the table._
                   *   - **name** (`string`, optional) _The configured name of the report._
                   *   - **type** (`string`, optional) _The type of report in Quickbase (e.g., chart)._
                   *   - **description** (`string`, optional) _The configured description of a report._
                   *   - **ownerId** (`number`, optional) _Optional, showed only for personal reports. The user ID of report owner._
                   *   - **query** (`{ [key: string]: any; }`, optional) _The query definition as configured in Quickbase that gets executed when the report is run._
                   *   - **properties** (`{ [key: string]: any; }`, optional) _A list of properties specific to the report type. To see a detailed description of the properties for each report type, See [Report Types.](../reportTypes)_
                   *   - **usedLast** (`string`, optional) _The instant at which a report was last used._
                   *   - **usedCount** (`number`, optional) _The number of times a report has been used._
                   *
                   * @see {@link https://developer.quickbase.com/operation/getReport} Official Quickbase API documentation
                   */
                  getReport: (params: { tableId: string; reportId: string }) => Promise<GetReport200Response>;
                  /**
                   * Run a report
                   *
                   * @param {Object} params _Object containing the parameters for_ runReport
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {number} params.skip _Optional parameter with properties_
                   *   @param {number} params.top _Optional parameter with properties_
                   *   @param {string} params.reportId _Required parameter with properties_
                   *   @param {any} params.body _Optional parameter with properties_
                   *
                   * @returns {Promise<RunReport200Response>} _Promise resolving to the runReport response with properties_
                   *   - **fields** (`{ [key: string]: any; }[]`, optional) _An array of objects that contains limited meta-data of each field displayed in the report. This assists in building logic that depends on field types and IDs._
                   *   - **data** (`string[]`, optional) _An array of objects that either represents the record data or summarized values, depending on the report type._
                   *   - **metadata** (`{ [key: string]: any; }`, optional) _Additional information about the results that may be helpful. Pagination may be needed if either you specify a smaller number of results to skip than is available, or if the API automatically returns fewer results. numRecords can be compared to totalRecords to determine if further pagination is needed._
                   *
                   * @see {@link https://developer.quickbase.com/operation/runReport} Official Quickbase API documentation
                   */
                  runReport: (params: { tableId: string; skip?: number; top?: number; reportId: string; body?: any }) => Promise<RunReport200Response>;
                  /**
                   * Get fields for a table
                   *
                   * @param {Object} params _Object containing the parameters for_ getFields
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {boolean} params.includeFieldPerms _Optional parameter with properties_
                   *
                   * @returns {Promise<GetFields200Response>} _Promise resolving to the getFields response with properties_
                   *   - **items** (`GetFields200ResponseItemsInner[]`, optional) __
                   *     *   - **id** (`number`, required) _The id of the field, unique to this table._
                   *     *   - **fieldType** (`string`, optional) _The type of field, as described [here](https://help.quickbase.com/user-assistance/field_types.html)._
                   *     *   - **mode** (`string`, optional) _For derived fields, this will be 'lookup', 'summary', or 'formula', to indicate the type of derived field.  For non-derived fields, this will be blank._
                   *     *   - **label** (`string`, optional) _The label (name) of the field._
                   *     *   - **noWrap** (`boolean`, optional) _Indicates if the field is configured to not wrap when displayed in the product._
                   *     *   - **bold** (`boolean`, optional) _Indicates if the field is configured to display in bold in the product._
                   *     *   - **required** (`boolean`, optional) _Indicates if the field is marked required._
                   *     *   - **appearsByDefault** (`boolean`, optional) _Indicates if the field is marked as a default in reports._
                   *     *   - **findEnabled** (`boolean`, optional) _Indicates if the field is marked as searchable._
                   *     *   - **unique** (`boolean`, optional) _Indicates if the field is marked unique._
                   *     *   - **doesDataCopy** (`boolean`, optional) _Indicates if the field data will copy when a user copies the record._
                   *     *   - **fieldHelp** (`string`, optional) _The configured help text shown to users within the product._
                   *     *   - **audited** (`boolean`, optional) _Indicates if the field is being tracked as part of Quickbase Audit Logs._
                   *     *   - **properties** (`{ [key: string]: any; }`, optional) _Additional properties for the field. Please see [Field type details](../fieldInfo) page for more details on the properties for each field type._
                   *     *   - **permissions** (`object[]`, optional) _Field Permissions for different roles._
                   *
                   * @see {@link https://developer.quickbase.com/operation/getFields} Official Quickbase API documentation
                   */
                  getFields: (params: { tableId: string; includeFieldPerms?: boolean }) => Promise<GetFields200Response>;
                  /**
                   * Create a field
                   *
                   * @param {Object} params _Object containing the parameters for_ createField
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {CreateFieldRequest} params.body _Optional parameter with properties_
                   *     - **label** (`string`, required) _The label of the field_
                   *     - **fieldType** (`CreateFieldRequestFieldTypeEnum`, required) _The type of the field_
                   *     - **fieldHelp** (`string`, optional) _Help text for the field_
                   *     - **addToForms** (`boolean`, optional) _Whether to add the field to forms_
                   *     - **permissions** (`object`, optional) _Custom permissions for the field_
                   *     - **required** (`boolean`, optional) _Whether the field is required_
                   *     - **unique** (`boolean`, optional) _Whether the field must have unique values_
                   *     - **noWrap** (`boolean`, optional) _Whether text wrapping is disabled_
                   *     - **bold** (`boolean`, optional) _Whether the field is bolded_
                   *     - **appearsByDefault** (`boolean`, optional) _Whether the field appears by default in reports_
                   *     - **findEnabled** (`boolean`, optional) _Whether the field is searchable_
                   *     - **doesDataCopy** (`boolean`, optional) _Whether the field copies data_
                   *     - **audited** (`boolean`, optional) _Whether changes to the field are audited_
                   *     - **properties** (`CreateFieldRequestProperties`, optional) _Type: CreateFieldRequestProperties_
                   *
                   * @returns {Promise<CreateField200Response>} _Promise resolving to the createField response with properties_
                   *   - **id** (`number`, required) _The id of the field, unique to this table._
                   *   - **fieldType** (`string`, optional) _The type of field, as described [here](https://help.quickbase.com/user-assistance/field_types.html)._
                   *   - **mode** (`string`, optional) _For derived fields, this will be 'lookup', 'summary', or 'formula', to indicate the type of derived field.  For non-derived fields, this will be blank._
                   *   - **label** (`string`, optional) _The label (name) of the field._
                   *   - **noWrap** (`boolean`, optional) _Indicates if the field is configured to not wrap when displayed in the product._
                   *   - **bold** (`boolean`, optional) _Indicates if the field is configured to display in bold in the product._
                   *   - **required** (`boolean`, optional) _Indicates if the field is marked required._
                   *   - **appearsByDefault** (`boolean`, optional) _Indicates if the field is marked as a default in reports._
                   *   - **findEnabled** (`boolean`, optional) _Indicates if the field is marked as searchable._
                   *   - **unique** (`boolean`, optional) _Indicates if the field is marked unique._
                   *   - **doesDataCopy** (`boolean`, optional) _Indicates if the field data will copy when a user copies the record._
                   *   - **fieldHelp** (`string`, optional) _The configured help text shown to users within the product._
                   *   - **audited** (`boolean`, optional) _Indicates if the field is being tracked as part of Quickbase Audit Logs._
                   *   - **properties** (`{ [key: string]: any; }`, optional) _Additional properties for the field. Please see [Field type details](../fieldInfo) page for more details on the properties for each field type._
                   *   - **permissions** (`object[]`, optional) _Field Permissions for different roles._
                   *
                   * @see {@link https://developer.quickbase.com/operation/createField} Official Quickbase API documentation
                   */
                  createField: (params: { tableId: string; body?: CreateFieldRequest }) => Promise<CreateField200Response>;
                  /**
                   * Delete field(s)
                   *
                   * @param {Object} params _Object containing the parameters for_ deleteFields
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {DeleteFieldsRequest} params.body _Optional parameter with properties_
                   *     - **fieldIds** (`number[]`, required) _Type: number[]_
                   *
                   * @returns {Promise<DeleteFields200Response>} _Promise resolving to the deleteFields response with properties_
                   *   - **deletedFieldIds** (`number[]`, required) _List of field ids to were deleted._
                   *   - **errors** (`string[]`, required) _List of errors found._
                   *
                   * @see {@link https://developer.quickbase.com/operation/deleteFields} Official Quickbase API documentation
                   */
                  deleteFields: (params: { tableId: string; body?: DeleteFieldsRequest }) => Promise<DeleteFields200Response>;
                  /**
                   * Get field
                   *
                   * @param {Object} params _Object containing the parameters for_ getField
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {boolean} params.includeFieldPerms _Optional parameter with properties_
                   *   @param {number} params.fieldId _Required parameter with properties_
                   *
                   * @returns {Promise<GetField200Response>} _Promise resolving to the getField response with properties_
                   *   - **id** (`number`, required) _The id of the field, unique to this table._
                   *   - **fieldType** (`string`, optional) _The type of field, as described [here](https://help.quickbase.com/user-assistance/field_types.html)._
                   *   - **mode** (`string`, optional) _For derived fields, this will be 'lookup', 'summary', or 'formula', to indicate the type of derived field.  For non-derived fields, this will be blank._
                   *   - **label** (`string`, optional) _The label (name) of the field._
                   *   - **noWrap** (`boolean`, optional) _Indicates if the field is configured to not wrap when displayed in the product._
                   *   - **bold** (`boolean`, optional) _Indicates if the field is configured to display in bold in the product._
                   *   - **required** (`boolean`, optional) _Indicates if the field is marked required._
                   *   - **appearsByDefault** (`boolean`, optional) _Indicates if the field is marked as a default in reports._
                   *   - **findEnabled** (`boolean`, optional) _Indicates if the field is marked as searchable._
                   *   - **unique** (`boolean`, optional) _Indicates if the field is marked unique._
                   *   - **doesDataCopy** (`boolean`, optional) _Indicates if the field data will copy when a user copies the record._
                   *   - **fieldHelp** (`string`, optional) _The configured help text shown to users within the product._
                   *   - **audited** (`boolean`, optional) _Indicates if the field is being tracked as part of Quickbase Audit Logs._
                   *   - **properties** (`{ [key: string]: any; }`, optional) _Additional properties for the field. Please see [Field type details](../fieldInfo) page for more details on the properties for each field type._
                   *   - **permissions** (`object[]`, optional) _Field Permissions for different roles._
                   *
                   * @see {@link https://developer.quickbase.com/operation/getField} Official Quickbase API documentation
                   */
                  getField: (params: { tableId: string; includeFieldPerms?: boolean; fieldId: number }) => Promise<GetField200Response>;
                  /**
                   * Update a field
                   *
                   * @param {Object} params _Object containing the parameters for_ updateField
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {number} params.fieldId _Required parameter with properties_
                   *   @param {UpdateFieldRequest} params.body _Optional parameter with properties_
                   *     - **label** (`string`, required) _The label of the field_
                   *     - **fieldType** (`UpdateFieldRequestFieldTypeEnum`, optional) _The type of the field_
                   *     - **fieldHelp** (`string`, optional) _Help text for the field_
                   *     - **addToForms** (`boolean`, optional) _Whether to add the field to forms_
                   *     - **permissions** (`object`, optional) _Custom permissions for the field_
                   *     - **required** (`boolean`, optional) _Whether the field is required_
                   *     - **unique** (`boolean`, optional) _Whether the field must have unique values_
                   *     - **noWrap** (`boolean`, optional) _Whether text wrapping is disabled_
                   *     - **bold** (`boolean`, optional) _Whether the field is bolded_
                   *     - **appearsByDefault** (`boolean`, optional) _Whether the field appears by default in reports_
                   *     - **findEnabled** (`boolean`, optional) _Whether the field is searchable_
                   *     - **doesDataCopy** (`boolean`, optional) _Whether the field copies data_
                   *     - **audited** (`boolean`, optional) _Whether changes to the field are audited_
                   *     - **properties** (`CreateFieldRequestProperties`, optional) _Type: CreateFieldRequestProperties_
                   *
                   * @returns {Promise<UpdateField200Response>} _Promise resolving to the updateField response with properties_
                   *   - **id** (`number`, required) _The id of the field, unique to this table._
                   *   - **fieldType** (`string`, optional) _The type of field, as described [here](https://help.quickbase.com/user-assistance/field_types.html)._
                   *   - **mode** (`string`, optional) _For derived fields, this will be 'lookup', 'summary', or 'formula', to indicate the type of derived field.  For non-derived fields, this will be blank._
                   *   - **label** (`string`, optional) _The label (name) of the field._
                   *   - **noWrap** (`boolean`, optional) _Indicates if the field is configured to not wrap when displayed in the product._
                   *   - **bold** (`boolean`, optional) _Indicates if the field is configured to display in bold in the product._
                   *   - **required** (`boolean`, optional) _Indicates if the field is marked required._
                   *   - **appearsByDefault** (`boolean`, optional) _Indicates if the field is marked as a default in reports._
                   *   - **findEnabled** (`boolean`, optional) _Indicates if the field is marked as searchable._
                   *   - **unique** (`boolean`, optional) _Indicates if the field is marked unique._
                   *   - **doesDataCopy** (`boolean`, optional) _Indicates if the field data will copy when a user copies the record._
                   *   - **fieldHelp** (`string`, optional) _The configured help text shown to users within the product._
                   *   - **audited** (`boolean`, optional) _Indicates if the field is being tracked as part of Quickbase Audit Logs._
                   *   - **properties** (`{ [key: string]: any; }`, optional) _Additional properties for the field. Please see [Field type details](../fieldInfo) page for more details on the properties for each field type._
                   *   - **permissions** (`object[]`, optional) _Field Permissions for different roles._
                   *
                   * @see {@link https://developer.quickbase.com/operation/updateField} Official Quickbase API documentation
                   */
                  updateField: (params: { tableId: string; fieldId: number; body?: UpdateFieldRequest }) => Promise<UpdateField200Response>;
                  /**
                   * Get usage for all fields
                   *
                   * @param {Object} params _Object containing the parameters for_ getFieldsUsage
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {number} params.skip _Optional parameter with properties_
                   *   @param {number} params.top _Optional parameter with properties_
                   *
                   * @returns {Promise<GetFieldsUsage200Response>} _Promise resolving to the getFieldsUsage response with properties_
                   *   - **items** (`GetFieldsUsage200ResponseItemsInner[]`, optional) __
                   *     *   - **field** (`{ [key: string]: any; }`, required) _Basic information about the field._
                   *     *   - **usage** (`{ [key: string]: any; }`, required) _Usage Information about the field._
                   *
                   * @see {@link https://developer.quickbase.com/operation/getFieldsUsage} Official Quickbase API documentation
                   */
                  getFieldsUsage: (params: { tableId: string; skip?: number; top?: number }) => Promise<GetFieldsUsage200Response>;
                  /**
                   * Get usage for a field
                   *
                   * @param {Object} params _Object containing the parameters for_ getFieldUsage
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {number} params.fieldId _Required parameter with properties_
                   *
                   * @returns {Promise<GetFieldUsage200Response>} _Promise resolving to the getFieldUsage response with properties_
                   *   - **items** (`GetFieldsUsage200ResponseItemsInner[]`, optional) __
                   *     *   - **field** (`{ [key: string]: any; }`, required) _Basic information about the field._
                   *     *   - **usage** (`{ [key: string]: any; }`, required) _Usage Information about the field._
                   *
                   * @see {@link https://developer.quickbase.com/operation/getFieldUsage} Official Quickbase API documentation
                   */
                  getFieldUsage: (params: { tableId: string; fieldId: number }) => Promise<GetFieldUsage200Response>;
                  /**
                   * Run a formula
                   *
                   * @param {Object} params _Object containing the parameters for_ runFormula
                   *   @param {{ formula?: string; rid?: number; from?: string }} params.body _Optional parameter with properties_
                   *
                   * @returns {Promise<RunFormula200Response>} _Promise resolving to the runFormula response with properties_
                   *   - **result** (`string`, optional) _The formula execution result._
                   *
                   * @see {@link https://developer.quickbase.com/operation/runFormula} Official Quickbase API documentation
                   */
                  runFormula: (params: { body?: { formula?: string; rid?: number; from?: string } }) => Promise<RunFormula200Response>;
                  /**
                   * Insert/Update record(s)
                   *
                   * @param {Object} params _Object containing the parameters for_ upsert
                   *   @param {UpsertRequest} params.body _Optional parameter with properties_
                   *     - **data** (`Record[]`, optional) _Type: Record[]_
                   *     - **to** (`string`, optional) _Type: string_
                   *     - **fieldsToReturn** (`number[]`, optional) _Type: number[]_
                   *
                   * @returns {Promise<Upsert200Response | Upsert207Response>} _Promise resolving to the upsert response with properties_
                   *   - **metadata** (`{ [key: string]: any; }`, optional) _Information about created records, updated records, referenced but unchanged records, and records having any errors while being processed._
                   *   - **data** (`string[]`, optional) _The data that is expected to be returned._
                   *   - **metadata** (`{ [key: string]: any; }`, optional) _Information about created records, updated records, referenced but unchanged records, and records having any errors while being processed._
                   *   - **data** (`string[]`, optional) _The data that is expected to be returned._
                   *
                   * @see {@link https://developer.quickbase.com/operation/upsert} Official Quickbase API documentation
                   */
                  upsert: (params: { body?: UpsertRequest }) => Promise<Upsert200Response | Upsert207Response>;
                  /**
                   * Delete record(s)
                   *
                   * @param {Object} params _Object containing the parameters for_ deleteRecords
                   *   @param {DeleteRecordsRequest} params.body _Optional parameter with properties_
                   *     - **from** (`string`, required) _Type: string_
                   *     - **where** (`string`, optional) _Type: string_
                   *
                   * @returns {Promise<DeleteRecords200Response>} _Promise resolving to the deleteRecords response with properties_
                   *   - **numberDeleted** (`number`, optional) _The number of records deleted._
                   *
                   * @see {@link https://developer.quickbase.com/operation/deleteRecords} Official Quickbase API documentation
                   */
                  deleteRecords: (params: { body?: DeleteRecordsRequest }) => Promise<DeleteRecords200Response>;
                  /**
                   * Query for data
                   *
                   * @param {Object} params _Object containing the parameters for_ runQuery
                   *   @param {RunQueryRequest} params.body _Optional parameter with properties_
                   *     - **from** (`string`, required) _The table identifier._
                   *     - **select** (`number[]`, optional) _An array of field ids..._
                   *     - **where** (`string`, optional) _The filter, using the Quickbase query language..._
                   *     - **sortBy** (`RunQueryRequestSortByInner[]`, optional) _An array of field IDs and sort directions..._
                   *     - **groupBy** (`RunQueryRequestGroupByInner[]`, optional) _An array that contains the fields to group the records by._
                   *     - **options** (`RunQueryRequestOptions`, optional) _Type: RunQueryRequestOptions_
                   *
                   * @returns {Promise<RunQuery200Response>} _Promise resolving to the runQuery response with properties_
                   *   - **fields** (`{ [key: string]: any; }[]`, optional) _An array of objects that contains limited meta-data of each field displayed in the report. This assists in building logic that depends on field types and IDs._
                   *   - **data** (`string[]`, optional) _An array of objects that either represents the record data or summarized values, depending on the report type._
                   *   - **metadata** (`{ [key: string]: any; }`, optional) _Additional information about the results that may be helpful. Pagination may be needed if either you specify a smaller number of results to skip than is available, or if the API automatically returns fewer results. numRecords can be compared to totalRecords to determine if further pagination is needed._
                   *
                   * @see {@link https://developer.quickbase.com/operation/runQuery} Official Quickbase API documentation
                   */
                  runQuery: (params: { body?: RunQueryRequest }) => Promise<RunQuery200Response>;
                  /**
                   * Get a temporary token for a dbid
                   *
                   * @param {Object} params _Object containing the parameters for_ getTempTokenDBID
                   *   @param {string} params.dbid _Required parameter with properties_
                   *   @param {string} params.qBAppToken _Optional parameter with properties_
                   *
                   * @returns {Promise<GetTempTokenDBID200Response>} _Promise resolving to the getTempTokenDBID response with properties_
                   *   - **temporaryAuthorization** (`string`, optional) _Temporary authorization token._
                   *
                   * @see {@link https://developer.quickbase.com/operation/getTempTokenDBID} Official Quickbase API documentation
                   */
                  getTempTokenDBID: (params: { dbid: string; qBAppToken?: string }) => Promise<GetTempTokenDBID200Response>;
                  /**
                   * Exchange an SSO token
                   *
                   * @param {Object} params _Object containing the parameters for_ exchangeSsoToken
                   *   @param {{ grant_type?: string; requested_token_type?: string; subject_token?: string; subject_token_type?: string }} params.body _Optional parameter with properties_
                   *
                   * @returns {Promise<ExchangeSsoToken200Response>} _Promise resolving to the exchangeSsoToken response with properties_
                   *   - **access_token** (`string`, optional) _The security token issued by the authorization server in response to the token exchange request. The identifier `access_token` is used for historical reasons and the issued token need not be an OAuth access token._
                   *   - **issued_token_type** (`ExchangeSsoToken200ResponseIssuedTokenTypeEnum`, optional) _An identifier for the representation of the issued security token._
                   *   - **token_type** (`"N_A"`, optional) _Will always return `N_A`_
                   *
                   * @see {@link https://developer.quickbase.com/operation/exchangeSsoToken} Official Quickbase API documentation
                   */
                  exchangeSsoToken: (params: { body?: { grant_type?: string; requested_token_type?: string; subject_token?: string; subject_token_type?: string } }) => Promise<ExchangeSsoToken200Response>;
                  /**
                   * Clone a user token
                   *
                   * @param {Object} params _Object containing the parameters for_ cloneUserToken
                   *   @param {{ name?: string; description?: string }} params.body _Optional parameter with properties_
                   *
                   * @returns {Promise<CloneUserToken200Response>} _Promise resolving to the cloneUserToken response with properties_
                   *   - **active** (`boolean`, optional) _Whether the user token is active._
                   *   - **apps** (`{ [key: string]: any; }[]`, optional) _The list of apps this user token is assigned to._
                   *   - **lastUsed** (`string`, optional) _The last date this user token was used, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **description** (`string`, optional) _User Token description._
                   *   - **id** (`number`, optional) _User Token id._
                   *   - **name** (`string`, optional) _User Token name._
                   *   - **token** (`string`, optional) _User Token value._
                   *
                   * @see {@link https://developer.quickbase.com/operation/cloneUserToken} Official Quickbase API documentation
                   */
                  cloneUserToken: (params: { body?: { name?: string; description?: string } }) => Promise<CloneUserToken200Response>;
                  /**
                   * Transfer a user token
                   *
                   * @param {Object} params _Object containing the parameters for_ transferUserToken
                   *   @param {{ id?: number; from?: string; to?: string }} params.body _Optional parameter with properties_
                   *
                   * @returns {Promise<TransferUserToken200Response>} _Promise resolving to the transferUserToken response with properties_
                   *   - **active** (`boolean`, optional) _Whether the user token is active._
                   *   - **apps** (`{ [key: string]: any; }[]`, optional) _The list of apps this user token is assigned to._
                   *   - **lastUsed** (`string`, optional) _The last date this user token was used, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone)._
                   *   - **description** (`string`, optional) _User Token description._
                   *   - **id** (`number`, optional) _User Token id._
                   *   - **name** (`string`, optional) _User Token name._
                   *
                   * @see {@link https://developer.quickbase.com/operation/transferUserToken} Official Quickbase API documentation
                   */
                  transferUserToken: (params: { body?: { id?: number; from?: string; to?: string } }) => Promise<TransferUserToken200Response>;
                  /**
                   * Deactivate a user token
                   *
                   * @param {Object} params _Object containing the parameters for_ deactivateUserToken
                   *   No parameters
                   *
                   * @returns {Promise<DeactivateUserToken200Response>} _Promise resolving to the deactivateUserToken response with properties_
                   *   - **id** (`number`, optional) _The user token id._
                   *
                   * @see {@link https://developer.quickbase.com/operation/deactivateUserToken} Official Quickbase API documentation
                   */
                  deactivateUserToken: (params: {  }) => Promise<DeactivateUserToken200Response>;
                  /**
                   * Delete a user token
                   *
                   * @param {Object} params _Object containing the parameters for_ deleteUserToken
                   *   No parameters
                   *
                   * @returns {Promise<DeleteUserToken200Response>} _Promise resolving to the deleteUserToken response with properties_
                   *   - **id** (`number`, optional) _The user token id._
                   *
                   * @see {@link https://developer.quickbase.com/operation/deleteUserToken} Official Quickbase API documentation
                   */
                  deleteUserToken: (params: {  }) => Promise<DeleteUserToken200Response>;
                  /**
                   * Download file
                   *
                   * @param {Object} params _Object containing the parameters for_ downloadFile
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {number} params.recordId _Required parameter with properties_
                   *   @param {number} params.fieldId _Required parameter with properties_
                   *   @param {number} params.versionNumber _Required parameter with properties_
                   *
                   * @returns {Promise<DownloadFile200Response>} _Promise resolving to the downloadFile response with properties_
                   *   - **data** (`Blob`, optional) _Type: Blob_
                   *
                   * @see {@link https://developer.quickbase.com/operation/downloadFile} Official Quickbase API documentation
                   */
                  downloadFile: (params: { tableId: string; recordId: number; fieldId: number; versionNumber: number }) => Promise<DownloadFile200Response>;
                  /**
                   * Delete file
                   *
                   * @param {Object} params _Object containing the parameters for_ deleteFile
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {number} params.recordId _Required parameter with properties_
                   *   @param {number} params.fieldId _Required parameter with properties_
                   *   @param {number} params.versionNumber _Required parameter with properties_
                   *
                   * @returns {Promise<DeleteFile200Response>} _Promise resolving to the deleteFile response with properties_
                   *   - **versionNumber** (`number`, optional) _The number of deleted version._
                   *   - **fileName** (`string`, optional) _The name of file associated with deleted version._
                   *   - **uploaded** (`string`, optional) _The timestamp when the version was originally uploaded._
                   *   - **creator** (`{ [key: string]: any; }`, optional) _The user that uploaded version._
                   *
                   * @see {@link https://developer.quickbase.com/operation/deleteFile} Official Quickbase API documentation
                   */
                  deleteFile: (params: { tableId: string; recordId: number; fieldId: number; versionNumber: number }) => Promise<DeleteFile200Response>;
                  /**
                   * Get users
                   *
                   * @param {Object} params _Object containing the parameters for_ getUsers
                   *   @param {number} params.accountId _Optional parameter with properties_
                   *   @param {GetUsersRequest} params.body _Optional parameter with properties_
                   *     - **userIds** (`string[]`, required) _Type: string[]_
                   *
                   * @returns {Promise<GetUsers200Response>} _Promise resolving to the getUsers response with properties_
                   *   - **users** (`{ [key: string]: any; }[]`, required) _A list of users found in an account with the given criterias_
                   *   - **metadata** (`{ [key: string]: any; }`, required) _Additional request information_
                   *
                   * @see {@link https://developer.quickbase.com/operation/getUsers} Official Quickbase API documentation
                   */
                  getUsers: (params: { accountId?: number; body?: GetUsersRequest }) => Promise<GetUsers200Response>;
                  /**
                   * Deny users
                   *
                   * @param {Object} params _Object containing the parameters for_ denyUsers
                   *   @param {number} params.accountId _Optional parameter with properties_
                   *   @param {DenyUsersRequest} params.body _Optional parameter with properties_
                   *     - **userIds** (`string[]`, required) _Type: string[]_
                   *
                   * @returns {Promise<DenyUsers200Response>} _Promise resolving to the denyUsers response with properties_
                   *   - **failure** (`string[]`, required) _A list of users that couldn't be denied. This also includes the ID's of users that are not valid._
                   *   - **success** (`string[]`, required) _A list of users that have successfully been denied._
                   *
                   * @see {@link https://developer.quickbase.com/operation/denyUsers} Official Quickbase API documentation
                   */
                  denyUsers: (params: { accountId?: number; body?: DenyUsersRequest }) => Promise<DenyUsers200Response>;
                  /**
                   * Deny and remove users from groups
                   *
                   * @param {Object} params _Object containing the parameters for_ denyUsersAndGroups
                   *   @param {number} params.accountId _Optional parameter with properties_
                   *   @param {boolean} params.shouldDeleteFromGroups _Required parameter with properties_
                   *   @param {DenyUsersAndGroupsRequest} params.body _Optional parameter with properties_
                   *     - **userIds** (`string[]`, required) _Type: string[]_
                   *
                   * @returns {Promise<DenyUsersAndGroups200Response>} _Promise resolving to the denyUsersAndGroups response with properties_
                   *   - **failure** (`string[]`, required) _A list of users that couldn't be denied. This also includes the ID's of users that are not valid._
                   *   - **success** (`string[]`, required) _A list of users that have successfully been denied._
                   *
                   * @see {@link https://developer.quickbase.com/operation/denyUsersAndGroups} Official Quickbase API documentation
                   */
                  denyUsersAndGroups: (params: { accountId?: number; shouldDeleteFromGroups: boolean; body?: DenyUsersAndGroupsRequest }) => Promise<DenyUsersAndGroups200Response>;
                  /**
                   * Undeny users
                   *
                   * @param {Object} params _Object containing the parameters for_ undenyUsers
                   *   @param {number} params.accountId _Optional parameter with properties_
                   *   @param {UndenyUsersRequest} params.body _Optional parameter with properties_
                   *     - **userIds** (`string[]`, required) _Type: string[]_
                   *
                   * @returns {Promise<UndenyUsers200Response>} _Promise resolving to the undenyUsers response with properties_
                   *   - **failure** (`string[]`, required) _A list of users that couldn't be undenied. This also includes the ID's of users that are not valid._
                   *   - **success** (`string[]`, required) _A list of users that have successfully been undenied._
                   *
                   * @see {@link https://developer.quickbase.com/operation/undenyUsers} Official Quickbase API documentation
                   */
                  undenyUsers: (params: { accountId?: number; body?: UndenyUsersRequest }) => Promise<UndenyUsers200Response>;
                  /**
                   * Add members
                   *
                   * @param {Object} params _Object containing the parameters for_ addMembersToGroup
                   *   @param {number} params.gid _Required parameter with properties_
                   *   @param {AddMembersToGroupRequest} params.body _Optional parameter with properties_
                   *     - **userIds** (`string[]`, required) _Type: string[]_
                   *
                   * @returns {Promise<AddMembersToGroup200Response>} _Promise resolving to the addMembersToGroup response with properties_
                   *   - **failure** (`string[]`, required) _A list of users that couldn’t be added to the group. This includes a list of IDs that represent invalid users and users who have already been added to the group._
                   *   - **success** (`string[]`, required) _A list of users that have been added to the group successfully._
                   *
                   * @see {@link https://developer.quickbase.com/operation/addMembersToGroup} Official Quickbase API documentation
                   */
                  addMembersToGroup: (params: { gid: number; body?: AddMembersToGroupRequest }) => Promise<AddMembersToGroup200Response>;
                  /**
                   * Remove members
                   *
                   * @param {Object} params _Object containing the parameters for_ removeMembersFromGroup
                   *   @param {number} params.gid _Required parameter with properties_
                   *   @param {RemoveMembersFromGroupRequest} params.body _Optional parameter with properties_
                   *     - **userIds** (`string[]`, required) _Type: string[]_
                   *
                   * @returns {Promise<RemoveMembersFromGroup200Response>} _Promise resolving to the removeMembersFromGroup response with properties_
                   *   - **failure** (`string[]`, required) _A list of users that couldn’t be removed from the group. This includes a list of IDs that represent invalid users._
                   *   - **success** (`string[]`, required) _A list of users that have been removed from the group successfully._
                   *
                   * @see {@link https://developer.quickbase.com/operation/removeMembersFromGroup} Official Quickbase API documentation
                   */
                  removeMembersFromGroup: (params: { gid: number; body?: RemoveMembersFromGroupRequest }) => Promise<RemoveMembersFromGroup200Response>;
                  /**
                   * Add managers
                   *
                   * @param {Object} params _Object containing the parameters for_ addManagersToGroup
                   *   @param {number} params.gid _Required parameter with properties_
                   *   @param {AddManagersToGroupRequest} params.body _Optional parameter with properties_
                   *     - **userIds** (`string[]`, required) _Type: string[]_
                   *
                   * @returns {Promise<AddManagersToGroup200Response>} _Promise resolving to the addManagersToGroup response with properties_
                   *   - **failure** (`string[]`, required) _A list of users that couldn’t be added to the group. This includes a list of IDs that represent invalid users and users who have already been added to the group._
                   *   - **success** (`string[]`, required) _A list of users that have been added to the group successfully._
                   *
                   * @see {@link https://developer.quickbase.com/operation/addManagersToGroup} Official Quickbase API documentation
                   */
                  addManagersToGroup: (params: { gid: number; body?: AddManagersToGroupRequest }) => Promise<AddManagersToGroup200Response>;
                  /**
                   * Remove managers
                   *
                   * @param {Object} params _Object containing the parameters for_ removeManagersFromGroup
                   *   @param {number} params.gid _Required parameter with properties_
                   *   @param {RemoveManagersFromGroupRequest} params.body _Optional parameter with properties_
                   *     - **userIds** (`string[]`, required) _Type: string[]_
                   *
                   * @returns {Promise<RemoveManagersFromGroup200Response>} _Promise resolving to the removeManagersFromGroup response with properties_
                   *   - **failure** (`string[]`, required) _A list of users that couldn’t be removed from the group. This includes a list of IDs that represent invalid users._
                   *   - **success** (`string[]`, required) _A list of users that have been removed from the group successfully._
                   *
                   * @see {@link https://developer.quickbase.com/operation/removeManagersFromGroup} Official Quickbase API documentation
                   */
                  removeManagersFromGroup: (params: { gid: number; body?: RemoveManagersFromGroupRequest }) => Promise<RemoveManagersFromGroup200Response>;
                  /**
                   * Add child groups
                   *
                   * @param {Object} params _Object containing the parameters for_ addSubgroupsToGroup
                   *   @param {number} params.gid _Required parameter with properties_
                   *   @param {AddSubgroupsToGroupRequest} params.body _Optional parameter with properties_
                   *     - **userIds** (`string[]`, required) _Type: string[]_
                   *
                   * @returns {Promise<AddSubgroupsToGroup200Response>} _Promise resolving to the addSubgroupsToGroup response with properties_
                   *   - **failure** (`string[]`, required) _A list of child groups that couldn’t be added to the group. This includes a list of IDs that represent invalid groups and groups that have already been added to the group._
                   *   - **success** (`string[]`, required) _A list of child groups that have been added to the group successfully._
                   *
                   * @see {@link https://developer.quickbase.com/operation/addSubgroupsToGroup} Official Quickbase API documentation
                   */
                  addSubgroupsToGroup: (params: { gid: number; body?: AddSubgroupsToGroupRequest }) => Promise<AddSubgroupsToGroup200Response>;
                  /**
                   * Remove child groups
                   *
                   * @param {Object} params _Object containing the parameters for_ removeSubgroupsFromGroup
                   *   @param {number} params.gid _Required parameter with properties_
                   *   @param {RemoveSubgroupsFromGroupRequest} params.body _Optional parameter with properties_
                   *     - **userIds** (`string[]`, required) _Type: string[]_
                   *
                   * @returns {Promise<RemoveSubgroupsFromGroup200Response>} _Promise resolving to the removeSubgroupsFromGroup response with properties_
                   *   - **failure** (`string[]`, required) _A list of child groups that couldn’t be removed from the group. This includes a list of IDs that represent invalid groups._
                   *   - **success** (`string[]`, required) _A list of child groups that have been removed from the group successfully._
                   *
                   * @see {@link https://developer.quickbase.com/operation/removeSubgroupsFromGroup} Official Quickbase API documentation
                   */
                  removeSubgroupsFromGroup: (params: { gid: number; body?: RemoveSubgroupsFromGroupRequest }) => Promise<RemoveSubgroupsFromGroup200Response>;
                  /**
                   * Get audit logs
                   *
                   * @param {Object} params _Object containing the parameters for_ audit
                   *   @param {{ nextToken?: string; numRows?: number; queryId?: string; date?: string; topics?: string[] }} params.body _Optional parameter with properties_
                   *
                   * @returns {Promise<Audit200Response>} _Promise resolving to the audit response with properties_
                   *   - **queryId** (`string`, required) _Query id of the requested audit log._
                   *   - **events** (`{ [key: string]: any; }[]`, optional) _All events of the audit log._
                   *   - **nextToken** (`string`, optional) _Token to fetch the next 1000 logs._
                   *
                   * @see {@link https://developer.quickbase.com/operation/audit} Official Quickbase API documentation
                   */
                  audit: (params: { body?: { nextToken?: string; numRows?: number; queryId?: string; date?: string; topics?: string[] } }) => Promise<Audit200Response>;
                  /**
                   * Get read summaries
                   *
                   * @param {Object} params _Object containing the parameters for_ platformAnalyticReads
                   *   @param {string} params.day _Optional parameter with properties_
                   *
                   * @returns {Promise<PlatformAnalyticReads200Response>} _Promise resolving to the platformAnalyticReads response with properties_
                   *   - **date** (`Date`, required) _The date of the requested summary._
                   *   - **reads** (`{ [key: string]: any; }`, required) _Total reads for the specified date._
                   *
                   * @see {@link https://developer.quickbase.com/operation/platformAnalyticReads} Official Quickbase API documentation
                   */
                  platformAnalyticReads: (params: { day?: string }) => Promise<PlatformAnalyticReads200Response>;
                  /**
                   * Get event summaries
                   *
                   * @param {Object} params _Object containing the parameters for_ platformAnalyticEventSummaries
                   *   @param {number} params.accountId _Optional parameter with properties_
                   *   @param {{ start?: string; end?: string; groupBy?: string; nextToken?: string; where?: { id?: string; type?: string }[] }} params.body _Optional parameter with properties_
                   *
                   * @returns {Promise<PlatformAnalyticEventSummaries200Response>} _Promise resolving to the platformAnalyticEventSummaries response with properties_
                   *   - **accountId** (`string`, required) _The ID of the account the events are associated with._
                   *   - **start** (`Date`, required) _The start date and time of the requested summaries in ISO 8601 time format._
                   *   - **end** (`Date`, required) _The end date and time of the requested summaries in ISO 8601 time format._
                   *   - **groupBy** (`PlatformAnalyticEventSummaries200ResponseGroupByEnum`, required) _How the events should be grouped._
                   *   - **where** (`PlatformAnalyticEventSummaries200ResponseWhereInner[]`, required) __
                   *     *   - **id** (`string`, required) _Id of the item to filter by._
                   *     *   - **type** (`PlatformAnalyticEventSummaries200ResponseWhereInnerTypeEnum`, required) _The type of item to filter by._
                   *   - **results** (`PlatformAnalyticEventSummaries200ResponseResultsInner[]`, required) __
                   *     *   - **eventTypes** (`PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner[]`, required) __
                   *     *     *   - **billingCategory** (`PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInnerBillingCategoryEnum`, optional) _Billing category of the event type._
                   *     *     *   - **count** (`number`, optional) _Count of events associated with that event type and Application/User._
                   *     *     *   - **eventType** (`string`, optional) _Event type_
                   *     *   - **id** (`string`, required) _Id of the Application/User._
                   *     *   - **name** (`string`, required) _Name of the Application/User._
                   *     *   - **totals** (`PlatformAnalyticEventSummaries200ResponseResultsInnerTotals`, required) _Type: PlatformAnalyticEventSummaries200ResponseResultsInnerTotals_
                   *   - **metadata** (`PlatformAnalyticEventSummaries200ResponseMetadata`, optional) _Type: PlatformAnalyticEventSummaries200ResponseMetadata_
                   *   - **totals** (`PlatformAnalyticEventSummaries200ResponseTotals`, optional) _Type: PlatformAnalyticEventSummaries200ResponseTotals_
                   *
                   * @see {@link https://developer.quickbase.com/operation/platformAnalyticEventSummaries} Official Quickbase API documentation
                   */
                  platformAnalyticEventSummaries: (params: { accountId?: number; body?: { start?: string; end?: string; groupBy?: string; nextToken?: string; where?: { id?: string; type?: string }[] } }) => Promise<PlatformAnalyticEventSummaries200Response>;
                  /**
                   * Export a solution
                   *
                   * @param {Object} params _Object containing the parameters for_ exportSolution
                   *   @param {string} params.solutionId _Required parameter with properties_
                   *   @param {string} params.qBLVersion _Optional parameter with properties_
                   *
                   * @returns {Promise<ExportSolution200Response>} _Promise resolving to the exportSolution response with properties_
                   *   - **content** (`string`, optional) _Type: string_
                   *
                   * @see {@link https://developer.quickbase.com/operation/exportSolution} Official Quickbase API documentation
                   */
                  exportSolution: (params: { solutionId: string; qBLVersion?: string }) => Promise<ExportSolution200Response>;
                  /**
                   * Update a solution
                   *
                   * @param {Object} params _Object containing the parameters for_ updateSolution
                   *   @param {string} params.solutionId _Required parameter with properties_
                   *   @param {any} params.body _Optional parameter with properties_
                   *   @param {boolean} params.xQBLErrorsAsSuccess _Optional parameter with properties_
                   *
                   * @returns {Promise<UpdateSolution200Response>} _Promise resolving to the updateSolution response_
                   *
                   * @see {@link https://developer.quickbase.com/operation/updateSolution} Official Quickbase API documentation
                   */
                  updateSolution: (params: { solutionId: string; body?: any; xQBLErrorsAsSuccess?: boolean }) => Promise<UpdateSolution200Response>;
                  /**
                   * Create a solution
                   *
                   * @param {Object} params _Object containing the parameters for_ createSolution
                   *   @param {any} params.body _Optional parameter with properties_
                   *   @param {boolean} params.xQBLErrorsAsSuccess _Optional parameter with properties_
                   *
                   * @returns {Promise<CreateSolution200Response>} _Promise resolving to the createSolution response_
                   *
                   * @see {@link https://developer.quickbase.com/operation/createSolution} Official Quickbase API documentation
                   */
                  createSolution: (params: { body?: any; xQBLErrorsAsSuccess?: boolean }) => Promise<CreateSolution200Response>;
                  /**
                   * Export solution to record
                   *
                   * @param {Object} params _Object containing the parameters for_ exportSolutionToRecord
                   *   @param {string} params.solutionId _Required parameter with properties_
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {number} params.fieldId _Required parameter with properties_
                   *   @param {boolean} params.xQBLErrorsAsSuccess _Optional parameter with properties_
                   *   @param {string} params.qBLVersion _Optional parameter with properties_
                   *
                   * @returns {Promise<ExportSolutionToRecord200Response>} _Promise resolving to the exportSolutionToRecord response_
                   *
                   * @see {@link https://developer.quickbase.com/operation/exportSolutionToRecord} Official Quickbase API documentation
                   */
                  exportSolutionToRecord: (params: { solutionId: string; tableId: string; fieldId: number; xQBLErrorsAsSuccess?: boolean; qBLVersion?: string }) => Promise<ExportSolutionToRecord200Response>;
                  /**
                   * Create solution from record
                   *
                   * @param {Object} params _Object containing the parameters for_ createSolutionFromRecord
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {number} params.fieldId _Required parameter with properties_
                   *   @param {number} params.recordId _Required parameter with properties_
                   *   @param {boolean} params.xQBLErrorsAsSuccess _Optional parameter with properties_
                   *
                   * @returns {Promise<CreateSolutionFromRecord200Response>} _Promise resolving to the createSolutionFromRecord response_
                   *
                   * @see {@link https://developer.quickbase.com/operation/createSolutionFromRecord} Official Quickbase API documentation
                   */
                  createSolutionFromRecord: (params: { tableId: string; fieldId: number; recordId: number; xQBLErrorsAsSuccess?: boolean }) => Promise<CreateSolutionFromRecord200Response>;
                  /**
                   * Update solution from record
                   *
                   * @param {Object} params _Object containing the parameters for_ updateSolutionToRecord
                   *   @param {string} params.solutionId _Required parameter with properties_
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {number} params.fieldId _Required parameter with properties_
                   *   @param {number} params.recordId _Required parameter with properties_
                   *   @param {boolean} params.xQBLErrorsAsSuccess _Optional parameter with properties_
                   *
                   * @returns {Promise<UpdateSolutionToRecord200Response>} _Promise resolving to the updateSolutionToRecord response_
                   *
                   * @see {@link https://developer.quickbase.com/operation/updateSolutionToRecord} Official Quickbase API documentation
                   */
                  updateSolutionToRecord: (params: { solutionId: string; tableId: string; fieldId: number; recordId: number; xQBLErrorsAsSuccess?: boolean }) => Promise<UpdateSolutionToRecord200Response>;
                  /**
                   * List solution changes
                   *
                   * @param {Object} params _Object containing the parameters for_ changesetSolution
                   *   @param {string} params.solutionId _Required parameter with properties_
                   *   @param {any} params.body _Optional parameter with properties_
                   *   @param {boolean} params.xQBLErrorsAsSuccess _Optional parameter with properties_
                   *
                   * @returns {Promise<ChangesetSolution200Response>} _Promise resolving to the changesetSolution response_
                   *
                   * @see {@link https://developer.quickbase.com/operation/changesetSolution} Official Quickbase API documentation
                   */
                  changesetSolution: (params: { solutionId: string; body?: any; xQBLErrorsAsSuccess?: boolean }) => Promise<ChangesetSolution200Response>;
                  /**
                   * List solution changes from record
                   *
                   * @param {Object} params _Object containing the parameters for_ changesetSolutionFromRecord
                   *   @param {string} params.solutionId _Required parameter with properties_
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {number} params.fieldId _Required parameter with properties_
                   *   @param {number} params.recordId _Required parameter with properties_
                   *   @param {boolean} params.xQBLErrorsAsSuccess _Optional parameter with properties_
                   *
                   * @returns {Promise<ChangesetSolutionFromRecord200Response>} _Promise resolving to the changesetSolutionFromRecord response_
                   *
                   * @see {@link https://developer.quickbase.com/operation/changesetSolutionFromRecord} Official Quickbase API documentation
                   */
                  changesetSolutionFromRecord: (params: { solutionId: string; tableId: string; fieldId: number; recordId: number; xQBLErrorsAsSuccess?: boolean }) => Promise<ChangesetSolutionFromRecord200Response>;
                  /**
                   * Generate a document
                   *
                   * @param {Object} params _Object containing the parameters for_ generateDocument
                   *   @param {number} params.templateId _Required parameter with properties_
                   *   @param {string} params.tableId _Required parameter with properties_
                   *   @param {number} params.recordId _Optional parameter with properties_
                   *   @param {string} params.filename _Required parameter with properties_
                   *   @param {string} params.accept _Optional parameter with properties_
                   *   @param {string} params.format _Optional parameter with properties_
                   *   @param {string} params.margin _Optional parameter with properties_
                   *   @param {string} params.unit _Optional parameter with properties_
                   *   @param {string} params.pageSize _Optional parameter with properties_
                   *   @param {string} params.orientation _Optional parameter with properties_
                   *   @param {string} params.realm _Optional parameter with properties_
                   *
                   * @returns {Promise<GenerateDocument200Response>} _Promise resolving to the generateDocument response with properties_
                   *   - **fileName** (`string`, optional) _The file name._
                   *   - **data** (`string`, optional) _Base64 encoded file content._
                   *   - **contentType** (`string`, optional) _The document content type._
                   *
                   * @see {@link https://developer.quickbase.com/operation/generateDocument} Official Quickbase API documentation
                   */
                  generateDocument: (params: { templateId: number; tableId: string; recordId?: number; filename: string; accept?: string; format?: string; margin?: string; unit?: string; pageSize?: string; orientation?: string; realm?: string }) => Promise<GenerateDocument200Response>;
                }
            - name: >-
                missing-types-report.json
              type: >-
                file
        - name: >-
            index.ts
          type: >-
            file
        - name: >-
            invokeMethod.ts
          type: >-
            file
          contents: >
            //
            src/invokeMethod.ts


            import
            {
            AuthorizationStrategy,
            extractDbid
            }
            from
            "./authorizationStrategy";

            import
            {
            RateLimiter
            }
            from
            "./rateLimiter";

            import
            {
            RateLimitError
            }
            from
            "./RateLimitError";

            import
            {
            ResponseError
            }
            from
            "./generated/runtime";

            import
            {
            QuickbaseClient
            }
            from
            "./quickbaseClient";


            export
            type
            ApiMethod<K
            extends
            keyof
            QuickbaseClient>
            =
            (
              requestParameters: Parameters<QuickbaseClient[K]>[0],
              initOverrides?: RequestInit
            )
            =>
            Promise<ReturnType<QuickbaseClient[K]>>;


            export
            interface
            MethodInfo<K
            extends
            keyof
            QuickbaseClient>
            {
              api: any;
              method: ApiMethod<K>;
              paramMap: string[];
              httpMethod: string;
            }


            export
            async
            function
            invokeMethod<K
            extends
            keyof
            QuickbaseClient>(
              methodName: K,
              params: Parameters<QuickbaseClient[K]>[0] & {
                dbid?: string;
                tableId?: string;
                appId?: string;
              },
              methodMap: { [P in keyof QuickbaseClient]: MethodInfo<P> },
              baseHeaders: Record<string, string>,
              authStrategy: AuthorizationStrategy,
              rateLimiter: RateLimiter,
              transformDates: (obj: any, convertStringsToDates: boolean) => any,
              debug: boolean | undefined,
              convertDates: boolean
            ):
            Promise<ReturnType<QuickbaseClient[K]>>
            {
              console.log("[invokeMethod] Starting for method:", methodName);

              const methodInfo = methodMap[methodName];
              if (!methodInfo) throw new Error(`Method ${methodName} not found`);

              const hasBody = "body" in params && params.body !== undefined;
              const body = hasBody ? params.body : undefined;
              const restParams: any = hasBody
                ? Object.fromEntries(
                    Object.entries(params).filter(([key]) => key !== "body")
                  )
                : { ...params };
              const requestParameters: any = {
                ...restParams,
                ...(hasBody ? { generated: body } : {}),
              };

              const requestOptions: RequestInit = {
                credentials: methodName === "getTempTokenDBID" ? "include" : "omit",
                method: methodInfo.httpMethod,
              };

              let dbid: string | undefined = extractDbid(params);
              console.log("[invokeMethod] Extracted dbid:", dbid);

              let token = dbid
                ? await authStrategy.getToken(dbid)
                : await authStrategy.getToken("");
              console.log("[invokeMethod] Initial token:", token);

              if (token) {
                authStrategy.applyHeaders(baseHeaders, token);
                requestOptions.headers = { ...baseHeaders };
                console.log(
                  "[invokeMethod] Token found, headers set:",
                  requestOptions.headers
                );
                if (methodName === "getTempTokenDBID") {
                  console.log("[invokeMethod] Using cached token:", token);
                  return { temporaryAuthorization: token } as ReturnType<
                    QuickbaseClient[K]
                  >;
                }
              }

              if (debug) {
                console.log(`[${methodName}] requestParameters:`, requestParameters);
                console.log(`[${methodName}] requestOptions:`, requestOptions);
              }

              async function processResponse(
                rawResponse: any
              ): Promise<ReturnType<QuickbaseClient[K]>> {
                if (debug) console.log(`[${methodName}] rawResponse:`, rawResponse);
                if (rawResponse instanceof Response) {
                  const contentType = rawResponse.headers
                    .get("Content-Type")
                    ?.toLowerCase();
                  if (debug) console.log(`[${methodName}] contentType:`, contentType);
                  if (contentType?.includes("application/json")) {
                    const jsonResponse = await rawResponse.json();
                    return transformDates(jsonResponse, convertDates) as ReturnType<
                      QuickbaseClient[K]
                    >;
                  }
                  return rawResponse as ReturnType<QuickbaseClient[K]>;
                }
                if (rawResponse && typeof rawResponse.value === "function") {
                  const response = await rawResponse.value();
                  if (debug)
                    console.log(`[${methodName}] Resolved JSONApiResponse:`, response);
                  return transformDates(response, convertDates) as ReturnType<
                    QuickbaseClient[K]
                  >;
                }
                return transformDates(rawResponse, convertDates) as ReturnType<
                  QuickbaseClient[K]
                >;
              }

              async function parseErrorResponse(
                response: Response
              ): Promise<{ message: string; status: number }> {
                let message = "Unknown error";
                let status = response.status || 500;
                try {
                  const contentType =
                    response.headers?.get("Content-Type")?.toLowerCase() ||
                    "application/json";
                  if (
                    contentType.includes("application/json") &&
                    typeof response.json === "function"
                  ) {
                    const errorBody = await response.json();
                    if (
                      errorBody &&
                      typeof errorBody === "object" &&
                      "message" in errorBody
                    ) {
                      message = errorBody.message;
                    } else {
                      message = "Invalid error response format";
                    }
                  } else if (typeof response.text === "function") {
                    message = (await response.text()) || message;
                  }
                } catch (e) {
                  if (debug) console.log(`[${methodName}] Error parsing response body:`, e);
                  message = "Failed to parse error response";
                }
                if (debug)
                  console.log(
                    "[invokeMethod] Parsed error - status:",
                    status,
                    "message:",
                    message
                  );
                return { message, status };
              }

              let attempt = 0;
              const maxAttempts = rateLimiter.maxRetries + 1;

              while (attempt < maxAttempts) {
                console.log("[invokeMethod] Attempt:", attempt + 1, "of", maxAttempts);
                try {
                  await rateLimiter.throttle();
                  console.log("[invokeMethod] About to call API for method:", methodName);
                  const response = await methodInfo.method(
                    requestParameters,
                    requestOptions
                  );
                  console.log("[invokeMethod] API call completed for method:", methodName);
                  return await processResponse(response);
                } catch (error: unknown) {
                  if (debug) console.log("[invokeMethod] Caught error:", error);

                  let status: number;
                  let message: string;
                  let response: Response | undefined;

                  if (error instanceof ResponseError && error.response) {
                    response = error.response;
                    ({ message, status } = await parseErrorResponse(response));
                  } else if (error instanceof Response) {
                    response = error;
                    ({ message, status } = await parseErrorResponse(response));
                  } else {
                    if (debug) console.log(`[${methodName}] Unexpected error:`, error);
                    // Attempt to handle as a fetch error with a response
                    if (error instanceof Error && "response" in error) {
                      response = (error as any).response;
                      if (response instanceof Response) {
                        ({ message, status } = await parseErrorResponse(response));
                      } else {
                        throw error; // Rethrow if no response
                      }
                    } else {
                      throw error; // Rethrow truly unexpected errors
                    }
                  }

                  if (debug)
                    console.log("[invokeMethod] Handling error with status:", status);

                  if (status === 429) {
                    if (!(error instanceof ResponseError)) {
                      throw new Error("Expected ResponseError for 429 handling");
                    }
                    const delay = await rateLimiter.handle429(error, attempt + 1);
                    if (debug) console.log(`[${methodName}] 429 delay: ${delay}ms`);
                    if (attempt + 1 === maxAttempts) {
                      throw new RateLimitError(
                        `API Error: ${message} (Status: ${status})`,
                        status,
                        response?.headers.get("Retry-After")
                          ? parseInt(response.headers.get("Retry-After")!, 10)
                          : undefined
                      );
                    }
                    await new Promise((resolve) => setTimeout(resolve, delay));
                    attempt++;
                    continue;
                  }

                  const newToken = await authStrategy.handleError(
                    status,
                    params,
                    attempt,
                    maxAttempts,
                    debug,
                    methodName
                  );
                  if (newToken) {
                    token = newToken;
                    authStrategy.applyHeaders(baseHeaders, token);
                    requestOptions.headers = { ...baseHeaders };
                    attempt++;
                    if (debug)
                      console.log(
                        `[${methodName}] Retrying with token: ${token.substring(0, 10)}...`
                      );
                    continue;
                  }

                  throw new Error(`API Error: ${message} (Status: ${status})`);
                }
              }
              throw new Error(`API Error: Exhausted retries after ${maxAttempts} attempts`);
            }
        - name: >-
            quickbaseClient.ts
          type: >-
            file
          contents: >
            //
            src/quickbaseClient.ts


            import
            {
            QuickbaseClient
            as
            IQuickbaseClient
            }
            from
            "./generated-unified/QuickbaseClient";

            import
            {
            Configuration,
            HTTPHeaders
            }
            from
            "./generated/runtime";

            import
            *
            as
            apis
            from
            "./generated/apis";

            import
            {
            TokenCache
            }
            from
            "./tokenCache";

            import
            {
              simplifyName,
              getParamNames,
              transformDates,
              extractHttpMethod,
            }
            from
            "./utils";
            //
            Updated
            import

            import
            {
            invokeMethod,
            MethodInfo
            }
            from
            "./invokeMethod";

            import
            {
              TempTokenStrategy,
              UserTokenStrategy,
              AuthorizationStrategy,
              SsoTokenStrategy,
            }
            from
            "./authorizationStrategy";

            import
            {
            ThrottleBucket
            }
            from
            "./ThrottleBucket";

            import
            {
            RateLimiter
            }
            from
            "./rateLimiter";


            export
            *
            from
            "./generated/models/index";


            export
            interface
            QuickbaseClient
            extends
            IQuickbaseClient
            {}


            export
            interface
            QuickbaseConfig
            {
              realm: string;
              userToken?: string;
              tempToken?: string;
              useTempTokens?: boolean;
              useSso?: boolean;
              samlToken?: string;
              debug?: boolean;
              fetchApi?: typeof fetch;
              convertDates?: boolean;
              tempTokenLifespan?: number;
              throttle?: { rate: number; burst: number };
              maxRetries?: number;
              retryDelay?: number;
              tokenCache?: TokenCache;
              baseUrl?: string;
            }


            type
            MethodMap
            =
            {
              [K in keyof QuickbaseClient]: MethodInfo<K>;
            };


            export
            function
            quickbase(config:
            QuickbaseConfig):
            QuickbaseClient
            {
              const {
                realm,
                userToken,
                tempToken,
                useTempTokens,
                useSso,
                samlToken,
                fetchApi,
                debug,
                convertDates = true,
                tempTokenLifespan = 290000,
                throttle = { rate: 10, burst: 10 },
                maxRetries = 3,
                retryDelay = 1000,
                tokenCache: providedTokenCache,
                baseUrl = "https://api.quickbase.com/v1",
              } = config;

              const tokenCache = providedTokenCache || new TokenCache(tempTokenLifespan);
              const throttleBucket = throttle
                ? new ThrottleBucket(throttle.rate, throttle.burst)
                : null;
              const rateLimiter = new RateLimiter(throttleBucket, maxRetries, retryDelay);

              const defaultFetch: typeof fetch | undefined =
                typeof globalThis.window !== "undefined"
                  ? globalThis.window.fetch.bind(globalThis.window)
                  : undefined;
              const effectiveFetch = fetchApi || defaultFetch;

              if (!effectiveFetch) {
                throw new Error("No fetch implementation available");
              }

              const authStrategy: AuthorizationStrategy = useSso
                ? new SsoTokenStrategy(samlToken || "", realm, effectiveFetch, debug)
                : useTempTokens
                ? new TempTokenStrategy(
                    tokenCache,
                    tempToken,
                    effectiveFetch,
                    realm,
                    baseUrl
                  )
                : new UserTokenStrategy(userToken || "");

              const baseHeaders: HTTPHeaders = {
                "QB-Realm-Hostname": `${realm}.quickbase.com`,
                "Content-Type": "application/json",
              };

              const configuration = new Configuration({
                basePath: baseUrl,
                headers: { ...baseHeaders },
                fetchApi: effectiveFetch,
                credentials: "omit",
              });

              const apiInstances = Object.fromEntries(
                Object.entries(apis)
                  .filter(([name]) => name.endsWith("Api"))
                  .map(([name, ApiClass]) => [
                    name.replace("Api", "").toLowerCase(),
                    new ApiClass(configuration),
                  ])
              );

              function buildMethodMap(): MethodMap {
                const methodMap: Partial<MethodMap> = {};
                const isValidMethod = (name: string) =>
                  !name.startsWith("_") &&
                  name !== "constructor" &&
                  !["Middleware", "Pre", "Post", "Raw"].some((s) => name.includes(s));

                for (const [apiName, api] of Object.entries(apiInstances)) {
                  Object.getOwnPropertyNames(Object.getPrototypeOf(api))
                    .filter(
                      (name) =>
                        isValidMethod(name) &&
                        typeof api[name as keyof typeof api] === "function"
                    )
                    .forEach((rawMethodName) => {
                      const simplifiedName = simplifyName(
                        rawMethodName
                      ) as keyof QuickbaseClient;
                      const rawMethodKey = `${rawMethodName}Raw` as keyof typeof api;
                      const method =
                        api[rawMethodKey] || api[rawMethodName as keyof typeof api];
                      const boundMethod = method.bind(api as any) as unknown;
                      if (typeof boundMethod === "function" && boundMethod.length <= 2) {
                        const httpMethod = extractHttpMethod(method);
                        methodMap[simplifiedName] = {
                          api,
                          method: boundMethod as any,
                          paramMap: getParamNames(method),
                          httpMethod,
                        };
                      }
                    });
                }
                if (debug) {
                  console.log("[buildMethodMap] Methods:", Object.keys(methodMap));
                }
                return methodMap as MethodMap;
              }

              const methodMap = buildMethodMap();

              const proxyHandler: ProxyHandler<QuickbaseClient> = {
                get: (_, prop: string) => {
                  console.log(
                    "[proxy] Accessing:",
                    prop,
                    "in methodMap:",
                    prop in methodMap
                  );
                  if (prop in methodMap) {
                    const methodName = prop as keyof QuickbaseClient;
                    return (params: Parameters<QuickbaseClient[typeof methodName]>[0]) =>
                      invokeMethod(
                        methodName,
                        params,
                        methodMap,
                        baseHeaders,
                        authStrategy,
                        rateLimiter,
                        transformDates,
                        debug,
                        convertDates
                      );
                  }
                  console.log("[proxy] Method not found:", prop);
                  return undefined;
                },
              };

              const proxy = new Proxy<QuickbaseClient>({} as QuickbaseClient, proxyHandler);

              if (debug) {
                console.log("[createClient] Config:", config);
                console.log("[createClient] Proxy created:", proxy);
              }

              return proxy;
            }
        - name: >-
            rateLimiter.ts
          type: >-
            file
        - name: >-
            tokenCache.ts
          type: >-
            file
        - name: >-
            utils.ts
          type: >-
            file
    - name: >-
        test-artifacts
      type: >-
        directory
      children:
        - name: >-
            .last-run.json
          type: >-
            file
    - name: >-
        tests
      type: >-
        directory
      children:
        - name: >-
            playwright
          type: >-
            directory
          children:
            - name: >-
                qb
              type: >-
                directory
              children:
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        cacheSwitching.test.ts
                      type: >-
                        file
                    - name: >-
                        fetchTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithUserToken.test.ts
                      type: >-
                        file
                    - name: >-
                        getTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        tempTokenPrefetch.test.ts
                      type: >-
                        file
                    - name: >-
                        tempTokenRenewal.test.ts
                      type: >-
                        file
        - name: >-
            setup.ts
          type: >-
            file
          contents: >
            //
            @tests/setup.ts

            import
            {
            vi
            }
            from
            "vitest";

            import
            {
            quickbase
            }
            from
            "../src/quickbaseClient.ts";

            import
            type
            {
            QuickbaseConfig
            }
            from
            "../src/quickbaseClient.ts";

            import
            dotenv
            from
            "dotenv";


            //
            Load
            environment
            variables
            from
            .env
            file

            dotenv.config({
            path:
            "./.env"
            });
            //
            Assumes
            .env
            is
            at
            project
            root


            export
            const
            mockFetch
            =
            vi.fn();


            export
            const
            QB_REALM
            =
            process.env.QB_REALM
            ||
            "test-realm";

            export
            const
            QB_USER_TOKEN
            =
              process.env.QB_USER_TOKEN || "user-token-1234567890";
            export
            const
            QB_APP_ID
            =
            process.env.QB_APP_ID
            ||
            "app-id-1234567890";

            export
            const
            QB_TABLE_ID_1
            =
              process.env.QB_TABLE_ID_1 || "table-id-1-1234567890";
            export
            const
            QB_TABLE_ID_2
            =
              process.env.QB_TABLE_ID_2 || "table-id-2-1234567890";

            //
            Mock
            env
            variables
            for
            consistency,
            using
            .env
            values
            if
            available

            vi.stubEnv("QB_REALM",
            QB_REALM);

            vi.stubEnv("QB_USER_TOKEN",
            QB_USER_TOKEN);

            vi.stubEnv("QB_APP_ID",
            QB_APP_ID);

            vi.stubEnv("QB_TABLE_ID_1",
            QB_TABLE_ID_1);

            vi.stubEnv("QB_TABLE_ID_2",
            QB_TABLE_ID_2);


            export
            const
            createClient
            =
            (
              fetchApi?: any,
              config: Partial<QuickbaseConfig> = {}
            )
            =>
            {
              // Use loaded env vars with fallbacks for safety
              const realm = QB_REALM;
              const userToken = QB_USER_TOKEN;

              const client = quickbase({
                realm,
                userToken,
                debug: true,
                fetchApi,
                throttle: { rate: 10, burst: 10 }, // Throttle at 10 req/s with 10 burst capacity
                ...config, // Allow overrides if provided
              });
              console.log("[createClient] Config:", {
                realm,
                userToken,
                debug: true,
                throttle: { rate: 10, burst: 10 },
                ...config,
              });
              console.log("[createClient] Returning:", client);
              return client;
            };
        - name: >-
            vitest
          type: >-
            directory
          children:
            - name: >-
                qb
              type: >-
                directory
              children:
                - name: >-
                    apps
                  type: >-
                    directory
                  children:
                    - name: >-
                        copyApp.test.ts
                      type: >-
                        file
                    - name: >-
                        createApp.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppEvents.test.ts
                      type: >-
                        file
                    - name: >-
                        updateApp.test.ts
                      type: >-
                        file
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        mockQuickbaseServer.ts
                      type: >-
                        file
                    - name: >-
                        retryUserToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        ssoTokenIntegrationWithServer.test.ts
                      type: >-
                        file
                - name: >-
                    fields
                  type: >-
                    directory
                  children:
                    - name: >-
                        createField.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getField.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        getFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldsUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        updateField.test.ts
                      type: >-
                        file
                - name: >-
                    formulas
                  type: >-
                    directory
                  children:
                    - name: >-
                        runFormula.test.ts
                      type: >-
                        file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    records
                  type: >-
                    directory
                  children:
                    - name: >-
                        deleteRecords.test.ts
                      type: >-
                        file
                    - name: >-
                        runQuery.test.ts
                      type: >-
                        file
                    - name: >-
                        upsert.test.ts
                      type: >-
                        file
                - name: >-
                    tables
                  type: >-
                    directory
                  children:
                    - name: >-
                        createRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        createTable.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteTable.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppTables.test.ts
                      type: >-
                        file
                    - name: >-
                        getRelationships.test.ts
                      type: >-
                        file
                    - name: >-
                        getTable.test.ts
                      type: >-
                        file
                    - name: >-
                        updateRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        updateTable.test.ts
                      type: >-
                        file
            - name: >-
                unit
              type: >-
                directory
              children:
                - name: >-
                    ThrottleBucket.test.ts
                  type: >-
                    file
                - name: >-
                    apps
                  type: >-
                    directory
                  children:
                    - name: >-
                        copyApp.test.ts
                      type: >-
                        file
                    - name: >-
                        createApp.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppEvents.test.ts
                      type: >-
                        file
                    - name: >-
                        updateApp.test.ts
                      type: >-
                        file
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        fetchTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        getTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        retryTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        retryTempTokenMaxRetries.test.ts
                      type: >-
                        file
                    - name: >-
                        retryUserToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        ssoTokenRefresh.test.ts
                      type: >-
                        file
                - name: >-
                    fields
                  type: >-
                    directory
                  children:
                    - name: >-
                        createField.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getField.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        getFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldsUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        updateField.test.ts
                      type: >-
                        file
                - name: >-
                    formulas
                  type: >-
                    directory
                  children:
                    - name: >-
                        runFormula.test.ts
                      type: >-
                        file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    quickbaseClientHttpMethods.test.ts
                  type: >-
                    file
                - name: >-
                    rateLimit.test.ts
                  type: >-
                    file
                - name: >-
                    records
                  type: >-
                    directory
                  children:
                    - name: >-
                        deleteRecords.test.ts
                      type: >-
                        file
                    - name: >-
                        runQuery.test.ts
                      type: >-
                        file
                    - name: >-
                        upsert.test.ts
                      type: >-
                        file
                - name: >-
                    tables
                  type: >-
                    directory
                  children:
                    - name: >-
                        createRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        createTable.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteTable.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppTables.test.ts
                      type: >-
                        file
                    - name: >-
                        getRelationships.test.ts
                      type: >-
                        file
                    - name: >-
                        getTable.test.ts
                      type: >-
                        file
                    - name: >-
                        updateRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        updateTable.test.ts
                      type: >-
                        file
                - name: >-
                    tokenLifespan.test.ts
                  type: >-
                    file
                - name: >-
                    umd.test.ts
                  type: >-
                    file
    - name: >-
        tools
      type: >-
        directory
      children:
        - name: >-
            log-gen.ts
          type: >-
            file
        - name: >-
            log-gen.yaml
          type: >-
            file
        - name: >-
            openapi-jars
          type: >-
            directory
          children:
            - name: >-
                openapi-generator-cli-7.12.0.jar
              type: >-
                file
    - name: >-
        tsconfig.build.json
      type: >-
        file
    - name: >-
        tsconfig.json
      type: >-
        file
    - name: >-
        versionrc.json
      type: >-
        file
    - name: >-
        vitest.config.ts
      type: >-
        file

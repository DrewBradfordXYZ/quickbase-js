project: >-
  quickbase-js
date: >-
  3/15/2025
root: >-
  /home/drew/Projects/quickbase-js
goals:
  - >-
    A
    library
    for
    interacting
    with
    the
    QuickBase
    RESTful
    API.
  - >-
    Use
    OpenAPI
    to
    generate
    types
    and
    methods
    using
    a
    proxy.
    Validate
    with
    tests.
  - >-
    Provide
    robust
    and
    intuitive
    temporary
    token
    support
    for
    browser
    environments.
  - >-
    User
    Tokens
    support
    both
    Node.js
    and
    browser
    environments.
  - >-
    Use
    case:
    JS
    frameworks
    like
    React,
    Vue,
    and
    Angular
    hosted
    in
    QuickBase
    code
    pages.
  - >-
    Enable
    a
    flexible
    or
    native
    fetch
    in
    the
    browser.
  - >-
    Enable
    a
    flexible
    fetch
    framework
    in
    Node.js.
  - >-
    #
  - >-
    No
    manual
    updating
    methods
    when
    the
    QuickBase
    API
    changes.
  - >-
    The
    proxy
    magic
    dynamically
    maps
    generated
    methods
    and
    types.
  - >-
    #
  - >-
    TokenCache
    is
    defined
    per
    quickbaseClient
    call,
    so
    each
    instance
    has
    its
    own
    isolated
    TokenCache.
  - >-
    Each
    quickbase
    client
    instance
    has
    an
    isolated
    and
    individual
    token
    cache.
pipelineOverview:
  - >-
    What
    I’m
    Trying
    to
    Do
  - >-
    My
    approach
    is
    to
    ensure
    AppsApi.ts
    is
    generated
    with
    getAppById
    so
    QuickbaseClient.ts
    can
    map
    it
    to
    client.getApp.
    Steps
    include:
  - >-
    Fix
    fix-spec.ts:
  - >-
    Add
    tags:
    ["Apps"]
    to
    /apps/*
    endpoints
    to
    group
    them
    into
    AppsApi.ts.
  - >-
    Ensure
    all
    endpoints
    and
    models
    are
    correctly
    defined
    and
    typed.
  - >-
    Debug
    regenerate-client.ts:
  - >-
    Enhance
    logging
    to
    catch
    why
    AppsApi.ts
    isn’t
    generated.
  - >-
    Test
    if
    getAppById
    appears
    in
    another
    file
    (e.g.,
    DefaultApi.ts).
  - >-
    Update
    QuickbaseClient.ts:
  - >-
    Adjust
    imports
    to
    use
    the
    correct
    API
    class
    once
    generated.
  - >-
    Test
    and
    Iterate:
  - >-
    Run
    npm
    run
    fix-spec,
    npm
    run
    regenerate,
    and
    npm
    run
    test
    to
    verify
    AppsApi.ts
    exists
    and
    test.ts
    works.
  - >-
    The
    latest
    fix-spec.ts
    with
    tags
    aims
    to
    force
    the
    generator
    to
    create
    AppsApi.ts,
    addressing
    the
    missing
    file
    issue.
  - >-
    Relevant
    Project
    Files
  - >-
    Here’s
    a
    list
    of
    files
    that
    would
    help
    understand
    and
    resolve
    this
    problem,
    along
    with
    their
    roles:
  - >-
    src/code-generation/fix-spec.ts:
  - >-
    Role:
    Modifies
    the
    original
    QuickBase
    spec
    (e.g.,
    QuickBase_RESTful_*.json)
    to
    create
    quickbase-fixed.json
    with
    required
    endpoints
    (e.g.,
    /apps/{appId}).
  - >-
    Relevance:
    Defines
    the
    spec
    fed
    to
    the
    generator;
    errors
    here
    affect
    generation.
  - >-
    src/code-generation/quickbase-fixed.json:
  - >-
    Role:
    The
    processed
    OpenAPI
    spec
    used
    by
    regenerate-client.ts
    to
    generate
    code.
  - >-
    Relevance:
    Confirms
    if
    /apps/{appId}
    is
    correctly
    structured
    with
    operationId:
    "getAppById".
  - >-
    src/code-generation/regenerate-client.ts:
  - >-
    Role:
    Runs
    OpenAPI
    Generator
    to
    produce
    src/generated/
    files
    (APIs
    and
    models)
    and
    fixes
    .ts
    extensions
    with
    ts-morph.
  - >-
    Relevance:
    Controls
    the
    generation
    process;
    logs
    reveal
    why
    AppsApi.ts
    is
    missing.
  - >-
    src/generated/apis/AppsApi.ts
    (if
    exists):
  - >-
    Role:
    Should
    contain
    getAppById
    method
    for
    /apps/{appId}
    GET.
  - >-
    Relevance:
    Missing
    file
    is
    the
    core
    issue;
    its
    absence
    breaks
    QuickbaseClient.ts.
  - >-
    src/generated/apis/DefaultApi.ts:
  - >-
    Role:
    Default
    API
    class
    for
    untagged
    operations.
  - >-
    Relevance:
    Might
    contain
    getAppById
    if
    tags
    are
    misconfigured.
  - >-
    src/QuickbaseClient.ts:
  - >-
    Role:
    Wraps
    generated
    API
    classes
    (e.g.,
    AppsApi)
    in
    a
    Proxy
    for
    ergonomic
    calls
    (e.g.,
    client.getApp).
  - >-
    Relevance:
    Fails
    to
    import
    AppsApi.ts,
    causing
    the
    runtime
    error.
  - >-
    src/test.ts:
  - >-
    Role:
    Test
    script
    calling
    client.getApp({
    appId
    }).
  - >-
    Relevance:
    Final
    validation
    point;
    shows
    if
    the
    fix
    works.
  - >-
    .env.development:
  - >-
    Role:
    Stores
    QB_REALM,
    QB_USER_TOKEN,
    QB_APP_ID
    for
    API
    authentication.
  - >-
    Relevance:
    Ensures
    the
    API
    call
    has
    valid
    credentials
    (not
    the
    current
    issue,
    but
    critical
    for
    success).
  - >-
    src/specs/QuickBase_RESTful_API_2025-03-04T06_22_39.725Z.json
    (or
    similar):
  - >-
    Role:
    Original
    QuickBase
    API
    spec
    before
    fix-spec.ts
    processing.
  - >-
    Relevance:
    Shows
    how
    /apps/{appId}
    was
    originally
    defined,
    helping
    identify
    conflicts.
  - >-
    package.json:
  - >-
    Role:
    Defines
    scripts
    (fix-spec,
    regenerate,
    test)
    and
    dependencies
    (e.g.,
    ts-node,
    openapi-generator-cli).
  - >-
    Relevance:
    Confirms
    script
    commands
    and
    versions
    align
    with
    our
    process.
  - >-
    What
    We
    Achieved
  - >-
    Goal
    Met:
    You
    can
    now
    call
    client.getApp({
    appId:
    "buwai2zpe"
    })
    and
    get
    the
    app
    details
    {
    id:
    'buwai2zpe',
    name:
    'qb-copy'
    }.
  - >-
    Fixes
    Applied:
  - >-
    Added
    tags:
    ["Apps"]
    in
    fix-spec.ts
    to
    ensure
    AppsApi.ts
    is
    generated
    with
    getAppById.
  - >-
    Updated
    QuickbaseClient.ts
    to:
  - >-
    Use
    prototype
    methods
    via
    Object.getOwnPropertyNames.
  - >-
    Bind
    methods
    to
    preserve
    context
    with
    .bind(api).
  - >-
    Handle
    getAppById’s
    direct
    JSON
    return
    instead
    of
    a
    Response
    object.
  - >-
    Result:
    The
    ergonomic
    API
    you
    wanted
    (client.getApp)
    works
    seamlessly
    with
    the
    generated
    AppsApi.ts.
  - >-
    Why
    It
    Works
    Now
  - >-
    fix-spec.ts:
  - >-
    Correctly
    defined
    /apps/{appId}
    with
    operationId:
    "getAppById"
    and
    tags:
    ["Apps"],
    ensuring
    AppsApi.ts
    generation.
  - >-
    regenerate-client.ts:
  - >-
    Successfully
    ran
    OpenAPI
    Generator
    to
    produce
    AppsApi.ts
    with
    getAppById.
  - >-
    QuickbaseClient.ts:
  - >-
    buildMethodMap
    now
    captures
    getAppById
    and
    maps
    it
    to
    getApp.
  - >-
    invokeMethod
    passes
    {
    appId:
    'buwai2zpe'
    }
    as
    requestParameters
    and
    handles
    the
    JSON
    response
    directly.
  - >-
    test.ts:
  - >-
    Calls
    client.getApp
    and
    logs
    the
    result,
    proving
    the
    end-to-end
    flow.
tree:
  name: >-
    .
  type: >-
    directory
  children:
    - name: >-
        .env
      type: >-
        file
    - name: >-
        .gitignore
      type: >-
        file
    - name: >-
        CHANGELOG.md
      type: >-
        file
    - name: >-
        LICENSE
      type: >-
        file
    - name: >-
        README.md
      type: >-
        file
    - name: >-
        build-common.js
      type: >-
        file
    - name: >-
        build-esm.js
      type: >-
        file
    - name: >-
        build-umd.js
      type: >-
        file
    - name: >-
        debug.log
      type: >-
        file
    - name: >-
        dist
      type: >-
        directory
      children:
        - name: >-
            esm
          type: >-
            directory
          children:
            - name: >-
                quickbase.d.ts
              type: >-
                file
            - name: >-
                quickbase.js
              type: >-
                file
            - name: >-
                quickbase.js.map
              type: >-
                file
            - name: >-
                quickbase.min.js
              type: >-
                file
            - name: >-
                quickbase.min.js.map
              type: >-
                file
        - name: >-
            umd
          type: >-
            directory
          children:
            - name: >-
                quickbase.umd.js
              type: >-
                file
            - name: >-
                quickbase.umd.js.map
              type: >-
                file
            - name: >-
                quickbase.umd.min.js
              type: >-
                file
            - name: >-
                quickbase.umd.min.js.map
              type: >-
                file
    - name: >-
        examples
      type: >-
        directory
      children:
        - name: >-
            quicbase-jsCDN.html
          type: >-
            file
        - name: >-
            react.js
          type: >-
            file
        - name: >-
            vanillajs.html
          type: >-
            file
    - name: >-
        gen-no-overrides.log
      type: >-
        file
    - name: >-
        notes.txt
      type: >-
        file
    - name: >-
        open-api
      type: >-
        directory
      children:
        - name: >-
            definitions
          type: >-
            directory
          children:
            - name: >-
                apps.ts
              type: >-
                file
            - name: >-
                auth.ts
              type: >-
                file
            - name: >-
                events.ts
              type: >-
                file
            - name: >-
                fields.ts
              type: >-
                file
            - name: >-
                index.ts
              type: >-
                file
            - name: >-
                records.ts
              type: >-
                file
            - name: >-
                relationships.ts
              type: >-
                file
            - name: >-
                reports.ts
              type: >-
                file
            - name: >-
                tables.ts
              type: >-
                file
        - name: >-
            fix-spec-main.ts
          type: >-
            file
          contents: >
            #!/usr/bin/env
            node


            import
            {
            promises
            as
            fs
            }
            from
            "fs";

            import
            path
            from
            "path";

            import
            {
            fileURLToPath
            }
            from
            "url";

            import
            *
            as
            glob
            from
            "glob";


            interface
            Parameter
            {
              name: string;
              in: string;
              required?: boolean;
              type?: string;
              schema?: {
                type?: string;
                items?: any;
                $ref?: string;
                properties?: any;
                example?: any;
              };
              example?: any;
            }


            interface
            Operation
            {
              parameters?: Parameter[];
              responses?: Record<string, { description: string; schema?: any }>;
              operationId?: string;
              summary?: string;
              tags?: string[];
            }


            interface
            Spec
            {
              paths: Record<string, Record<string, Operation>>;
              definitions?: Record<string, any>;
              swagger: string;
              info: any;
              operations?: any;
              groups?: any;
              components?: any;
            }


            interface
            FixSpecConfig
            {
              applyOverrides?: boolean;
              overridePaths?: string[];
              overrideDefinitions?: string[];
            }


            function
            toCamelCase(str:
            string):
            string
            {
              return str
                .replace(/[-_](.)/g, (_, char) => char.toUpperCase())
                .replace(/^./, (str) => str.toLowerCase());
            }


            function
            fixArraySchemas(spec:
            Spec)
            {
              for (const pathKey in spec.paths) {
                for (const method in spec.paths[pathKey]) {
                  const operation = spec.paths[pathKey][method];
                  if (operation.parameters) {
                    operation.parameters.forEach((param: Parameter) => {
                      if (param.schema?.type === "array" && !param.schema.items) {
                        console.log(
                          `Fixing array schema for ${pathKey}(${method}).${param.name}`
                        );
                        param.schema.items = { type: "string" };
                      }
                      if (param.schema?.properties) {
                        for (const propKey in param.schema.properties) {
                          const prop = param.schema.properties[propKey];
                          if (prop.type === "array" && !prop.items) {
                            console.log(
                              `Fixing nested array for ${pathKey}(${method}).${param.name}.${propKey}`
                            );
                            prop.items = { type: "string" };
                          }
                        }
                      }
                    });
                  }
                  if (operation.responses) {
                    for (const status in operation.responses) {
                      const response = operation.responses[status];
                      if (response.schema?.type === "array" && !response.schema.items) {
                        console.log(
                          `Fixing array schema for ${pathKey}(${method}).responses.${status}`
                        );
                        response.schema.items = { type: "string" };
                      }
                      if (response.schema?.properties) {
                        for (const propKey in response.schema.properties) {
                          const prop = response.schema.properties[propKey];
                          if (prop.type === "array" && !prop.items) {
                            console.log(
                              `Fixing nested array for ${pathKey}(${method}).responses.${status}.${propKey}`
                            );
                            prop.items = { type: "string" };
                          }
                        }
                      }
                    }
                  }
                }
              }

              console.log("Fixing array schemas in definitions...");
              const definitions = spec.definitions || {};

              for (const defKey in definitions) {
                const def = definitions[defKey];
                if (def.properties) {
                  for (const propKey in def.properties) {
                    const prop = def.properties[propKey];
                    if (prop.type === "array" && !prop.items) {
                      console.log(`Fixing missing items in ${defKey}.${propKey}`);
                      prop.items = { type: "string" };
                    }
                  }
                }
              }
            }


            function
            enhanceRawSpec(spec:
            Spec)
            {
              spec.definitions = spec.definitions || {};

              // Define Record if not present
              if (!spec.definitions["Record"]) {
                spec.definitions["Record"] = {
                  type: "object",
                  additionalProperties: {
                    type: "object",
                    properties: {
                      value: { type: "string" }, // Generic field value, can be refined later
                    },
                    required: ["value"],
                  },
                  description: "A generic QuickBase record with field ID-value pairs",
                };
                console.log("Added Record to definitions");
              }

              // Normalize definition names to camelCase
              const normalizeDefinitionName = (name: string) => {
                return name.charAt(0).toUpperCase() + name.slice(1);
              };

              for (const pathKey in spec.paths) {
                for (const method in spec.paths[pathKey]) {
                  const operation = spec.paths[pathKey][method];
                  const opId =
                    operation.operationId || `${method}${pathKey.replace(/\W/g, "")}`;

                  if (operation.parameters) {
                    operation.parameters.forEach((param: Parameter) => {
                      if (param.in === "body") {
                        if (!param.schema) {
                          param.schema = {};
                        }
                        let requestName =
                          param.schema.$ref?.split("/").pop() || `${opId}Request`;
                        requestName = normalizeDefinitionName(requestName);

                        if (spec.definitions[requestName]?.type === "array") {
                          console.log(
                            `Wrapping array schema for ${requestName} in ${pathKey}(${method})`
                          );
                          const arraySchema = spec.definitions[requestName];
                          let wrapperPropName = operation.tags?.includes("Users")
                            ? "userIds"
                            : "items";
                          if (
                            operation.tags?.includes("Groups") &&
                            operation.summary?.toLowerCase().includes("subgroup")
                          ) {
                            wrapperPropName = "groupIds";
                          }
                          spec.definitions[requestName] = {
                            type: "object",
                            properties: {
                              [wrapperPropName]: arraySchema,
                            },
                            required: arraySchema.minItems > 0 ? [wrapperPropName] : [],
                            description:
                              arraySchema.description || `Request body for ${opId}`,
                          };
                        } else {
                          let properties = spec.definitions[requestName]?.properties || {};
                          if (
                            !spec.definitions[requestName] ||
                            !spec.definitions[requestName].type ||
                            Object.keys(properties).length === 0
                          ) {
                            console.log(
                              `Defining schema for ${requestName} in ${pathKey}(${method})`
                            );
                            if (operation.tags?.includes("Users")) {
                              properties = {
                                userIds: { type: "array", items: { type: "string" } },
                              };
                            } else if (
                              operation.tags?.includes("Groups") &&
                              operation.summary?.toLowerCase().includes("subgroup")
                            ) {
                              properties = {
                                groupIds: { type: "array", items: { type: "string" } },
                              };
                            } else if (
                              operation.tags?.includes("Records") &&
                              method === "post"
                            ) {
                              properties = {
                                data: {
                                  type: "array",
                                  items: { $ref: "#/definitions/Record" },
                                },
                                to: { type: "string" },
                                fieldsToReturn: {
                                  type: "array",
                                  items: { type: "integer" },
                                },
                              };
                            } else if (
                              operation.tags?.includes("Records") &&
                              method === "delete"
                            ) {
                              properties = {
                                from: { type: "string" },
                                where: { type: "string" },
                              };
                            } else if (
                              operation.tags?.includes("Records") &&
                              operation.summary?.toLowerCase().includes("query")
                            ) {
                              properties = {
                                from: { type: "string" },
                                select: { type: "array", items: { type: "integer" } },
                                where: { type: "string" },
                              };
                            } else if (operation.tags?.includes("Formulas")) {
                              properties = { formula: { type: "string" } };
                            } else if (
                              operation.tags?.includes("Apps") ||
                              operation.tags?.includes("Tables")
                            ) {
                              properties = { name: { type: "string" } };
                            } else if (operation.tags?.includes("Fields")) {
                              properties =
                                method === "delete"
                                  ? {
                                      fieldIds: {
                                        type: "array",
                                        items: { type: "integer" },
                                      },
                                    }
                                  : {
                                      label: { type: "string" },
                                      fieldType: { type: "string" },
                                    };
                            } else if (operation.tags?.includes("Reports")) {
                              properties = {
                                filters: { type: "array", items: { type: "object" } },
                              };
                            } else if (operation.tags?.includes("Auth")) {
                              properties = { token: { type: "string" } };
                            } else if (operation.tags?.includes("UserToken")) {
                              properties = operation.summary
                                ?.toLowerCase()
                                .includes("transfer")
                                ? {
                                    userToken: { type: "string" },
                                    toUserId: { type: "string" },
                                  }
                                : { userToken: { type: "string" } };
                            } else if (operation.tags?.includes("Audit")) {
                              properties = {
                                events: { type: "array", items: { type: "object" } },
                              };
                            } else if (operation.tags?.includes("Analytics")) {
                              properties = {
                                where: { type: "array", items: { type: "object" } },
                              };
                            } else if (operation.tags?.includes("Solutions")) {
                              properties = { name: { type: "string" } };
                            } else {
                              properties = {
                                items: { type: "array", items: { type: "string" } },
                              };
                            }
                            spec.definitions[requestName] = {
                              type: "object",
                              properties,
                              required: Object.keys(properties).filter(
                                (key) => key !== "fieldsToReturn"
                              ),
                              description: operation.summary || `Request body for ${opId}`,
                            };
                          }
                        }
                        param.schema = { $ref: `#/definitions/${requestName}` };
                        console.log(
                          `Ensured ${requestName} in definitions for ${pathKey}(${method})`
                        );
                      } else if (
                        !param.type &&
                        !param.schema &&
                        (param.in === "path" || param.in === "query")
                      ) {
                        param.type = param.name.includes("Id") ? "string" : "string";
                        console.log(
                          `Set default type 'string' for ${pathKey}(${method}).${param.name}`
                        );
                      }
                    });
                  }

                  if (operation.responses) {
                    for (const status in operation.responses) {
                      const response = operation.responses[status];
                      if (response.schema) {
                        const cleanStatus = status.replace("/", "_");
                        const responseName = normalizeDefinitionName(
                          `${opId}${cleanStatus}Response`
                        );
                        if (!spec.definitions[responseName]) {
                          console.log(
                            `Adding ${responseName} to definitions for ${pathKey}(${method})`
                          );
                          spec.definitions[responseName] = response.schema;
                        }
                        response.schema = { $ref: `#/definitions/${responseName}` };
                      }
                    }
                  }
                }
              }

              console.log("Fixing array schemas...");
              fixArraySchemas(spec);

              console.log("Removing unexpected top-level attributes...");
              delete spec.operations;
              delete spec.groups;
              delete spec.components;
            }


            async
            function
            fixQuickBaseSpec(config:
            FixSpecConfig
            =
            {}):
            Promise<void>
            {
              try {
                const CODEGEN_DIR = path.dirname(fileURLToPath(import.meta.url));
                const SPECS_DIR = path.join(CODEGEN_DIR, "..", "specs");
                const OUTPUT_DIR = path.join(CODEGEN_DIR, "output");
                console.log("Finding latest QuickBase RESTful API spec...");
                const specFiles = glob.sync(
                  path.join(SPECS_DIR, "QuickBase_RESTful_*.json")
                );
                if (specFiles.length === 0) {
                  throw new Error(
                    "No QuickBase_RESTful_*.json files found in specs/ folder."
                  );
                }
                const inputFile = specFiles.sort().pop() as string;
                const outputFile = path.join(OUTPUT_DIR, "quickbase-fixed.json");

                console.log(`Reading ${path.basename(inputFile)} from specs/...`);
                const specContent = await fs.readFile(inputFile, "utf8");
                const spec: Spec = JSON.parse(specContent);

                console.log("Fixing parameters...");
                for (const pathKey in spec.paths) {
                  for (const method in spec.paths[pathKey]) {
                    const operation = spec.paths[pathKey][method];
                    if (operation.parameters) {
                      operation.parameters = operation.parameters
                        .filter(
                          (param) =>
                            !["QB-Realm-Hostname", "Authorization", "User-Agent"].includes(
                              param.name
                            )
                        )
                        .map((param: Parameter) => {
                          param.name = toCamelCase(param.name);
                          if ("example" in param) delete param.example;
                          if ("schema" in param && param.in !== "body") delete param.schema;
                          if (!param.type && param.in !== "body") {
                            param.type = param.name.includes("Id") ? "string" : "string";
                            console.log(
                              `Set default type 'string' for ${pathKey}(${method}).${param.name} in initial pass`
                            );
                          }
                          return param;
                        });
                    }
                  }
                }

                if (!config.applyOverrides) {
                  console.log("Running with no overrides, using raw spec only...");
                }
                console.log("Enhancing raw spec...");
                enhanceRawSpec(spec);

                console.log(`Writing fixed spec to ${path.basename(outputFile)}...`);
                await fs.mkdir(OUTPUT_DIR, { recursive: true });
                await fs.writeFile(outputFile, JSON.stringify(spec, null, 2), "utf8");
                console.log("Spec fixed successfully! Output written to:", outputFile);
              } catch (error) {
                console.error("Failed to fix spec:", error);
                process.exit(1);
              }
            }


            async
            function
            main()
            {
              try {
                const args = process.argv.slice(2);
                let config: FixSpecConfig = {};

                for (let i = 0; i < args.length; i++) {
                  if (args[i] === "--config" && i + 1 < args.length) {
                    config = JSON.parse(args[i + 1]);
                    i++;
                  }
                }

                await fixQuickBaseSpec(config);
              } catch (error) {
                console.error("Fatal error in script execution:", error);
                process.exit(1);
              }
            }


            main();
        - name: >-
            generate-unified-interface.ts
          type: >-
            file
          contents: >
            //
            open-api/generate-unified-interface.ts

            import
            {
              readFileSync,
              writeFileSync,
              mkdirSync,
              existsSync,
              readdirSync,
            }
            from
            "fs";

            import
            {
            join,
            dirname
            }
            from
            "path";

            import
            {
            fileURLToPath
            }
            from
            "url";

            import
            {
            OpenAPIV2
            }
            from
            "openapi-types";

            import
            {
            simplifyName
            }
            from
            "../src/utils.ts";


            const
            __dirname
            =
            dirname(fileURLToPath(import.meta.url));

            const
            SPEC_FILE
            =
            join(__dirname,
            "output",
            "quickbase-fixed.json");

            const
            OUTPUT_DIR
            =
            join(__dirname,
            "..",
            "src",
            "generated-unified");

            const
            OUTPUT_FILE
            =
            join(OUTPUT_DIR,
            "QuickbaseClient.ts");

            const
            MODELS_DIR
            =
            join(__dirname,
            "..",
            "src",
            "generated",
            "models");


            function
            mapOpenApiTypeToTs(
              openApiType: string | string[] | undefined
            ):
            string
            {
              const type = Array.isArray(openApiType)
                ? openApiType[0]
                : openApiType || "any";
              switch (type.toLowerCase()) {
                case "integer":
                case "int":
                case "number":
                  return "number";
                case "string":
                  return "string";
                case "boolean":
                  return "boolean";
                default:
                  return "any";
              }
            }


            function
            mapRefToType(
              schema: OpenAPIV2.SchemaObject | OpenAPIV2.ReferenceObject | undefined,
              modelImports: Set<string>,
              spec: OpenAPIV2.Document,
              depth: number = 0,
              availableModels: string[],
              missingTypes: Set<string>
            ):
            string
            {
              if (!schema) return "any";

              if ("$ref" in schema && schema.$ref) {
                const refParts = schema.$ref.split("/");
                const model = refParts[refParts.length - 1];
                const camelModel = model.charAt(0).toUpperCase() + model.slice(1);
                if (availableModels.includes(camelModel)) {
                  modelImports.add(camelModel);
                  return camelModel;
                }
                missingTypes.add(camelModel);
                console.warn(
                  `Type ${camelModel} not found in /generated/models, defaulting to 'any'`
                );
                return "any";
              }

              if ("type" in schema) {
                if (schema.type === "array" && schema.items) {
                  const items = schema.items as
                    | OpenAPIV2.SchemaObject
                    | OpenAPIV2.ReferenceObject;
                  const itemType = mapRefToType(
                    items,
                    modelImports,
                    spec,
                    depth + 1,
                    availableModels,
                    missingTypes
                  );
                  return `${itemType}[]`;
                }

                if (schema.type === "object") {
                  if (schema.additionalProperties) {
                    const additionalProps = schema.additionalProperties as
                      | OpenAPIV2.SchemaObject
                      | OpenAPIV2.ReferenceObject
                      | boolean;
                    if (typeof additionalProps === "boolean") {
                      return "{ [key: string]: any }";
                    }
                    const valueType = mapRefToType(
                      additionalProps,
                      modelImports,
                      spec,
                      depth + 1,
                      availableModels,
                      missingTypes
                    );
                    return `{ [key: string]: ${valueType} }`;
                  }
                  if (schema.properties) {
                    const props = Object.entries(schema.properties).map(([key, prop]) => {
                      const propSchema = prop as OpenAPIV2.SchemaObject;
                      const propType = mapRefToType(
                        propSchema,
                        modelImports,
                        spec,
                        depth + 1,
                        availableModels,
                        missingTypes
                      );
                      return `${key}${propSchema.required ? "" : "?"}: ${propType}`;
                    });
                    return `{ ${props.join("; ")} }`;
                  }
                  return "{ [key: string]: any }";
                }

                return mapOpenApiTypeToTs(schema.type);
              }

              return "any";
            }


            function
            generateInterface()
            {
              if (!existsSync(SPEC_FILE)) {
                console.error(
                  `Spec file ${SPEC_FILE} not found. Run 'npm run fix-spec' first.`
                );
                process.exit(1);
              }

              console.log("Generating unified QuickbaseClient interface...");
              const spec = JSON.parse(
                readFileSync(SPEC_FILE, "utf8")
              ) as OpenAPIV2.Document;
              const { paths } = spec;

              // Load available models from /generated/models
              const availableModels = readdirSync(MODELS_DIR)
                .filter((file) => file.endsWith(".ts") && !file.startsWith("index"))
                .map((file) => file.replace(".ts", ""));
              console.log("Available models:", availableModels);

              const modelImports = new Set<string>();
              const missingTypes = new Set<string>();
              const methods: string[] = [];

              for (const [path, methodsObj] of Object.entries(
                paths as OpenAPIV2.PathsObject
              )) {
                if (!methodsObj) continue;

                for (const [method, operation] of Object.entries(
                  methodsObj as OpenAPIV2.PathItemObject
                )) {
                  const op = operation as OpenAPIV2.OperationObject | undefined;
                  if (!op || !op.operationId) continue;

                  const opId = simplifyName(op.operationId);
                  const summary = op.summary || "No description available.";
                  const params = (op.parameters || [])
                    .filter((p) => {
                      const param = p as OpenAPIV2.Parameter;
                      return !["QB-Realm-Hostname", "Authorization", "User-Agent"].includes(
                        "name" in param ? param.name : ""
                      );
                    })
                    .map((param: OpenAPIV2.Parameter) => {
                      if (!("name" in param)) return "";
                      let type: string;
                      if ("schema" in param && param.schema) {
                        type = mapRefToType(
                          param.schema,
                          modelImports,
                          spec,
                          1,
                          availableModels,
                          missingTypes
                        );
                      } else if ("type" in param && param.type) {
                        type = mapOpenApiTypeToTs(param.type);
                      } else {
                        console.warn(
                          `Parameter ${param.name} in ${opId} has no type or schema, defaulting to 'any'`
                        );
                        type = "any";
                      }
                      const paramName = param.in === "body" ? "body" : param.name;
                      return `${paramName}${param.required ? "" : "?"}: ${type}`;
                    })
                    .filter((param) => param !== "")
                    .join("; ");

                  const successResponses = ["200", "207"]
                    .map((code) => ({
                      code,
                      response: op.responses?.[code] as
                        | OpenAPIV2.ResponseObject
                        | undefined,
                    }))
                    .filter(({ response }) => response?.schema);
                  const returnTypes = successResponses.map(({ response }) =>
                    mapRefToType(
                      response!.schema,
                      modelImports,
                      spec,
                      1,
                      availableModels,
                      missingTypes
                    )
                  );
                  const uniqueReturnTypes = [...new Set(returnTypes)];
                  const returnType =
                    uniqueReturnTypes.length > 1
                      ? uniqueReturnTypes.join(" | ")
                      : uniqueReturnTypes[0] || "void";

                  const jsDoc = [
                    `  /**`,
                    `   * ${summary}`,
                    `   * @param params - Parameters for the ${opId} operation`,
                    `   * @returns A promise resolving to the ${opId} response`,
                    `   */`,
                  ].join("\n");

                  methods.push(
                    `${jsDoc}\n  ${opId}: (params: { ${params} }) => Promise<${returnType}>;`
                  );
                }
              }

              // Log and report missing types
              if (missingTypes.size > 0) {
                console.log(
                  "Missing types detected (defaulted to 'any'):",
                  Array.from(missingTypes)
                );
                writeFileSync(
                  join(OUTPUT_DIR, "missing-types-report.json"),
                  JSON.stringify({ missingTypes: Array.from(missingTypes) }, null, 2)
                );
                console.log("Missing types report saved to missing-types-report.json");
              } else {
                console.log("No missing types detected.");
              }

              const importStatement =
                modelImports.size > 0
                  ? `import { ${Array.from(modelImports)
                      .sort()
                      .join(", ")} } from "../generated/models";`
                  : "";
              console.log(`Imports: ${Array.from(modelImports).join(", ")}`);

              const interfaceContent = `// Generated on ${new Date().toISOString()}\n${importStatement}\n\nexport interface QuickbaseClient {\n${methods.join(
                "\n"
              )}\n}\n`;

              if (!existsSync(OUTPUT_DIR)) {
                mkdirSync(OUTPUT_DIR, { recursive: true });
              }
              writeFileSync(OUTPUT_FILE, interfaceContent, "utf8");
              console.log(`Generated ${OUTPUT_FILE}`);
            }


            try
            {
              generateInterface();
            }
            catch
            (error)
            {
              console.error("Generation failed:", error);
              process.exit(1);
            }
        - name: >-
            output
          type: >-
            directory
          children:
            - name: >-
                override-report.json
              type: >-
                file
            - name: >-
                quickbase-fixed.json
              type: >-
                file
        - name: >-
            paths
          type: >-
            directory
          children:
            - name: >-
                apps.ts
              type: >-
                file
            - name: >-
                auth.ts
              type: >-
                file
            - name: >-
                events.ts
              type: >-
                file
            - name: >-
                fields.ts
              type: >-
                file
            - name: >-
                index.ts
              type: >-
                file
            - name: >-
                records.ts
              type: >-
                file
            - name: >-
                relationships.ts
              type: >-
                file
            - name: >-
                reports.ts
              type: >-
                file
            - name: >-
                tables.ts
              type: >-
                file
        - name: >-
            regenerate-client.ts
          type: >-
            file
          contents: >
            #!/usr/bin/env
            node

            import
            {
            execSync
            }
            from
            "child_process";

            import
            {
            existsSync
            }
            from
            "fs";

            import
            {
            join
            }
            from
            "path";

            import
            {
            fileURLToPath
            }
            from
            "url";

            import
            fetch
            from
            "node-fetch";

            import
            readline
            from
            "readline";


            const
            CURRENT_JAR_VERSION
            =
            "7.12.0";

            const
            MAVEN_METADATA_URL
            =
              "https://repo1.maven.org/maven2/org/openapitools/openapi-generator-cli/maven-metadata.xml";
            const
            CODEGEN_DIR
            =
            join(fileURLToPath(import.meta.url),
            "..");
            //
            open-api/

            const
            JARS_DIR
            =
            join(CODEGEN_DIR,
            "..",
            "tools",
            "openapi-jars");
            //
            Updated
            to
            tools/openapi-jars/

            const
            SPEC_INPUT
            =
            join(CODEGEN_DIR,
            "output",
            "quickbase-fixed.json");
            //
            Relative
            to
            open-api/

            const
            OUTPUT_DIR
            =
            join(CODEGEN_DIR,
            "..",
            "src",
            "generated");
            //
            Up
            to
            root,
            then
            into
            src/generated/


            async
            function
            getLatestVersion():
            Promise<string>
            {
              const response = await fetch(MAVEN_METADATA_URL);
              if (!response.ok)
                throw new Error(`Failed to fetch Maven metadata: ${response.statusText}`);
              const text = await response.text();
              const match = text.match(/<latest>(.*?)<\/latest>/);
              if (!match)
                throw new Error("Couldn’t parse latest version from Maven metadata");
              return match[1];
            }


            async
            function
            checkAndPromptForUpdate(messages:
            string[]):
            Promise<string>
            {
              const latestVersion = await getLatestVersion();
              if (latestVersion === CURRENT_JAR_VERSION) {
                messages.push(`Current version (${CURRENT_JAR_VERSION}) is the latest.`);
                return CURRENT_JAR_VERSION;
              }

              messages.push(
                `Newer version available: ${latestVersion} (current: ${CURRENT_JAR_VERSION})`
              );
              const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout,
              });

              return new Promise((resolve) => {
                const prompt = "Do you want to update to the latest version? (y/n): ";
                messages.push(prompt);
                rl.question(prompt, (answer) => {
                  rl.close();
                  if (answer.toLowerCase() === "y" || answer.toLowerCase() === "yes") {
                    messages.push(`Switching to version ${latestVersion}...`);
                    resolve(latestVersion);
                  } else {
                    messages.push(`Sticking with version ${CURRENT_JAR_VERSION}.`);
                    resolve(CURRENT_JAR_VERSION);
                  }
                });
              });
            }


            async
            function
            ensureJarExists(
              version: string,
              messages: string[]
            ):
            Promise<string>
            {
              const jarPath = join(JARS_DIR, `openapi-generator-cli-${version}.jar`);
              const jarUrl = `https://repo1.maven.org/maven2/org/openapitools/openapi-generator-cli/${version}/openapi-generator-cli-${version}.jar`;

              if (!existsSync(jarPath)) {
                messages.push(`Downloading OpenAPI Generator CLI v${version}...`);
                try {
                  execSync(`curl -L -o ${jarPath} ${jarUrl}`, { stdio: "inherit" });
                  messages.push(`Downloaded ${jarPath}`);
                } catch (error) {
                  messages.push("Failed to download JAR.");
                  throw error;
                }
              } else {
                messages.push(`Using existing ${jarPath}`);
              }
              return jarPath;
            }


            function
            regenerateClient(jarPath:
            string,
            messages:
            string[])
            {
              messages.push("Regenerating client from spec...");
              const command = `java -jar ${jarPath} generate -i ${SPEC_INPUT} -g typescript-fetch -o ${OUTPUT_DIR} --additional-properties=generateAliasAsModel=true`;
              try {
                execSync(command, { stdio: "inherit" });
                messages.push("Client regeneration complete.");
              } catch (error) {
                messages.push("Regeneration failed.");
                throw error;
              }
            }


            async
            function
            main()
            {
              const messages: string[] = [];
              try {
                if (!existsSync(SPEC_INPUT)) {
                  console.error(
                    `Spec file ${SPEC_INPUT} does not exist. Run 'npm run fix-spec' first.`
                  );
                  process.exit(1);
                }
                const versionToUse = await checkAndPromptForUpdate(messages);
                const jarPath = await ensureJarExists(versionToUse, messages);
                regenerateClient(jarPath, messages);
              } catch (error) {
                console.error("Error occurred during process:", error);
              } finally {
                console.log("\n--- Key Messages ---");
                messages.forEach((msg) => console.log(msg));
              }
            }


            main().catch((error)
            =>
            {
              console.error("Error in regeneration process:", error);
              process.exit(1);
            });
    - name: >-
        openapitools.json
      type: >-
        file
    - name: >-
        output.log
      type: >-
        file
    - name: >-
        package-lock.json
      type: >-
        file
    - name: >-
        package.json
      type: >-
        file
      contents: >
        {
          "name": "quickbase-js",
          "version": "1.1.0-beta.6",
          "description": "QuickBase JavaScript client for frameworks and vanilla JS",
          "type": "module",
          "main": "dist/esm/quickbase.js",
          "module": "dist/esm/quickbase.js",
          "types": "dist/esm/quickbase.d.ts",
          "publishConfig": {
            "access": "public"
          },
          "exports": {
            ".": {
              "import": {
                "minified": "./dist/esm/quickbase.min.js",
                "default": "./dist/esm/quickbase.js"
              },
              "require": {
                "minified": "./dist/umd/quickbase.umd.min.js",
                "default": "./dist/umd/quickbase.umd.js"
              },
              "types": "./dist/esm/quickbase.d.ts",
              "umd:types": "./dist/umd/quickbase.umd.d.ts"
            }
          },
          "scripts": {
            "build": "npm run build:esm && npm run build:umd",
            "build:esm": "rimraf dist/esm dist/temp dist/temp-src && node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' build-esm.js",
            "build:umd": "rimraf dist/umd dist/temp dist/temp-src && node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' build-umd.js",
            "release": "standard-version",
            "release:beta": "standard-version --prerelease beta",
            "release:alpha": "standard-version --prerelease alpha",
            "release:push": "npm run release:beta && git push --follow-tags origin main",
            "release:publish": "npm run release:push && npm publish --tag beta",
            "release:stable": "standard-version && git push --follow-tags origin main && npm publish",
            "fix-spec": "node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' open-api/fix-spec-main.ts",
            "fix-spec:no-overrides": "node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' open-api/fix-spec-main.ts --config '{\"applyOverrides\": false}'",
            "fix-spec:upsert-only": "node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' open-api/fix-spec-main.ts --config '{\"applyOverrides\": true, \"overridePaths\": [\"/records\"]}'",
            "fix-spec:report": "node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' open-api/fix-spec-main.ts --config '{\"applyOverrides\": true}' --report-only",
            "gen:openapi": "rimraf src/generated && node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' open-api/regenerate-client.ts",
            "gen:unified": "node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' open-api/generate-unified-interface.ts",
            "gen:all": "npm run split-spec && npm run validate-spec && npm run fix-spec && npm run gen:openapi && npm run gen:unified",
            "gen:no-overrides": "npm run split-spec && npm run validate-spec && npm run fix-spec:no-overrides && npm run gen:openapi && npm run gen:unified",
            "gen:upsert-only": "npm run split-spec && npm run validate-spec && npm run fix-spec:upsert-only && npm run gen:openapi && npm run gen:unified",
            "split-spec": "node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' tools/split-spec.ts",
            "validate-spec": "node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' tools/validate-spec.ts",
            "generate-types": "node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' tools/generate-types.ts",
            "log-gen": "node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"ts-node/esm\", pathToFileURL(\"./\"));' tools/log-gen.ts",
            "test:all": "vitest run tests/vitest/**/**/*.test.ts --reporter=basic && playwright test tests/playwright/qb --config playwright.config.ts --reporter=dot --quiet",
            "test:pw:qb:all": "playwright test tests/playwright/qb --config playwright.config.ts",
            "test:vitest:all": "vitest run tests/vitest/**/**/*.test.ts",
            "test:vitest:qb": "vitest run tests/vitest/qb/**/*.test.ts",
            "test:vitest:unit": "vitest run tests/vitest/unit/**/*.test.ts",
            "test:vitest:qb:apps": "vitest run tests/vitest/qb/apps/**/*.test.ts",
            "test:vitest:qb:auth": "vitest run tests/vitest/qb/auth/**/*.test.ts",
            "test:vitest:qb:fields": "vitest run tests/vitest/qb/fields/**/*.test.ts",
            "test:vitest:qb:records": "vitest run tests/vitest/qb/records/**/*.test.ts",
            "test:vitest:qb:tables": "vitest run tests/vitest/qb/tables/**/*.test.ts",
            "test:vitest:unit:apps": "vitest run tests/vitest/unit/apps/**/*.test.ts",
            "test:vitest:unit:auth": "vitest run tests/vitest/unit/auth/**/*.test.ts",
            "test:vitest:unit:fields": "vitest run tests/vitest/unit/fields/**/*.test.ts",
            "test:vitest:unit:records": "vitest run tests/vitest/unit/records/**/*.test.ts",
            "test:vitest:unit:tables": "vitest run tests/vitest/unit/tables/**/*.test.ts",
            "test:pw:qb:auth": "playwright test tests/playwright/qb/auth"
          },
          "dependencies": {
            "typescript": "^5.8.2"
          },
          "devDependencies": {
            "@openapitools/openapi-generator-cli": "^2.17.0",
            "@playwright/test": "^1.51.0",
            "@rollup/plugin-commonjs": "^28.0.3",
            "@rollup/plugin-node-resolve": "^16.0.0",
            "@rollup/plugin-terser": "^0.4.4",
            "@rollup/plugin-typescript": "^12.1.2",
            "@types/js-yaml": "^4.0.9",
            "@types/node": "^22.13.10",
            "dotenv": "^16.4.7",
            "glob": "^11.0.1",
            "js-yaml": "^4.1.0",
            "jsdom": "^26.0.0",
            "node-fetch": "^3.3.2",
            "openapi-schema-validator": "^12.1.3",
            "openapi-types": "^12.1.3",
            "openapi-typescript": "^7.6.1",
            "rimraf": "^5.0.10",
            "rollup": "^4.35.0",
            "rollup-plugin-dts": "^6.1.1",
            "standard-version": "^9.5.0",
            "ts-morph": "^25.0.1",
            "ts-node": "^10.9.2",
            "tslib": "^2.8.1",
            "undici-types": "^7.5.0",
            "vitest": "^3.0.8"
          }
        }
    - name: >-
        playwright.config.ts
      type: >-
        file
    - name: >-
        regenerate_output.log
      type: >-
        file
    - name: >-
        rollup.config.js
      type: >-
        file
    - name: >-
        src
      type: >-
        directory
      children:
        - name: >-
            generated
          type: >-
            directory
          children:
            - name: >-
                .openapi-generator
              type: >-
                directory
              children:
                - name: >-
                    FILES
                  type: >-
                    file
                - name: >-
                    VERSION
                  type: >-
                    file
            - name: >-
                .openapi-generator-ignore
              type: >-
                file
            - name: >-
                apis
              type: >-
                directory
              children:
                - name: >-
                    AppsApi.ts
                  type: >-
                    file
                - name: >-
                    AuditApi.ts
                  type: >-
                    file
                - name: >-
                    AuthApi.ts
                  type: >-
                    file
                - name: >-
                    DocumentTemplatesApi.ts
                  type: >-
                    file
                - name: >-
                    FieldsApi.ts
                  type: >-
                    file
                - name: >-
                    FilesApi.ts
                  type: >-
                    file
                - name: >-
                    FormulasApi.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticsApi.ts
                  type: >-
                    file
                - name: >-
                    RecordsApi.ts
                  type: >-
                    file
                - name: >-
                    ReportsApi.ts
                  type: >-
                    file
                - name: >-
                    SolutionsApi.ts
                  type: >-
                    file
                - name: >-
                    TablesApi.ts
                  type: >-
                    file
                - name: >-
                    UserTokenApi.ts
                  type: >-
                    file
                - name: >-
                    UsersApi.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
            - name: >-
                index.ts
              type: >-
                file
            - name: >-
                models
              type: >-
                directory
              children:
                - name: >-
                    AddManagersToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddManagersToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    AddMembersToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddMembersToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    AddSubgroupsToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddSubgroupsToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    Audit200Response.ts
                  type: >-
                    file
                - name: >-
                    Audit202Response.ts
                  type: >-
                    file
                - name: >-
                    AuditRequest.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution404Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionRequest.ts
                  type: >-
                    file
                - name: >-
                    CloneUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    CloneUserTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    CopyApp200Response.ts
                  type: >-
                    file
                - name: >-
                    CopyAppRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateApp200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateAppRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateField200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateFieldRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateRelationshipRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateTable200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateTableRequest.ts
                  type: >-
                    file
                - name: >-
                    DeactivateUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteApp200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteAppRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteFields200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteFieldsRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteFile200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteRecords200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteRecordsRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteTable200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersAndGroups200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersAndGroupsRequest.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    DownloadFile200Response.ts
                  type: >-
                    file
                - name: >-
                    ExchangeSsoToken200Response.ts
                  type: >-
                    file
                - name: >-
                    ExchangeSsoTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution404Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    GenerateDocument200Response.ts
                  type: >-
                    file
                - name: >-
                    GetApp200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppEvents200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppTables200Response.ts
                  type: >-
                    file
                - name: >-
                    GetField200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFieldUsage200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFields200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFieldsUsage200Response.ts
                  type: >-
                    file
                - name: >-
                    GetRelationships200Response.ts
                  type: >-
                    file
                - name: >-
                    GetReport200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTable200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTableReports200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTempTokenDBID200Response.ts
                  type: >-
                    file
                - name: >-
                    GetUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    GetUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200Response.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummariesRequest.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticReads200Response.ts
                  type: >-
                    file
                - name: >-
                    Record.ts
                  type: >-
                    file
                - name: >-
                    RecordValue.ts
                  type: >-
                    file
                - name: >-
                    RemoveManagersFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveManagersFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RemoveMembersFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveMembersFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RemoveSubgroupsFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveSubgroupsFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RunFormula200Response.ts
                  type: >-
                    file
                - name: >-
                    RunFormulaRequest.ts
                  type: >-
                    file
                - name: >-
                    RunQuery200Response.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequest.ts
                  type: >-
                    file
                - name: >-
                    RunReport200Response.ts
                  type: >-
                    file
                - name: >-
                    RunReportRequest.ts
                  type: >-
                    file
                - name: >-
                    TransferUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    TransferUserTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    UndenyUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    UndenyUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateApp200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateAppRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateField200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateFieldRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateRelationshipRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    UpdateTable200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateTableRequest.ts
                  type: >-
                    file
                - name: >-
                    Upsert200Response.ts
                  type: >-
                    file
                - name: >-
                    Upsert207Response.ts
                  type: >-
                    file
                - name: >-
                    Upsert400Response.ts
                  type: >-
                    file
                - name: >-
                    UpsertRequest.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
            - name: >-
                runtime.ts
              type: >-
                file
        - name: >-
            generated-unified
          type: >-
            directory
          children:
            - name: >-
                QuickbaseClient.ts
              type: >-
                file
              contents: >
                //
                Generated
                on
                2025-03-15T20:32:41.783Z

                import
                {
                AddManagersToGroup200Response,
                AddManagersToGroupRequest,
                AddMembersToGroup200Response,
                AddMembersToGroupRequest,
                AddSubgroupsToGroup200Response,
                AddSubgroupsToGroupRequest,
                Audit200Response,
                AuditRequest,
                ChangesetSolutionRequest,
                CloneUserToken200Response,
                CloneUserTokenRequest,
                CopyApp200Response,
                CopyAppRequest,
                CreateApp200Response,
                CreateAppRequest,
                CreateField200Response,
                CreateFieldRequest,
                CreateRelationship200Response,
                CreateRelationshipRequest,
                CreateSolutionRequest,
                CreateTable200Response,
                CreateTableRequest,
                DeactivateUserToken200Response,
                DeleteApp200Response,
                DeleteAppRequest,
                DeleteFields200Response,
                DeleteFieldsRequest,
                DeleteFile200Response,
                DeleteRecords200Response,
                DeleteRecordsRequest,
                DeleteRelationship200Response,
                DeleteTable200Response,
                DeleteUserToken200Response,
                DenyUsers200Response,
                DenyUsersAndGroups200Response,
                DenyUsersAndGroupsRequest,
                DenyUsersRequest,
                ExchangeSsoToken200Response,
                ExchangeSsoTokenRequest,
                GenerateDocument200Response,
                GetApp200Response,
                GetAppEvents200Response,
                GetAppTables200Response,
                GetField200Response,
                GetFieldUsage200Response,
                GetFields200Response,
                GetFieldsUsage200Response,
                GetRelationships200Response,
                GetReport200Response,
                GetTable200Response,
                GetTableReports200Response,
                GetTempTokenDBID200Response,
                GetUsers200Response,
                GetUsersRequest,
                PlatformAnalyticEventSummaries200Response,
                PlatformAnalyticEventSummariesRequest,
                PlatformAnalyticReads200Response,
                RemoveManagersFromGroup200Response,
                RemoveManagersFromGroupRequest,
                RemoveMembersFromGroup200Response,
                RemoveMembersFromGroupRequest,
                RemoveSubgroupsFromGroup200Response,
                RemoveSubgroupsFromGroupRequest,
                RunFormula200Response,
                RunFormulaRequest,
                RunQuery200Response,
                RunQueryRequest,
                RunReport200Response,
                RunReportRequest,
                TransferUserToken200Response,
                TransferUserTokenRequest,
                UndenyUsers200Response,
                UndenyUsersRequest,
                UpdateApp200Response,
                UpdateAppRequest,
                UpdateField200Response,
                UpdateFieldRequest,
                UpdateRelationship200Response,
                UpdateRelationshipRequest,
                UpdateSolutionRequest,
                UpdateTable200Response,
                UpdateTableRequest,
                Upsert200Response,
                Upsert207Response,
                UpsertRequest
                }
                from
                "../generated/models";


                export
                interface
                QuickbaseClient
                {
                  /**
                   * Create an app
                   * @param params - Parameters for the createApp operation
                   * @returns A promise resolving to the createApp response
                   */
                  createApp: (params: { body?: CreateAppRequest }) => Promise<CreateApp200Response>;
                  /**
                   * Get an app
                   * @param params - Parameters for the getApp operation
                   * @returns A promise resolving to the getApp response
                   */
                  getApp: (params: { appId: string }) => Promise<GetApp200Response>;
                  /**
                   * Update an app
                   * @param params - Parameters for the updateApp operation
                   * @returns A promise resolving to the updateApp response
                   */
                  updateApp: (params: { appId: string; body?: UpdateAppRequest }) => Promise<UpdateApp200Response>;
                  /**
                   * Delete an app
                   * @param params - Parameters for the deleteApp operation
                   * @returns A promise resolving to the deleteApp response
                   */
                  deleteApp: (params: { appId: string; body?: DeleteAppRequest }) => Promise<DeleteApp200Response>;
                  /**
                   * Get app events
                   * @param params - Parameters for the getAppEvents operation
                   * @returns A promise resolving to the getAppEvents response
                   */
                  getAppEvents: (params: { appId: string }) => Promise<GetAppEvents200Response>;
                  /**
                   * Copy an app
                   * @param params - Parameters for the copyApp operation
                   * @returns A promise resolving to the copyApp response
                   */
                  copyApp: (params: { appId: string; body?: CopyAppRequest }) => Promise<CopyApp200Response>;
                  /**
                   * Create a table
                   * @param params - Parameters for the createTable operation
                   * @returns A promise resolving to the createTable response
                   */
                  createTable: (params: { appId: string; body?: CreateTableRequest }) => Promise<CreateTable200Response>;
                  /**
                   * Get tables for an app
                   * @param params - Parameters for the getAppTables operation
                   * @returns A promise resolving to the getAppTables response
                   */
                  getAppTables: (params: { appId: string }) => Promise<GetAppTables200Response>;
                  /**
                   * Get a table
                   * @param params - Parameters for the getTable operation
                   * @returns A promise resolving to the getTable response
                   */
                  getTable: (params: { appId: string; tableId: string }) => Promise<GetTable200Response>;
                  /**
                   * Update a table
                   * @param params - Parameters for the updateTable operation
                   * @returns A promise resolving to the updateTable response
                   */
                  updateTable: (params: { appId: string; tableId: string; body?: UpdateTableRequest }) => Promise<UpdateTable200Response>;
                  /**
                   * Delete a table
                   * @param params - Parameters for the deleteTable operation
                   * @returns A promise resolving to the deleteTable response
                   */
                  deleteTable: (params: { appId: string; tableId: string }) => Promise<DeleteTable200Response>;
                  /**
                   * Get all relationships
                   * @param params - Parameters for the getRelationships operation
                   * @returns A promise resolving to the getRelationships response
                   */
                  getRelationships: (params: { skip?: number; tableId: string }) => Promise<GetRelationships200Response>;
                  /**
                   * Create a relationship
                   * @param params - Parameters for the createRelationship operation
                   * @returns A promise resolving to the createRelationship response
                   */
                  createRelationship: (params: { tableId: string; body?: CreateRelationshipRequest }) => Promise<CreateRelationship200Response>;
                  /**
                   * Update a relationship
                   * @param params - Parameters for the updateRelationship operation
                   * @returns A promise resolving to the updateRelationship response
                   */
                  updateRelationship: (params: { tableId: string; relationshipId: number; body?: UpdateRelationshipRequest }) => Promise<UpdateRelationship200Response>;
                  /**
                   * Delete a relationship
                   * @param params - Parameters for the deleteRelationship operation
                   * @returns A promise resolving to the deleteRelationship response
                   */
                  deleteRelationship: (params: { tableId: string; relationshipId: number }) => Promise<DeleteRelationship200Response>;
                  /**
                   * Get reports for a table
                   * @param params - Parameters for the getTableReports operation
                   * @returns A promise resolving to the getTableReports response
                   */
                  getTableReports: (params: { tableId: string }) => Promise<GetTableReports200Response>;
                  /**
                   * Get a report
                   * @param params - Parameters for the getReport operation
                   * @returns A promise resolving to the getReport response
                   */
                  getReport: (params: { tableId: string; reportId: string }) => Promise<GetReport200Response>;
                  /**
                   * Run a report
                   * @param params - Parameters for the runReport operation
                   * @returns A promise resolving to the runReport response
                   */
                  runReport: (params: { tableId: string; skip?: number; top?: number; reportId: string; body?: RunReportRequest }) => Promise<RunReport200Response>;
                  /**
                   * Get fields for a table
                   * @param params - Parameters for the getFields operation
                   * @returns A promise resolving to the getFields response
                   */
                  getFields: (params: { tableId: string; includeFieldPerms?: boolean }) => Promise<GetFields200Response>;
                  /**
                   * Create a field
                   * @param params - Parameters for the createField operation
                   * @returns A promise resolving to the createField response
                   */
                  createField: (params: { tableId: string; body?: CreateFieldRequest }) => Promise<CreateField200Response>;
                  /**
                   * Delete field(s)
                   * @param params - Parameters for the deleteFields operation
                   * @returns A promise resolving to the deleteFields response
                   */
                  deleteFields: (params: { tableId: string; body?: DeleteFieldsRequest }) => Promise<DeleteFields200Response>;
                  /**
                   * Get field
                   * @param params - Parameters for the getField operation
                   * @returns A promise resolving to the getField response
                   */
                  getField: (params: { tableId: string; includeFieldPerms?: boolean; fieldId: number }) => Promise<GetField200Response>;
                  /**
                   * Update a field
                   * @param params - Parameters for the updateField operation
                   * @returns A promise resolving to the updateField response
                   */
                  updateField: (params: { tableId: string; fieldId: number; body?: UpdateFieldRequest }) => Promise<UpdateField200Response>;
                  /**
                   * Get usage for all fields
                   * @param params - Parameters for the getFieldsUsage operation
                   * @returns A promise resolving to the getFieldsUsage response
                   */
                  getFieldsUsage: (params: { tableId: string; skip?: number; top?: number }) => Promise<GetFieldsUsage200Response>;
                  /**
                   * Get usage for a field
                   * @param params - Parameters for the getFieldUsage operation
                   * @returns A promise resolving to the getFieldUsage response
                   */
                  getFieldUsage: (params: { tableId: string; fieldId: number }) => Promise<GetFieldUsage200Response>;
                  /**
                   * Run a formula
                   * @param params - Parameters for the runFormula operation
                   * @returns A promise resolving to the runFormula response
                   */
                  runFormula: (params: { body?: RunFormulaRequest }) => Promise<RunFormula200Response>;
                  /**
                   * Insert/Update record(s)
                   * @param params - Parameters for the upsert operation
                   * @returns A promise resolving to the upsert response
                   */
                  upsert: (params: { body?: UpsertRequest }) => Promise<Upsert200Response | Upsert207Response>;
                  /**
                   * Delete record(s)
                   * @param params - Parameters for the deleteRecords operation
                   * @returns A promise resolving to the deleteRecords response
                   */
                  deleteRecords: (params: { body?: DeleteRecordsRequest }) => Promise<DeleteRecords200Response>;
                  /**
                   * Query for data
                   * @param params - Parameters for the runQuery operation
                   * @returns A promise resolving to the runQuery response
                   */
                  runQuery: (params: { body?: RunQueryRequest }) => Promise<RunQuery200Response>;
                  /**
                   * Get a temporary token for a dbid
                   * @param params - Parameters for the getTempTokenDBID operation
                   * @returns A promise resolving to the getTempTokenDBID response
                   */
                  getTempTokenDBID: (params: { dbid: string; qBAppToken?: string }) => Promise<GetTempTokenDBID200Response>;
                  /**
                   * Exchange an SSO token
                   * @param params - Parameters for the exchangeSsoToken operation
                   * @returns A promise resolving to the exchangeSsoToken response
                   */
                  exchangeSsoToken: (params: { body?: ExchangeSsoTokenRequest }) => Promise<ExchangeSsoToken200Response>;
                  /**
                   * Clone a user token
                   * @param params - Parameters for the cloneUserToken operation
                   * @returns A promise resolving to the cloneUserToken response
                   */
                  cloneUserToken: (params: { body?: CloneUserTokenRequest }) => Promise<CloneUserToken200Response>;
                  /**
                   * Transfer a user token
                   * @param params - Parameters for the transferUserToken operation
                   * @returns A promise resolving to the transferUserToken response
                   */
                  transferUserToken: (params: { body?: TransferUserTokenRequest }) => Promise<TransferUserToken200Response>;
                  /**
                   * Deactivate a user token
                   * @param params - Parameters for the deactivateUserToken operation
                   * @returns A promise resolving to the deactivateUserToken response
                   */
                  deactivateUserToken: (params: {  }) => Promise<DeactivateUserToken200Response>;
                  /**
                   * Delete a user token
                   * @param params - Parameters for the deleteUserToken operation
                   * @returns A promise resolving to the deleteUserToken response
                   */
                  deleteUserToken: (params: {  }) => Promise<DeleteUserToken200Response>;
                  /**
                   * Download file
                   * @param params - Parameters for the downloadFile operation
                   * @returns A promise resolving to the downloadFile response
                   */
                  downloadFile: (params: { tableId: string; recordId: number; fieldId: number; versionNumber: number }) => Promise<any>;
                  /**
                   * Delete file
                   * @param params - Parameters for the deleteFile operation
                   * @returns A promise resolving to the deleteFile response
                   */
                  deleteFile: (params: { tableId: string; recordId: number; fieldId: number; versionNumber: number }) => Promise<DeleteFile200Response>;
                  /**
                   * Get users
                   * @param params - Parameters for the getUsers operation
                   * @returns A promise resolving to the getUsers response
                   */
                  getUsers: (params: { accountId?: number; body?: GetUsersRequest }) => Promise<GetUsers200Response>;
                  /**
                   * Deny users
                   * @param params - Parameters for the denyUsers operation
                   * @returns A promise resolving to the denyUsers response
                   */
                  denyUsers: (params: { accountId?: number; body?: DenyUsersRequest }) => Promise<DenyUsers200Response>;
                  /**
                   * Deny and remove users from groups
                   * @param params - Parameters for the denyUsersAndGroups operation
                   * @returns A promise resolving to the denyUsersAndGroups response
                   */
                  denyUsersAndGroups: (params: { accountId?: number; shouldDeleteFromGroups: boolean; body?: DenyUsersAndGroupsRequest }) => Promise<DenyUsersAndGroups200Response>;
                  /**
                   * Undeny users
                   * @param params - Parameters for the undenyUsers operation
                   * @returns A promise resolving to the undenyUsers response
                   */
                  undenyUsers: (params: { accountId?: number; body?: UndenyUsersRequest }) => Promise<UndenyUsers200Response>;
                  /**
                   * Add members
                   * @param params - Parameters for the addMembersToGroup operation
                   * @returns A promise resolving to the addMembersToGroup response
                   */
                  addMembersToGroup: (params: { gid: number; body?: AddMembersToGroupRequest }) => Promise<AddMembersToGroup200Response>;
                  /**
                   * Remove members
                   * @param params - Parameters for the removeMembersFromGroup operation
                   * @returns A promise resolving to the removeMembersFromGroup response
                   */
                  removeMembersFromGroup: (params: { gid: number; body?: RemoveMembersFromGroupRequest }) => Promise<RemoveMembersFromGroup200Response>;
                  /**
                   * Add managers
                   * @param params - Parameters for the addManagersToGroup operation
                   * @returns A promise resolving to the addManagersToGroup response
                   */
                  addManagersToGroup: (params: { gid: number; body?: AddManagersToGroupRequest }) => Promise<AddManagersToGroup200Response>;
                  /**
                   * Remove managers
                   * @param params - Parameters for the removeManagersFromGroup operation
                   * @returns A promise resolving to the removeManagersFromGroup response
                   */
                  removeManagersFromGroup: (params: { gid: number; body?: RemoveManagersFromGroupRequest }) => Promise<RemoveManagersFromGroup200Response>;
                  /**
                   * Add child groups
                   * @param params - Parameters for the addSubgroupsToGroup operation
                   * @returns A promise resolving to the addSubgroupsToGroup response
                   */
                  addSubgroupsToGroup: (params: { gid: number; body?: AddSubgroupsToGroupRequest }) => Promise<AddSubgroupsToGroup200Response>;
                  /**
                   * Remove child groups
                   * @param params - Parameters for the removeSubgroupsFromGroup operation
                   * @returns A promise resolving to the removeSubgroupsFromGroup response
                   */
                  removeSubgroupsFromGroup: (params: { gid: number; body?: RemoveSubgroupsFromGroupRequest }) => Promise<RemoveSubgroupsFromGroup200Response>;
                  /**
                   * Get audit logs
                   * @param params - Parameters for the audit operation
                   * @returns A promise resolving to the audit response
                   */
                  audit: (params: { body?: AuditRequest }) => Promise<Audit200Response>;
                  /**
                   * Get read summaries
                   * @param params - Parameters for the platformAnalyticReads operation
                   * @returns A promise resolving to the platformAnalyticReads response
                   */
                  platformAnalyticReads: (params: { day?: string }) => Promise<PlatformAnalyticReads200Response>;
                  /**
                   * Get event summaries
                   * @param params - Parameters for the platformAnalyticEventSummaries operation
                   * @returns A promise resolving to the platformAnalyticEventSummaries response
                   */
                  platformAnalyticEventSummaries: (params: { accountId?: number; body?: PlatformAnalyticEventSummariesRequest }) => Promise<PlatformAnalyticEventSummaries200Response>;
                  /**
                   * Export a solution
                   * @param params - Parameters for the exportSolution operation
                   * @returns A promise resolving to the exportSolution response
                   */
                  exportSolution: (params: { solutionId: string; qBLVersion?: string }) => Promise<any>;
                  /**
                   * Update a solution
                   * @param params - Parameters for the updateSolution operation
                   * @returns A promise resolving to the updateSolution response
                   */
                  updateSolution: (params: { solutionId: string; body?: UpdateSolutionRequest; xQBLErrorsAsSuccess?: boolean }) => Promise<any>;
                  /**
                   * Create a solution
                   * @param params - Parameters for the createSolution operation
                   * @returns A promise resolving to the createSolution response
                   */
                  createSolution: (params: { body?: CreateSolutionRequest; xQBLErrorsAsSuccess?: boolean }) => Promise<any>;
                  /**
                   * Export solution to record
                   * @param params - Parameters for the exportSolutionToRecord operation
                   * @returns A promise resolving to the exportSolutionToRecord response
                   */
                  exportSolutionToRecord: (params: { solutionId: string; tableId: string; fieldId: number; xQBLErrorsAsSuccess?: boolean; qBLVersion?: string }) => Promise<any>;
                  /**
                   * Create solution from record
                   * @param params - Parameters for the createSolutionFromRecord operation
                   * @returns A promise resolving to the createSolutionFromRecord response
                   */
                  createSolutionFromRecord: (params: { tableId: string; fieldId: number; recordId: number; xQBLErrorsAsSuccess?: boolean }) => Promise<any>;
                  /**
                   * Update solution from record
                   * @param params - Parameters for the updateSolutionToRecord operation
                   * @returns A promise resolving to the updateSolutionToRecord response
                   */
                  updateSolutionToRecord: (params: { solutionId: string; tableId: string; fieldId: number; recordId: number; xQBLErrorsAsSuccess?: boolean }) => Promise<any>;
                  /**
                   * List solution changes
                   * @param params - Parameters for the changesetSolution operation
                   * @returns A promise resolving to the changesetSolution response
                   */
                  changesetSolution: (params: { solutionId: string; body?: ChangesetSolutionRequest; xQBLErrorsAsSuccess?: boolean }) => Promise<any>;
                  /**
                   * List solution changes from record
                   * @param params - Parameters for the changesetSolutionFromRecord operation
                   * @returns A promise resolving to the changesetSolutionFromRecord response
                   */
                  changesetSolutionFromRecord: (params: { solutionId: string; tableId: string; fieldId: number; recordId: number; xQBLErrorsAsSuccess?: boolean }) => Promise<any>;
                  /**
                   * Generate a document
                   * @param params - Parameters for the generateDocument operation
                   * @returns A promise resolving to the generateDocument response
                   */
                  generateDocument: (params: { templateId: number; tableId: string; recordId?: number; filename: string; accept?: string; format?: string; margin?: string; unit?: string; pageSize?: string; orientation?: string; realm?: string }) => Promise<GenerateDocument200Response>;
                }
            - name: >-
                missing-types-report.json
              type: >-
                file
        - name: >-
            index.ts
          type: >-
            file
        - name: >-
            quickbaseClient.ts
          type: >-
            file
          contents: >
            //
            src/quickbaseClient.ts

            import
            {
            QuickbaseClient
            as
            IQuickbaseClient
            }
            from
            "./generated-unified/QuickbaseClient";

            import
            {
            Configuration,
            HTTPHeaders,
            ResponseError
            }
            from
            "./generated/runtime";

            import
            *
            as
            apis
            from
            "./generated/apis";

            import
            {
            TokenCache
            }
            from
            "./tokenCache";

            import
            {
            simplifyName
            }
            from
            "./utils.ts";
            //
            Add
            this
            import


            //
            Re-export
            all
            model
            types
            from
            generated/models

            export
            *
            from
            "./generated/models/index";


            //
            Remove
            the
            local
            simplifyName
            function

            //
            (The
            rest
            of
            the
            file
            remains
            unchanged)


            export
            interface
            QuickbaseClient
            extends
            IQuickbaseClient
            {}


            export
            interface
            QuickbaseConfig
            {
              realm: string;
              userToken?: string;
              tempToken?: string;
              useTempTokens?: boolean;
              debug?: boolean;
              fetchApi?: typeof fetch;
            }


            export
            interface
            TempTokenParams
            {
              appId?: string;
              tableId?: string;
              dbid?: string;
            }


            type
            ApiMethod<K
            extends
            keyof
            QuickbaseClient>
            =
            (
              requestParameters: Parameters<QuickbaseClient[K]>[0],
              initOverrides?: RequestInit
            )
            =>
            Promise<ReturnType<QuickbaseClient[K]>>;


            interface
            MethodInfo<K
            extends
            keyof
            QuickbaseClient>
            {
              api: any;
              method: ApiMethod<K>;
              paramMap: string[];
            }


            type
            MethodMap
            =
            {
            [K
            in
            keyof
            QuickbaseClient]:
            MethodInfo<K>
            };


            const
            getParamNames
            =
            (fn:
            (...args:
            any[])
            =>
            any):
            string[]
            =>
              fn
                .toString()
                .slice(fn.toString().indexOf("(") + 1, fn.toString().indexOf(")"))
                .split(",")
                .map((p) => p.trim().split("=")[0].trim())
                .filter((p) => p && !p.match(/^\{/) && p !== "options");

            const
            extractDbid
            =
            (
              params: Partial<TempTokenParams>,
              errorMessage: string
            ):
            string
            =>
            {
              const dbid = params.dbid || params.tableId || params.appId;
              if (!dbid) {
                throw new Error(errorMessage);
              }
              return dbid;
            };


            export
            function
            quickbase(config:
            QuickbaseConfig):
            QuickbaseClient
            {
              const {
                realm,
                userToken,
                tempToken: initialTempToken,
                useTempTokens,
                fetchApi,
                debug,
              } = config;
              const baseUrl = `https://api.quickbase.com/v1`;

              const tokenCache = new TokenCache();

              const baseHeaders: HTTPHeaders = {
                "QB-Realm-Hostname": `${realm}.quickbase.com`,
                "Content-Type": "application/json",
              };

              if (initialTempToken) {
                baseHeaders["Authorization"] = `QB-TEMP-TOKEN ${initialTempToken}`;
              } else if (userToken && !useTempTokens) {
                baseHeaders["Authorization"] = `QB-USER-TOKEN ${userToken}`;
              }

              const defaultFetch: typeof fetch | undefined =
                typeof globalThis.window !== "undefined"
                  ? globalThis.window.fetch.bind(globalThis.window)
                  : undefined;
              const configuration = new Configuration({
                basePath: baseUrl,
                headers: { ...baseHeaders },
                fetchApi: fetchApi || defaultFetch,
                credentials: "omit", // Default to "omit" for all requests
              });

              if (!configuration.fetchApi && typeof globalThis.window === "undefined") {
                throw new Error(
                  "fetchApi must be provided in non-browser environments (e.g., Node.js)"
                );
              }

              const apiInstances = Object.fromEntries(
                Object.entries(apis)
                  .filter(([name]) => name.endsWith("Api"))
                  .map(([name, ApiClass]) => [
                    name.replace("Api", "").toLowerCase(),
                    new ApiClass(configuration),
                  ])
              );

              const methodMap = buildMethodMap();

              function buildMethodMap(): MethodMap {
                const methodMap: Partial<MethodMap> = {};
                const isValidMethod = (name: string) =>
                  !name.startsWith("_") &&
                  name !== "constructor" &&
                  !["Middleware", "Pre", "Post", "Raw"].some((s) => name.includes(s));

                for (const [apiName, api] of Object.entries(apiInstances)) {
                  Object.getOwnPropertyNames(Object.getPrototypeOf(api))
                    .filter(
                      (name) =>
                        isValidMethod(name) &&
                        typeof api[name as keyof typeof api] === "function"
                    )
                    .forEach((rawMethodName) => {
                      const simplifiedName = simplifyName(
                        rawMethodName
                      ) as keyof QuickbaseClient;
                      const method = api[rawMethodName as keyof typeof api];
                      const boundMethod = method.bind(api as any) as unknown;
                      if (typeof boundMethod === "function" && boundMethod.length <= 2) {
                        methodMap[simplifiedName] = {
                          api,
                          method: boundMethod as ApiMethod<typeof simplifiedName>,
                          paramMap: getParamNames(method),
                        };
                      }
                    });
                }
                return methodMap as MethodMap;
              }

              const fetchTempToken = async (dbid: string): Promise<string> => {
                const effectiveFetch = fetchApi || defaultFetch;
                if (!effectiveFetch) {
                  throw new Error(
                    "No fetch implementation available for fetching temp token"
                  );
                }

                const response = await effectiveFetch(
                  `https://api.quickbase.com/v1/auth/temporary/${dbid}`,
                  {
                    method: "GET",
                    headers: { ...baseHeaders },
                    credentials: "include", // Explicitly include credentials for token fetch
                  }
                );

                if (!response.ok) {
                  const errorBody: { message?: string } = await response.json();
                  throw new Error(
                    `API Error: ${errorBody.message || "Unknown error"} (Status: ${
                      response.status
                    })`
                  );
                }

                const tokenResult = await response.json();
                const token = tokenResult.temporaryAuthorization;
                if (!token) {
                  throw new Error("No temporary token returned from API");
                }
                tokenCache.set(dbid, token);
                if (debug) {
                  console.log(
                    `Fetched and cached new token for dbid: ${dbid}`,
                    token,
                    `Expires at: ${new Date(
                      Date.now() + (4 * 60 + 50) * 1000
                    ).toISOString()}`
                  );
                }
                return token;
              };

              async function invokeMethod<K extends keyof QuickbaseClient>(
                methodName: K,
                params: Parameters<QuickbaseClient[K]>[0] & Partial<TempTokenParams>,
                retryCount: number = 0
              ): Promise<ReturnType<QuickbaseClient[K]>> {
                const methodInfo = methodMap[methodName];
                if (!methodInfo) {
                  throw new Error(`Method ${methodName} not found`);
                }

                const requestParameters =
                  methodInfo.paramMap.length === 1 &&
                  methodInfo.paramMap[0] === "requestParameters"
                    ? { requestParameters: params }
                    : params;
                let requestOptions: RequestInit = {
                  credentials: "omit", // Explicitly set to "omit" for API calls
                };

                const selectedToken =
                  initialTempToken || (userToken && !useTempTokens ? userToken : undefined);

                if (methodName === "getTempTokenDBID" && useTempTokens) {
                  const dbid = extractDbid(params, "No dbid provided for getTempTokenDBID");
                  const cachedToken = tokenCache.get(dbid);
                  if (cachedToken) {
                    return { temporaryAuthorization: cachedToken } as ReturnType<
                      QuickbaseClient[K]
                    >;
                  }
                }

                let authorizationToken = selectedToken;
                if (useTempTokens && !authorizationToken) {
                  const dbid = extractDbid(
                    params,
                    `No dbid found in params for ${methodName} to fetch temp token`
                  );
                  const cachedToken = tokenCache.get(dbid);
                  authorizationToken = cachedToken || (await fetchTempToken(dbid));
                  if (methodName === "getTempTokenDBID") {
                    return { temporaryAuthorization: authorizationToken } as ReturnType<
                      QuickbaseClient[K]
                    >;
                  }
                  requestOptions.headers = {
                    ...baseHeaders,
                    Authorization: `QB-TEMP-TOKEN ${authorizationToken}`,
                  };
                } else if (authorizationToken) {
                  requestOptions.headers = {
                    ...baseHeaders,
                    Authorization: `QB-USER-TOKEN ${authorizationToken}`,
                  };
                }

                try {
                  return await methodInfo.method(requestParameters, requestOptions);
                } catch (error) {
                  if (
                    error instanceof ResponseError &&
                    error.response.status === 401 &&
                    retryCount < 1 &&
                    useTempTokens
                  ) {
                    if (debug) {
                      console.log(
                        `Authorization error for ${methodName}, refreshing token:`,
                        error.message
                      );
                    }
                    const dbid = extractDbid(
                      params,
                      `No dbid to refresh token after authorization error`
                    );
                    authorizationToken = await fetchTempToken(dbid);
                    requestOptions.headers = {
                      ...baseHeaders,
                      Authorization: `QB-TEMP-TOKEN ${authorizationToken}`,
                    };
                    if (debug) {
                      console.log(`Retrying ${methodName} with new token`);
                    }
                    return invokeMethod(methodName, params, retryCount + 1);
                  }
                  if (error instanceof ResponseError) {
                    let errorMessage = error.message;
                    try {
                      const errorBody: { message?: string } = await error.response.json();
                      if (debug) {
                        console.log(`Error response body for ${methodName}:`, errorBody);
                      }
                      errorMessage = errorBody.message || errorMessage;
                    } catch (e) {
                      // Silent fail on parse error
                    }
                    throw new Error(
                      `API Error: ${errorMessage} (Status: ${error.response.status})`
                    );
                  }
                  throw error;
                }
              }

              const proxy = new Proxy<QuickbaseClient>({} as QuickbaseClient, {
                get: (_, prop: string): ((params: any) => Promise<any>) | undefined => {
                  if (prop in methodMap) {
                    const methodName = prop as keyof QuickbaseClient;
                    return (params: Parameters<QuickbaseClient[typeof methodName]>[0]) =>
                      invokeMethod(methodName, params);
                  }
                  return undefined;
                },
              });

              return proxy;
            }
        - name: >-
            tokenCache.ts
          type: >-
            file
        - name: >-
            utils.ts
          type: >-
            file
    - name: >-
        test-artifacts
      type: >-
        directory
      children:
        - name: >-
            .last-run.json
          type: >-
            file
        - name: >-
            test-results.json
          type: >-
            file
    - name: >-
        test-esm.js
      type: >-
        file
    - name: >-
        test-results.json
      type: >-
        file
    - name: >-
        test-umd.js
      type: >-
        file
    - name: >-
        test.ts
      type: >-
        file
    - name: >-
        tests
      type: >-
        directory
      children:
        - name: >-
            playwright
          type: >-
            directory
          children:
            - name: >-
                qb
              type: >-
                directory
              children:
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        cacheSwitching.test.ts
                      type: >-
                        file
                    - name: >-
                        fetchTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithUserToken.test.ts
                      type: >-
                        file
                    - name: >-
                        getTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        tokenPrefetch.test.ts
                      type: >-
                        file
                    - name: >-
                        tokenRenewal.test.ts
                      type: >-
                        file
        - name: >-
            setup.ts
          type: >-
            file
        - name: >-
            vitest
          type: >-
            directory
          children:
            - name: >-
                qb
              type: >-
                directory
              children:
                - name: >-
                    apps
                  type: >-
                    directory
                  children:
                    - name: >-
                        copyApp.test.ts
                      type: >-
                        file
                    - name: >-
                        createApp.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getApp.test.ts
                      type: >-
                        file
                - name: >-
                    fields
                  type: >-
                    directory
                  children:
                    - name: >-
                        createField.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getField.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        getFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldsUsage.test.ts
                      type: >-
                        file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    records
                  type: >-
                    directory
                  children:
                    - name: >-
                        deleteRecords.test.ts
                      type: >-
                        file
                    - name: >-
                        runQuery.test.ts
                      type: >-
                        file
                    - name: >-
                        upsert.test.ts
                      type: >-
                        file
                - name: >-
                    tables
                  type: >-
                    directory
                  children:
                    - name: >-
                        createTable.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteTable.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppTables.test.ts
                      type: >-
                        file
                    - name: >-
                        getRelationships.test.ts
                      type: >-
                        file
                    - name: >-
                        getTable.test.ts
                      type: >-
                        file
                    - name: >-
                        updateTable.test.ts
                      type: >-
                        file
            - name: >-
                unit
              type: >-
                directory
              children:
                - name: >-
                    apps
                  type: >-
                    directory
                  children:
                    - name: >-
                        copyApp.test.ts
                      type: >-
                        file
                    - name: >-
                        createApp.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getApp.test.ts
                      type: >-
                        file
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        fetchTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        getTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        retryOn401.test.ts
                      type: >-
                        file
                    - name: >-
                        two401s.test.ts
                      type: >-
                        file
                - name: >-
                    fields
                  type: >-
                    directory
                  children:
                    - name: >-
                        createField.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getField.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        getFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldsUsage.test.ts
                      type: >-
                        file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    records
                  type: >-
                    directory
                  children:
                    - name: >-
                        deleteRecords.test.ts
                      type: >-
                        file
                    - name: >-
                        runQuery.test.ts
                      type: >-
                        file
                    - name: >-
                        upsert.test.ts
                      type: >-
                        file
                - name: >-
                    tables
                  type: >-
                    directory
                  children:
                    - name: >-
                        createTable.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteTable.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppTables.test.ts
                      type: >-
                        file
                    - name: >-
                        getRelationships.test.ts
                      type: >-
                        file
                    - name: >-
                        getTable.test.ts
                      type: >-
                        file
                    - name: >-
                        updateTable.test.ts
                      type: >-
                        file
                - name: >-
                    umd.test.ts
                  type: >-
                    file
    - name: >-
        text.txt
      type: >-
        file
    - name: >-
        tools
      type: >-
        directory
      children:
        - name: >-
            generate-types.ts
          type: >-
            file
        - name: >-
            log-gen.ts
          type: >-
            file
        - name: >-
            log-gen.yaml
          type: >-
            file
        - name: >-
            openapi-jars
          type: >-
            directory
          children:
            - name: >-
                openapi-generator-cli-7.12.0.jar
              type: >-
                file
        - name: >-
            openapi-schema-validator.ts
          type: >-
            file
        - name: >-
            spec-analyzer.ts
          type: >-
            file
        - name: >-
            split-spec.ts
          type: >-
            file
        - name: >-
            test-import.ts
          type: >-
            file
        - name: >-
            validate-spec.ts
          type: >-
            file
    - name: >-
        tsconfig.build.json
      type: >-
        file
    - name: >-
        tsconfig.json
      type: >-
        file
    - name: >-
        versionrc.json
      type: >-
        file
    - name: >-
        vitest.config.ts
      type: >-
        file

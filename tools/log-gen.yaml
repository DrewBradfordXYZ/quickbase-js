project: >-
  quickbase-js
date: >-
  5/28/2025
root: >-
  /home/drew/Projects/quickbase-js
goals:
  - >-
    A
    library
    for
    interacting
    with
    the
    QuickBase
    RESTful
    API.
  - >-
    Use
    OpenAPI
    to
    generate
    types
    and
    methods
    using
    a
    proxy.
    Validate
    with
    tests.
  - >-
    Provide
    robust
    and
    intuitive
    temporary
    token
    support
    for
    browser
    environments.
  - >-
    User
    Tokens
    support
    both
    Node.js
    and
    browser
    environments.
  - >-
    Use
    case:
    JS
    frameworks
    like
    React,
    Vue,
    and
    Angular
    hosted
    in
    QuickBase
    code
    pages.
  - >-
    Enable
    a
    flexible
    or
    native
    fetch
    in
    the
    browser.
  - >-
    Enable
    a
    flexible
    fetch
    framework
    in
    Node.js.
  - >-
    #
  - >-
    No
    manual
    updating
    methods
    when
    the
    QuickBase
    API
    changes.
  - >-
    The
    proxy
    magic
    dynamically
    maps
    generated
    methods
    and
    types.
  - >-
    #
  - >-
    TokenCache
    is
    defined
    per
    quickbaseClient
    call,
    so
    each
    instance
    has
    its
    own
    isolated
    TokenCache.
  - >-
    Each
    quickbase
    client
    instance
    has
    an
    isolated
    and
    individual
    token
    cache.
pipelineOverview:
  - >-
    What
    I’m
    Trying
    to
    Do
  - >-
    My
    approach
    is
    to
    ensure
    AppsApi.ts
    is
    generated
    with
    getAppById
    so
    QuickbaseClient.ts
    can
    map
    it
    to
    client.getApp.
    Steps
    include:
  - >-
    Fix
    fix-spec.ts:
  - >-
    Add
    tags:
    ["Apps"]
    to
    /apps/*
    endpoints
    to
    group
    them
    into
    AppsApi.ts.
  - >-
    Ensure
    all
    endpoints
    and
    models
    are
    correctly
    defined
    and
    typed.
  - >-
    Debug
    regenerate-client.ts:
  - >-
    Enhance
    logging
    to
    catch
    why
    AppsApi.ts
    isn’t
    generated.
  - >-
    Test
    if
    getAppById
    appears
    in
    another
    file
    (e.g.,
    DefaultApi.ts).
  - >-
    Update
    QuickbaseClient.ts:
  - >-
    Adjust
    imports
    to
    use
    the
    correct
    API
    class
    once
    generated.
  - >-
    Test
    and
    Iterate:
  - >-
    Run
    npm
    run
    fix-spec,
    npm
    run
    regenerate,
    and
    npm
    run
    test
    to
    verify
    AppsApi.ts
    exists
    and
    test.ts
    works.
  - >-
    The
    latest
    fix-spec.ts
    with
    tags
    aims
    to
    force
    the
    generator
    to
    create
    AppsApi.ts,
    addressing
    the
    missing
    file
    issue.
  - >-
    Relevant
    Project
    Files
  - >-
    Here’s
    a
    list
    of
    files
    that
    would
    help
    understand
    and
    resolve
    this
    problem,
    along
    with
    their
    roles:
  - >-
    src/code-generation/fix-spec.ts:
  - >-
    Role:
    Modifies
    the
    original
    QuickBase
    spec
    (e.g.,
    QuickBase_RESTful_*.json)
    to
    create
    quickbase-fixed.json
    with
    required
    endpoints
    (e.g.,
    /apps/{appId}).
  - >-
    Relevance:
    Defines
    the
    spec
    fed
    to
    the
    generator;
    errors
    here
    affect
    generation.
  - >-
    src/code-generation/quickbase-fixed.json:
  - >-
    Role:
    The
    processed
    OpenAPI
    spec
    used
    by
    regenerate-client.ts
    to
    generate
    code.
  - >-
    Relevance:
    Confirms
    if
    /apps/{appId}
    is
    correctly
    structured
    with
    operationId:
    "getAppById".
  - >-
    src/code-generation/regenerate-client.ts:
  - >-
    Role:
    Runs
    OpenAPI
    Generator
    to
    produce
    src/generated/
    files
    (APIs
    and
    models)
    and
    fixes
    .ts
    extensions
    with
    ts-morph.
  - >-
    Relevance:
    Controls
    the
    generation
    process;
    logs
    reveal
    why
    AppsApi.ts
    is
    missing.
  - >-
    src/generated/apis/AppsApi.ts
    (if
    exists):
  - >-
    Role:
    Should
    contain
    getAppById
    method
    for
    /apps/{appId}
    GET.
  - >-
    Relevance:
    Missing
    file
    is
    the
    core
    issue;
    its
    absence
    breaks
    QuickbaseClient.ts.
  - >-
    src/generated/apis/DefaultApi.ts:
  - >-
    Role:
    Default
    API
    class
    for
    untagged
    operations.
  - >-
    Relevance:
    Might
    contain
    getAppById
    if
    tags
    are
    misconfigured.
  - >-
    src/QuickbaseClient.ts:
  - >-
    Role:
    Wraps
    generated
    API
    classes
    (e.g.,
    AppsApi)
    in
    a
    Proxy
    for
    ergonomic
    calls
    (e.g.,
    client.getApp).
  - >-
    Relevance:
    Fails
    to
    import
    AppsApi.ts,
    causing
    the
    runtime
    error.
  - >-
    src/test.ts:
  - >-
    Role:
    Test
    script
    calling
    client.getApp({
    appId
    }).
  - >-
    Relevance:
    Final
    validation
    point;
    shows
    if
    the
    fix
    works.
  - >-
    .env.development:
  - >-
    Role:
    Stores
    QB_REALM,
    QB_USER_TOKEN,
    QB_APP_ID
    for
    API
    authentication.
  - >-
    Relevance:
    Ensures
    the
    API
    call
    has
    valid
    credentials
    (not
    the
    current
    issue,
    but
    critical
    for
    success).
  - >-
    src/specs/QuickBase_RESTful_API_2025-03-04T06_22_39.725Z.json
    (or
    similar):
  - >-
    Role:
    Original
    QuickBase
    API
    spec
    before
    fix-spec.ts
    processing.
  - >-
    Relevance:
    Shows
    how
    /apps/{appId}
    was
    originally
    defined,
    helping
    identify
    conflicts.
  - >-
    package.json:
  - >-
    Role:
    Defines
    scripts
    (fix-spec,
    regenerate,
    test)
    and
    dependencies
    (e.g.,
    ts-node,
    openapi-generator-cli).
  - >-
    Relevance:
    Confirms
    script
    commands
    and
    versions
    align
    with
    our
    process.
  - >-
    What
    We
    Achieved
  - >-
    Goal
    Met:
    You
    can
    now
    call
    client.getApp({
    appId:
    "buwai2zpe"
    })
    and
    get
    the
    app
    details
    {
    id:
    'buwai2zpe',
    name:
    'qb-copy'
    }.
  - >-
    Fixes
    Applied:
  - >-
    Added
    tags:
    ["Apps"]
    in
    fix-spec.ts
    to
    ensure
    AppsApi.ts
    is
    generated
    with
    getAppById.
  - >-
    Updated
    QuickbaseClient.ts
    to:
  - >-
    Use
    prototype
    methods
    via
    Object.getOwnPropertyNames.
  - >-
    Bind
    methods
    to
    preserve
    context
    with
    .bind(api).
  - >-
    Handle
    getAppById’s
    direct
    JSON
    return
    instead
    of
    a
    Response
    object.
  - >-
    Result:
    The
    ergonomic
    API
    you
    wanted
    (client.getApp)
    works
    seamlessly
    with
    the
    generated
    AppsApi.ts.
  - >-
    Why
    It
    Works
    Now
  - >-
    fix-spec.ts:
  - >-
    Correctly
    defined
    /apps/{appId}
    with
    operationId:
    "getAppById"
    and
    tags:
    ["Apps"],
    ensuring
    AppsApi.ts
    generation.
  - >-
    regenerate-client.ts:
  - >-
    Successfully
    ran
    OpenAPI
    Generator
    to
    produce
    AppsApi.ts
    with
    getAppById.
  - >-
    QuickbaseClient.ts:
  - >-
    buildMethodMap
    now
    captures
    getAppById
    and
    maps
    it
    to
    getApp.
  - >-
    invokeMethod
    passes
    {
    appId:
    'buwai2zpe'
    }
    as
    requestParameters
    and
    handles
    the
    JSON
    response
    directly.
  - >-
    test.ts:
  - >-
    Calls
    client.getApp
    and
    logs
    the
    result,
    proving
    the
    end-to-end
    flow.
tree:
  name: >-
    .
  type: >-
    directory
  children:
    - name: >-
        .env
      type: >-
        file
    - name: >-
        .gitignore
      type: >-
        file
    - name: >-
        CHANGELOG.md
      type: >-
        file
    - name: >-
        LICENSE
      type: >-
        file
    - name: >-
        README.md
      type: >-
        file
    - name: >-
        build-common.js
      type: >-
        file
    - name: >-
        build-esm.js
      type: >-
        file
    - name: >-
        build-umd.js
      type: >-
        file
    - name: >-
        dist
      type: >-
        directory
      children:
        - name: >-
            esm
          type: >-
            directory
          children:
            - name: >-
                quickbase.d.ts
              type: >-
                file
            - name: >-
                quickbase.js
              type: >-
                file
            - name: >-
                quickbase.js.map
              type: >-
                file
            - name: >-
                quickbase.min.js
              type: >-
                file
            - name: >-
                quickbase.min.js.map
              type: >-
                file
        - name: >-
            umd
          type: >-
            directory
          children:
            - name: >-
                quickbase.umd.js
              type: >-
                file
            - name: >-
                quickbase.umd.js.map
              type: >-
                file
            - name: >-
                quickbase.umd.min.js
              type: >-
                file
            - name: >-
                quickbase.umd.min.js.map
              type: >-
                file
    - name: >-
        docs
      type: >-
        directory
      children:
        - name: >-
            .vitepress
          type: >-
            directory
          children:
            - name: >-
                cache
              type: >-
                directory
              children:
                - name: >-
                    deps
                  type: >-
                    directory
                  children:
                    - name: >-
                        @theme_index.js
                      type: >-
                        file
                    - name: >-
                        @theme_index.js.map
                      type: >-
                        file
                    - name: >-
                        _metadata.json
                      type: >-
                        file
                    - name: >-
                        chunk-5A67QEFC.js
                      type: >-
                        file
                    - name: >-
                        chunk-5A67QEFC.js.map
                      type: >-
                        file
                    - name: >-
                        chunk-7D4P4MMP.js
                      type: >-
                        file
                    - name: >-
                        chunk-7D4P4MMP.js.map
                      type: >-
                        file
                    - name: >-
                        package.json
                      type: >-
                        file
                    - name: >-
                        vitepress___@vue_devtools-api.js
                      type: >-
                        file
                    - name: >-
                        vitepress___@vue_devtools-api.js.map
                      type: >-
                        file
                    - name: >-
                        vitepress___@vueuse_core.js
                      type: >-
                        file
                    - name: >-
                        vitepress___@vueuse_core.js.map
                      type: >-
                        file
                    - name: >-
                        vue.js
                      type: >-
                        file
                    - name: >-
                        vue.js.map
                      type: >-
                        file
            - name: >-
                config.mts
              type: >-
                file
            - name: >-
                dist
              type: >-
                directory
              children:
                - name: >-
                    404.html
                  type: >-
                    file
                - name: >-
                    api-examples.html
                  type: >-
                    file
                - name: >-
                    assets
                  type: >-
                    directory
                  children:
                    - name: >-
                        api-examples.md.CRRh3xeI.js
                      type: >-
                        file
                    - name: >-
                        api-examples.md.CRRh3xeI.lean.js
                      type: >-
                        file
                    - name: >-
                        app.Yv9tMCdR.js
                      type: >-
                        file
                    - name: >-
                        chunks
                      type: >-
                        directory
                      children:
                        - name: >-
                            framework.Dh1jimFm.js
                          type: >-
                            file
                        - name: >-
                            theme.CDm2W-g2.js
                          type: >-
                            file
                    - name: >-
                        index.md.kvvDM3Wd.js
                      type: >-
                        file
                    - name: >-
                        index.md.kvvDM3Wd.lean.js
                      type: >-
                        file
                    - name: >-
                        inter-italic-cyrillic-ext.r48I6akx.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-cyrillic.By2_1cv3.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-greek-ext.1u6EdAuj.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-greek.DJ8dCoTZ.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-latin-ext.CN1xVJS-.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-latin.C2AdPX0b.woff2
                      type: >-
                        file
                    - name: >-
                        inter-italic-vietnamese.BSbpV94h.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-cyrillic-ext.BBPuwvHQ.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-cyrillic.C5lxZ8CY.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-greek-ext.CqjqNYQ-.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-greek.BBVDIX6e.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-latin-ext.4ZJIpNVo.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-latin.Di8DUHzh.woff2
                      type: >-
                        file
                    - name: >-
                        inter-roman-vietnamese.BjW4sHH5.woff2
                      type: >-
                        file
                    - name: >-
                        markdown-examples.md.ediKJOVO.js
                      type: >-
                        file
                    - name: >-
                        markdown-examples.md.ediKJOVO.lean.js
                      type: >-
                        file
                    - name: >-
                        style.BJrZ0CFW.css
                      type: >-
                        file
                - name: >-
                    hashmap.json
                  type: >-
                    file
                - name: >-
                    index.html
                  type: >-
                    file
                - name: >-
                    markdown-examples.html
                  type: >-
                    file
                - name: >-
                    vp-icons.css
                  type: >-
                    file
        - name: >-
            api-examples.md
          type: >-
            file
        - name: >-
            index.md
          type: >-
            file
        - name: >-
            markdown-examples.md
          type: >-
            file
        - name: >-
            node_modules
          type: >-
            directory
          children: []
    - name: >-
        docs-data
      type: >-
        directory
      children:
        - name: >-
            api-docs.json
          type: >-
            file
    - name: >-
        index.md
      type: >-
        file
    - name: >-
        open-api
      type: >-
        directory
      children:
        - name: >-
            fix-generated.ts.bak
          type: >-
            file
        - name: >-
            fix-spec-main.ts
          type: >-
            file
        - name: >-
            generate-unified-interface.ts
          type: >-
            file
        - name: >-
            generateDocsJson.ts
          type: >-
            file
        - name: >-
            post-process-generated.ts
          type: >-
            file
        - name: >-
            regenerate-client.ts
          type: >-
            file
        - name: >-
            schema
          type: >-
            directory
          children:
            - name: >-
                enhance-general.ts
              type: >-
                file
            - name: >-
                fix-arrays.ts
              type: >-
                file
            - name: >-
                tags
              type: >-
                directory
              children:
                - name: >-
                    apps.ts
                  type: >-
                    file
                - name: >-
                    fields.ts
                  type: >-
                    file
                - name: >-
                    groups.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    records.ts
                  type: >-
                    file
                - name: >-
                    tables.ts
                  type: >-
                    file
                - name: >-
                    users.ts
                  type: >-
                    file
        - name: >-
            types
          type: >-
            directory
          children:
            - name: >-
                spec.ts
              type: >-
                file
        - name: >-
            utils
          type: >-
            directory
          children:
            - name: >-
                common.ts
              type: >-
                file
            - name: >-
                generateJsDoc.ts
              type: >-
                file
            - name: >-
                infer-schema.ts
              type: >-
                file
            - name: >-
                naming.ts
              type: >-
                file
            - name: >-
                sharedUtils.ts
              type: >-
                file
    - name: >-
        openapitools.json
      type: >-
        file
    - name: >-
        package-lock.json
      type: >-
        file
    - name: >-
        package.json
      type: >-
        file
    - name: >-
        playwright.config.ts
      type: >-
        file
    - name: >-
        rollup.config.js
      type: >-
        file
    - name: >-
        src
      type: >-
        directory
      children:
        - name: >-
            auth
          type: >-
            directory
          children:
            - name: >-
                SsoTokenStrategy.ts
              type: >-
                file
              contents: >
                import
                {
                AuthorizationStrategy
                }
                from
                "./types";


                export
                class
                SsoTokenStrategy
                implements
                AuthorizationStrategy
                {
                  private currentToken: string | undefined;
                  private pendingFetches: Map<string, Promise<string>> = new Map();

                  constructor(
                    private samlToken: string,
                    private realm: string,
                    private fetchApi: typeof fetch,
                    private debug: boolean = false,
                    private baseUrl: string = "https://api.quickbase.com/v1"
                  ) {}

                  async getToken(_dbid: string): Promise<string | undefined> {
                    if (!this.currentToken) {
                      if (this.pendingFetches.has("sso")) {
                        if (this.debug)
                          console.log("[getToken] Waiting for existing SSO fetch");
                        return this.pendingFetches.get("sso");
                      }
                      const fetchPromise = this.fetchSsoToken({
                        grant_type: "urn:ietf:params:oauth:grant-type:token-exchange",
                        requested_token_type:
                          "urn:quickbase:params:oauth:token-type:temp_token",
                        subject_token: this.samlToken,
                        subject_token_type: "urn:ietf:params:oauth:token-type:saml2",
                      }).finally(() => this.pendingFetches.delete("sso"));
                      this.pendingFetches.set("sso", fetchPromise);
                      this.currentToken = await fetchPromise;
                    }
                    return this.currentToken;
                  }

                  applyHeaders(headers: Record<string, string>, token: string): void {
                    headers["Authorization"] = `QB-TEMP-TOKEN ${token}`;
                  }

                  async handleError(
                    status: number,
                    _params: any,
                    attempt: number,
                    maxAttempts: number,
                    debug?: boolean,
                    methodName?: string
                  ): Promise<string | null> {
                    if (status !== 401 || attempt >= maxAttempts - 1) return null;

                    if (debug || this.debug) {
                      console.log(
                        `Authorization error for ${
                          methodName || "method"
                        } (SSO), refreshing token`
                      );
                    }

                    const newToken = await this.refreshSsoToken(debug || this.debug);
                    if (newToken) {
                      this.currentToken = newToken;
                      if (debug || this.debug)
                        console.log(
                          `[${
                            methodName || "method"
                          }] Retrying with token: ${newToken.substring(0, 10)}...`
                        );
                      return newToken;
                    }
                    return null;
                  }

                  private async refreshSsoToken(debug: boolean = false): Promise<string> {
                    const payload = {
                      grant_type: "urn:ietf:params:oauth:grant-type:token-exchange",
                      requested_token_type: "urn:quickbase:params:oauth:token-type:temp_token",
                      subject_token: this.samlToken,
                      subject_token_type: "urn:ietf:params:oauth:token-type:saml2",
                    };

                    const response = await this.fetchApi(`${this.baseUrl}/auth/oauth/token`, {
                      method: "POST",
                      headers: {
                        "QB-Realm-Hostname": `${this.realm}.quickbase.com`,
                        "Content-Type": "application/json",
                      },
                      body: JSON.stringify(payload),
                      credentials: "omit",
                    });

                    if (!response.ok) {
                      const errorBody = await response.json().catch(() => ({}));
                      if (debug) {
                        console.log(`[SSO Refresh] Failed: ${response.status}`, errorBody);
                      }
                      throw new Error(
                        `SSO token refresh failed: ${errorBody.message || "Unknown error"}`
                      );
                    }

                    const result = await response.json();
                    const newToken = result.access_token;
                    if (!newToken) {
                      throw new Error("No access token returned from SSO token exchange");
                    }

                    if (debug) {
                      console.log(`[SSO Refresh] New token: ${newToken.substring(0, 10)}...`);
                    }
                    return newToken;
                  }

                  private async fetchSsoToken(params: {
                    grant_type: string;
                    requested_token_type: string;
                    subject_token: string;
                    subject_token_type: string;
                  }): Promise<string> {
                    const response = await this.fetchApi(`${this.baseUrl}/auth/oauth/token`, {
                      method: "POST",
                      headers: {
                        "QB-Realm-Hostname": `${this.realm}.quickbase.com`,
                        "Content-Type": "application/json",
                      },
                      body: JSON.stringify(params),
                      credentials: "omit",
                    });

                    if (!response.ok) {
                      const errorBody = await response.json().catch(() => ({}));
                      if (this.debug) {
                        console.log(`[fetchSsoToken] Failed: ${response.status}`, errorBody);
                      }
                      throw new Error(
                        `SSO token fetch failed: ${errorBody.message || "Unknown error"}`
                      );
                    }

                    const result = await response.json();
                    const newToken = result.access_token;
                    if (!newToken) {
                      throw new Error("No access token returned from SSO token exchange");
                    }

                    if (this.debug) {
                      console.log(
                        `[fetchSsoToken] Fetched token: ${newToken.substring(0, 10)}...`
                      );
                    }
                    return newToken;
                  }
                }
            - name: >-
                TempTokenStrategy.ts
              type: >-
                file
              contents: >
                //
                src/auth/TempTokenStrategy.ts

                import
                {
                AuthorizationStrategy
                }
                from
                "./types";

                import
                {
                TokenCache
                }
                from
                "../cache/TokenCache";

                import
                {
                extractDbid
                }
                from
                "./utils";


                export
                class
                TempTokenStrategy
                implements
                AuthorizationStrategy
                {
                  private pendingFetches: Map<string, Promise<string>> = new Map();

                  constructor(
                    private tokenCache: TokenCache,
                    private initialTempToken: string | undefined,
                    private fetchApi: typeof fetch,
                    private realm: string,
                    private baseUrl: string = "https://api.quickbase.com/v1"
                  ) {}

                  async fetchTempToken(dbid: string): Promise<string> {
                    const headers = {
                      "QB-Realm-Hostname": `${this.realm}.quickbase.com`,
                      "Content-Type": "application/json",
                      "User-Agent":
                        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                      Origin: `https://${this.realm}.quickbase.com`,
                      Referer: `https://${this.realm}.quickbase.com`,
                    };
                    const response = await this.fetchApi(
                      `${this.baseUrl}/auth/temporary/${dbid}`,
                      {
                        method: "GET",
                        headers,
                        credentials: "include",
                      }
                    );

                    if (!response.ok) {
                      const errorBody = await response.json().catch(() => ({}));
                      const message = errorBody.message || "Unknown error";
                      throw new Error(`API Error: ${message} (Status: ${response.status})`);
                    }

                    const tokenResult = await response.json();
                    const token = tokenResult.temporaryAuthorization;
                    if (!token) {
                      throw new Error(
                        "API Error: No temporary token returned from API (Status: 200)"
                      );
                    }
                    this.tokenCache.set(dbid, token);
                    console.log(`Fetched and cached new token for dbid: ${dbid}`, token);
                    return token;
                  }

                  async getToken(dbid: string): Promise<string | undefined> {
                    const cachedEntry = this.tokenCache.get(dbid);
                    let token = cachedEntry ? cachedEntry.token : this.initialTempToken;
                    if (!token && dbid) {
                      if (this.pendingFetches.has(dbid)) {
                        console.log(`[getToken] Waiting for existing fetch for dbid: ${dbid}`);
                        return this.pendingFetches.get(dbid);
                      }
                      const fetchPromise = this.fetchTempToken(dbid).finally(() =>
                        this.pendingFetches.delete(dbid)
                      );
                      this.pendingFetches.set(dbid, fetchPromise);
                      token = await fetchPromise;
                    }
                    return token;
                  }

                  applyHeaders(headers: Record<string, string>, token: string): void {
                    headers["Authorization"] = `QB-TEMP-TOKEN ${token}`;
                  }

                  async handleError(
                    status: number,
                    params: any,
                    attempt: number,
                    maxAttempts: number,
                    debug?: boolean,
                    methodName?: string
                  ): Promise<string | null> {
                    if (status !== 401 || attempt >= maxAttempts - 1) return null;
                    if (debug)
                      console.log(
                        `Authorization error for ${
                          methodName || "method"
                        } (temp token), refreshing token:`
                      );
                    const dbid = extractDbid(params);
                    if (!dbid) {
                      if (debug)
                        console.log(
                          `No dbid available for ${
                            methodName || "method"
                          }, skipping token refresh`
                        );
                      return null;
                    }
                    if (debug) console.log(`Refreshing temp token for dbid: ${dbid}`);
                    this.tokenCache.delete(dbid);
                    try {
                      const newToken = await this.getToken(dbid);
                      if (newToken) {
                        this.tokenCache.set(dbid, newToken);
                        if (debug)
                          console.log(
                            `[${
                              methodName || "method"
                            }] Retrying with token: ${newToken.substring(0, 10)}...`
                          );
                        return newToken;
                      }
                      return null;
                    } catch (error) {
                      if (debug)
                        console.log(
                          `[${methodName || "method"}] Failed to refresh token:`,
                          error
                        );
                      throw error;
                    }
                  }
                }
            - name: >-
                TicketTokenStrategy.ts
              type: >-
                file
              contents: >
                //
                src/auth/TicketTokenStrategy.ts

                import
                {
                parseStringPromise
                }
                from
                "xml2js";

                import
                {
                  AuthorizationStrategy,
                  Credentials,
                  CredentialProvider,
                  TicketData,
                }
                from
                "./types";

                import
                {
                TokenCache
                }
                from
                "../cache/TokenCache";

                import
                {
                TicketCache
                }
                from
                "../cache/TicketCache";

                import
                {
                extractDbid
                }
                from
                "./utils";


                interface
                ApiError
                extends
                Error
                {
                  status?: number;
                  details?: any;
                }


                export
                class
                TicketTokenStrategy
                implements
                AuthorizationStrategy
                {
                  private pendingTicketFetch: Promise<TicketData> | null = null;
                  private pendingTokenFetches: Map<string, Promise<string>> = new Map();

                  constructor(
                    private credentials: Credentials,
                    private credentialProvider: CredentialProvider | undefined,
                    private realm: string,
                    private fetchApi: typeof fetch,
                    private tokenCache: TokenCache,
                    private ticketCache: TicketCache<TicketData>,
                    private debug: boolean = false,
                    private ticketLifespanHours: number = 12,
                    private ticketRefreshThreshold: number = 0.1,
                    private baseUrl: string = "https://api.quickbase.com/v1"
                  ) {
                    this.ticketLifespan = ticketLifespanHours * 60 * 60 * 1000;
                  }

                  private ticketLifespan: number;

                  private async getCredentials(): Promise<Credentials> {
                    if (this.credentialProvider) {
                      const creds = await this.credentialProvider();
                      if (this.debug) {
                        console.log("[TicketTokenStrategy] Fetched credentials via provider");
                      }
                      return creds;
                    }
                    if (this.debug) {
                      console.log("[TicketTokenStrategy] Using stored credentials");
                    }
                    return this.credentials;
                  }

                  private async fetchTicket(credentials: Credentials): Promise<TicketData> {
                    if (this.pendingTicketFetch) {
                      if (this.debug) {
                        console.log("[TicketTokenStrategy] Waiting for pending ticket fetch");
                      }
                      return this.pendingTicketFetch;
                    }

                    this.pendingTicketFetch = (async () => {
                      try {
                        const response = await this.fetchApi(
                          `https://${this.realm}.quickbase.com/db/main`,
                          {
                            method: "POST",
                            headers: {
                              "Content-Type": "application/xml",
                              Accept: "application/xml",
                              "QUICKBASE-ACTION": "API_Authenticate",
                              "QB-App-Token": credentials.appToken,
                              "QB-Realm-Hostname": `${this.realm}.quickbase.com`,
                              "User-Agent":
                                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                              Origin: `https://${this.realm}.quickbase.com`,
                              Referer: `https://${this.realm}.quickbase.com`,
                            },
                            body: `<?xml version="1.0" ?>
                              <qdbapi>
                                <username>${credentials.username}</username>
                                <password>${credentials.password}</password>
                                <hours>${this.ticketLifespanHours}</hours>
                                <udata>auth_request</udata>
                              </qdbapi>`,
                          }
                        );

                        if (!response.ok) {
                          const error: ApiError = new Error(
                            `API_Authenticate failed: ${response.status}`
                          );
                          error.status = response.status;
                          throw error;
                        }

                        const xml = await response.text();
                        const parsed = await parseStringPromise(xml);
                        const ticket = parsed.qdbapi.ticket?.[0];
                        const errcode = parsed.qdbapi.errcode?.[0];

                        if (errcode !== "0") {
                          const error: ApiError = new Error(
                            `API_Authenticate error: ${parsed.qdbapi.errtext?.[0] || "Unknown"}`
                          );
                          error.status = parseInt(errcode, 10);
                          throw error;
                        }

                        if (!ticket) {
                          throw new Error("No ticket returned from API_Authenticate");
                        }

                        const setCookies =
                          response.headers
                            .get("set-cookie")
                            ?.split(/,(?=\s*[^\s])/)
                            .map((c) => c.trim()) || [];
                        const cookies = setCookies
                          .filter((c) => c.includes("TICKET") || c.includes("luid"))
                          .map((c) => c.split(";")[0])
                          .join("; ");

                        const ticketData: TicketData = { ticket, cookies };

                        await this.ticketCache.set("ticket", ticketData, this.ticketLifespan);
                        if (this.debug) {
                          console.log(
                            `[TicketTokenStrategy] Fetched and cached ticket: ${ticket.substring(
                              0,
                              10
                            )}...`,
                            `Expires in: ${(this.ticketLifespan / 3600000).toFixed(2)} hours`
                          );
                        }

                        return ticketData;
                      } catch (error) {
                        if (this.debug) {
                          console.error("[TicketTokenStrategy] Ticket fetch failed:", error);
                        }
                        throw error;
                      } finally {
                        this.pendingTicketFetch = null;
                      }
                    })();

                    return this.pendingTicketFetch;
                  }

                  private async getTicket(): Promise<TicketData> {
                    const entry = await this.ticketCache.get("ticket");
                    const now = Date.now();

                    if (entry && entry.expiresAt > now) {
                      const timeLeft = entry.expiresAt - now;
                      const threshold = this.ticketLifespan * this.ticketRefreshThreshold;
                      if (timeLeft < threshold) {
                        if (this.debug) {
                          console.log(
                            `[TicketTokenStrategy] Ticket nearing expiration (${(
                              timeLeft / 60000
                            ).toFixed(2)} min left), refreshing`
                          );
                        }
                        await this.ticketCache.delete("ticket");
                        const credentials = await this.getCredentials();
                        return this.fetchTicket(credentials);
                      }
                      if (this.debug) {
                        console.log("[TicketTokenStrategy] Using cached ticket");
                      }
                      return entry.value;
                    }

                    await this.ticketCache.delete("ticket");
                    const credentials = await this.getCredentials();
                    return this.fetchTicket(credentials);
                  }

                  private async fetchTempToken(dbid: string): Promise<string> {
                    if (this.pendingTokenFetches.has(dbid)) {
                      if (this.debug) {
                        console.log(
                          `[TicketTokenStrategy] Waiting for pending token fetch for dbid: ${dbid}`
                        );
                      }
                      return this.pendingTokenFetches.get(dbid)!;
                    }

                    const fetchPromise = (async () => {
                      try {
                        const { ticket, cookies } = await this.getTicket();
                        const response = await this.fetchApi(
                          `${this.baseUrl}/auth/temporary/${dbid}`,
                          {
                            headers: {
                              "QB-Realm-Hostname": `${this.realm}.quickbase.com`,
                              "Content-Type": "application/json",
                              Authorization: `QB-TICKET ${ticket}`,
                              Cookie: cookies,
                              "User-Agent":
                                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                              Origin: `https://${this.realm}.quickbase.com`,
                              Referer: `https://${this.realm}.quickbase.com`,
                            },
                          }
                        );

                        if (!response.ok) {
                          const errorBody = await response.json().catch(() => ({}));
                          const error: ApiError = new Error(
                            `getTempTokenDBID failed: ${errorBody.message || response.status}`
                          );
                          error.status = response.status;
                          error.details = errorBody;
                          if (this.debug) {
                            console.error("[fetchTempToken] Error:", {
                              status: response.status,
                              errorBody,
                              dbid,
                              headers: {
                                "QB-Realm-Hostname": `${this.realm}.quickbase.com`,
                                Authorization: `QB-TICKET ${ticket.substring(0, 10)}...`,
                                Cookie: cookies.substring(0, 20) + "...",
                              },
                            });
                          }
                          throw error;
                        }

                        const json = await response.json();
                        const token = json.temporaryAuthorization;

                        if (!token) {
                          throw new Error("No temporary token returned from getTempTokenDBID");
                        }

                        this.tokenCache.set(dbid, token);
                        if (this.debug) {
                          console.log(
                            `[TicketTokenStrategy] Fetched temp token for dbid ${dbid}: ${token.substring(
                              0,
                              10
                            )}...`
                          );
                        }
                        return token;
                      } finally {
                        this.pendingTokenFetches.delete(dbid);
                      }
                    })();

                    this.pendingTokenFetches.set(dbid, fetchPromise);
                    return fetchPromise;
                  }

                  async getToken(dbid: string): Promise<string | undefined> {
                    if (!dbid) return undefined;
                    const cachedEntry = this.tokenCache.get(dbid);
                    if (cachedEntry) {
                      const now = Date.now();
                      const timeLeft = cachedEntry.expiresAt - now;
                      const threshold =
                        (this.tokenCache as any).tempTokenLifespan *
                        this.ticketRefreshThreshold;
                      if (timeLeft < threshold) {
                        if (this.debug) {
                          console.log(
                            `[TicketTokenStrategy] Token for dbid ${dbid} nearing expiration (${(
                              timeLeft / 60000
                            ).toFixed(2)} min left), refreshing`
                          );
                        }
                        this.tokenCache.delete(dbid);
                        return this.fetchTempToken(dbid);
                      }
                      if (this.debug) {
                        console.log(
                          `[TicketTokenStrategy] Using cached temp token for dbid ${dbid}`
                        );
                      }
                      return cachedEntry.token;
                    }
                    return this.fetchTempToken(dbid);
                  }

                  applyHeaders(headers: Record<string, string>, token: string): void {
                    headers["Authorization"] = `QB-TEMP-TOKEN ${token}`;
                  }

                  async handleError(
                    status: number,
                    params: any,
                    attempt: number,
                    maxAttempts: number,
                    debug?: boolean,
                    methodName?: string
                  ): Promise<string | null> {
                    if (![401, 429].includes(status)) {
                      if (debug || this.debug) {
                        console.error(
                          `[TicketTokenStrategy] Non-retryable error for ${
                            methodName || "method"
                          }: Status ${status}`
                        );
                      }
                      return null;
                    }

                    if (attempt >= maxAttempts - 1) {
                      if (debug || this.debug) {
                        console.error(
                          `[TicketTokenStrategy] Exhausted retries (${maxAttempts}) for ${
                            methodName || "method"
                          }`
                        );
                      }
                      return null;
                    }

                    const dbid = extractDbid(params);
                    if (!dbid) {
                      if (debug || this.debug) {
                        console.log(
                          `[TicketTokenStrategy] No dbid available for ${
                            methodName || "method"
                          }, skipping token refresh`
                        );
                      }
                      return null;
                    }

                    if (debug || this.debug) {
                      console.log(
                        `[TicketTokenStrategy] Handling error ${status} for ${
                          methodName || "method"
                        }, attempt ${attempt + 1}/${maxAttempts}, dbid: ${dbid}`
                      );
                    }

                    try {
                      this.tokenCache.delete(dbid);
                      let newToken = await this.getToken(dbid);
                      if (newToken) {
                        if (debug || this.debug) {
                          console.log(
                            `[TicketTokenStrategy] Retrying ${
                              methodName || "method"
                            } with new token: ${newToken.substring(0, 10)}...`
                          );
                        }
                        return newToken;
                      }

                      if (debug || this.debug) {
                        console.log(
                          `[TicketTokenStrategy] Token refresh failed, attempting ticket refresh for ${
                            methodName || "method"
                          }`
                        );
                      }
                      await this.ticketCache.delete("ticket");
                      newToken = await this.getToken(dbid);
                      if (newToken) {
                        if (debug || this.debug) {
                          console.log(
                            `[TicketTokenStrategy] Retrying ${
                              methodName || "method"
                            } with token after ticket refresh: ${newToken.substring(0, 10)}...`
                          );
                        }
                        return newToken;
                      }

                      if (debug || this.debug) {
                        console.error(
                          `[TicketTokenStrategy] Failed to obtain new token after ticket refresh for ${
                            methodName || "method"
                          }`
                        );
                      }
                      return null;
                    } catch (error: any) {
                      if (debug || this.debug) {
                        console.error(
                          `[TicketTokenStrategy] Error during refresh for ${
                            methodName || "method"
                          }:`,
                          error.message || error
                        );
                      }
                      // Allow retry for 401 errors
                      if (error.status === 401) {
                        return null;
                      }
                      throw error;
                    }
                  }
                }
            - name: >-
                UserTokenStrategy.ts
              type: >-
                file
              contents: >
                import
                {
                AuthorizationStrategy
                }
                from
                "./types";


                export
                class
                UserTokenStrategy
                implements
                AuthorizationStrategy
                {
                  constructor(
                    private userToken: string,
                    private baseUrl: string = "https://api.quickbase.com/v1"
                  ) {}

                  async getToken(_dbid: string): Promise<string> {
                    return this.userToken;
                  }

                  applyHeaders(headers: Record<string, string>, token: string): void {
                    headers["Authorization"] = `QB-USER-TOKEN ${token}`;
                  }

                  async handleError(
                    status: number,
                    _params: any,
                    attempt: number,
                    maxAttempts: number,
                    debug?: boolean,
                    methodName?: string
                  ): Promise<string | null> {
                    if (status !== 401 || attempt >= maxAttempts - 1) return null;
                    if (debug)
                      console.log(
                        `Retrying ${
                          methodName || "method"
                        } with existing user token: ${this.userToken.substring(0, 10)}...`
                      );
                    return this.userToken;
                  }
                }
            - name: >-
                index.ts
              type: >-
                file
              contents: >
                export
                *
                from
                "./types";

                export
                *
                from
                "./utils";

                export
                *
                from
                "./TempTokenStrategy";

                export
                *
                from
                "./UserTokenStrategy";

                export
                *
                from
                "./SsoTokenStrategy";

                export
                *
                from
                "./TicketTokenStrategy";
            - name: >-
                types.ts
              type: >-
                file
              contents: >
                import
                {
                TokenCache
                }
                from
                "../cache/TokenCache";

                import
                {
                TicketCache
                }
                from
                "../cache/TicketCache";


                export
                interface
                AuthorizationStrategy
                {
                  getToken(dbid: string): Promise<string | undefined>;
                  applyHeaders(headers: Record<string, string>, token: string): void;
                  handleError(
                    status: number,
                    params: any,
                    attempt: number,
                    maxAttempts: number,
                    debug?: boolean,
                    methodName?: string
                  ): Promise<string | null>;
                }


                export
                interface
                Credentials
                {
                  username: string;
                  password: string;
                  appToken: string;
                }


                export
                type
                CredentialProvider
                =
                ()
                =>
                Promise<Credentials>
                |
                Credentials;


                export
                interface
                TicketData
                {
                  ticket: string;
                  cookies: string;
                }
            - name: >-
                utils.ts
              type: >-
                file
              contents: >
                export
                function
                extractDbid(params:
                any):
                string
                |
                undefined
                {
                  return (
                    params.dbid ||
                    params.tableId ||
                    params.appId ||
                    params.body?.from ||
                    params.body?.to
                  );
                }
        - name: >-
            cache
          type: >-
            directory
          children:
            - name: >-
                TicketCache.ts
              type: >-
                file
              contents: >
                //
                src/TicketCache.ts


                interface
                TicketCacheEntry<T>
                {
                  value: T;
                  expiresAt: number;
                }


                interface
                TicketCache<T>
                {
                  get(
                    key: string
                  ): Promise<TicketCacheEntry<T> | undefined> | TicketCacheEntry<T> | undefined;
                  set(key: string, value: T, lifespan: number): Promise<void> | void;
                  delete(key: string): Promise<void> | void;
                  clear(): Promise<void> | void;
                }


                class
                LocalStorageTicketCache<T>
                implements
                TicketCache<T>
                {
                  private prefix: string;

                  constructor(prefix = "quickbase-ticket") {
                    this.prefix = prefix;
                  }

                  private getKey(key: string): string {
                    return `${this.prefix}:${key}`;
                  }

                  get(key: string): TicketCacheEntry<T> | undefined {
                    if (typeof window === "undefined" || !window.localStorage) {
                      throw new Error("localStorage is not available");
                    }
                    const raw = window.localStorage.getItem(this.getKey(key));
                    if (!raw) return undefined;
                    try {
                      const entry: TicketCacheEntry<T> = JSON.parse(raw);
                      if (entry.expiresAt > Date.now()) {
                        return entry;
                      }
                      this.delete(key);
                      return undefined;
                    } catch {
                      return undefined;
                    }
                  }

                  set(key: string, value: T, lifespan: number): void {
                    if (typeof window === "undefined" || !window.localStorage) {
                      throw new Error("localStorage is not available");
                    }
                    const entry: TicketCacheEntry<T> = {
                      value,
                      expiresAt: Date.now() + lifespan,
                    };
                    window.localStorage.setItem(this.getKey(key), JSON.stringify(entry));
                  }

                  delete(key: string): void {
                    if (typeof window === "undefined" || !window.localStorage) {
                      return;
                    }
                    window.localStorage.removeItem(this.getKey(key));
                  }

                  clear(): void {
                    if (typeof window === "undefined" || !window.localStorage) {
                      return;
                    }
                    const keys = Object.keys(window.localStorage).filter((k) =>
                      k.startsWith(this.prefix)
                    );
                    keys.forEach((k) => window.localStorage.removeItem(k));
                  }
                }


                class
                InMemoryCache<T>
                implements
                TicketCache<T>
                {
                  private cache: Map<string, TicketCacheEntry<T>> = new Map();

                  get(key: string): TicketCacheEntry<T> | undefined {
                    const entry = this.cache.get(key);
                    if (entry && entry.expiresAt > Date.now()) {
                      return entry;
                    }
                    this.cache.delete(key);
                    return undefined;
                  }

                  set(key: string, value: T, lifespan: number): void {
                    this.cache.set(key, {
                      value,
                      expiresAt: Date.now() + lifespan,
                    });
                  }

                  delete(key: string): void {
                    this.cache.delete(key);
                  }

                  clear(): void {
                    this.cache.clear();
                  }
                }


                export
                {
                  TicketCache,
                  TicketCacheEntry,
                  LocalStorageTicketCache,
                  InMemoryCache,
                };
            - name: >-
                TokenCache.ts
              type: >-
                file
              contents: >
                //
                src/cache/TokenCache.ts


                interface
                CachedToken
                {
                  token: string;
                  expiresAt: number;
                }


                export
                class
                TokenCache
                {
                  private cache: Map<string, CachedToken>;
                  private readonly tempTokenLifespan: number;

                  constructor(tempTokenLifespan: number = 4 * 60 * 1000 + 50 * 1000) {
                    this.cache = new Map<string, CachedToken>();
                    this.tempTokenLifespan = tempTokenLifespan;
                  }

                  get(dbid: string): CachedToken | undefined {
                    const entry = this.cache.get(dbid);
                    const now = Date.now();
                    if (entry && entry.expiresAt > now) return entry;
                    if (entry) this.cache.delete(dbid);
                    return undefined;
                  }

                  set(dbid: string, token: string, lifespan?: number): void {
                    const now = Date.now();
                    this.cache.set(dbid, {
                      token,
                      expiresAt: now + (lifespan || this.tempTokenLifespan),
                    });
                  }

                  delete(dbid: string): void {
                    this.cache.delete(dbid);
                  }

                  clear(): void {
                    this.cache.clear();
                  }
                }
            - name: >-
                index.ts
              type: >-
                file
              contents: >
                export
                *
                from
                "./TicketCache";

                export
                *
                from
                "./TokenCache";
                //
                Updated
                from
                ./tokenCache
        - name: >-
            client
          type: >-
            directory
          children:
            - name: >-
                index.ts
              type: >-
                file
              contents: >
                export
                *
                from
                "./quickbaseClient.ts";
            - name: >-
                invokeMethod.ts
              type: >-
                file
              contents: >
                import
                {
                AuthorizationStrategy
                }
                from
                "../auth/types";

                import
                {
                extractDbid
                }
                from
                "../auth/utils";

                import
                {
                RateLimiter
                }
                from
                "../rate-limiting/rateLimiter";

                import
                {
                RateLimitError
                }
                from
                "../rate-limiting/RateLimitError";

                import
                {
                ResponseError
                }
                from
                "../generated/runtime";

                import
                {
                QuickbaseClient
                }
                from
                "./quickbaseClient";

                import
                {
                paginateRecords,
                isPaginatable
                }
                from
                "./pagination";


                export
                type
                ApiMethod<K
                extends
                keyof
                QuickbaseClient>
                =
                (
                  requestParameters: Parameters<QuickbaseClient[K]>[0],
                  initOverrides?: RequestInit
                )
                =>
                Promise<ReturnType<QuickbaseClient[K]>>;


                export
                interface
                MethodInfo<K
                extends
                keyof
                QuickbaseClient>
                {
                  api: any;
                  method: ApiMethod<K>;
                  paramMap: string[];
                  httpMethod: string;
                }


                export
                async
                function
                invokeMethod<K
                extends
                keyof
                QuickbaseClient>(
                  methodName: K,
                  params: Parameters<QuickbaseClient[K]>[0] & {
                    dbid?: string;
                    tableId?: string;
                    appId?: string;
                    startTime?: number;
                    skip?: number;
                    top?: number;
                  },
                  methodMap: { [P in keyof QuickbaseClient]: MethodInfo<P> },
                  baseHeaders: Record<string, string>,
                  authStrategy: AuthorizationStrategy,
                  rateLimiter: RateLimiter,
                  transformDates: (obj: any, convertStringsToDates: boolean) => any,
                  debug: boolean | undefined,
                  convertDates: boolean,
                  autoPaginate: boolean = true,
                  attempt: number = 0,
                  maxAttempts: number = rateLimiter.maxRetries + 1,
                  isPaginating: boolean = false,
                  paginationLimit: number | null = null
                ):
                Promise<ReturnType<QuickbaseClient[K]>>
                {
                  const methodInfo = methodMap[methodName];
                  if (!methodInfo) throw new Error(`Method ${methodName} not found`);

                  const hasBody = "body" in params && params.body !== undefined;
                  const body = hasBody ? params.body : undefined;
                  const options =
                    hasBody && body && typeof body === "object" && "options" in body
                      ? (body as any).options
                      : undefined;
                  const adjustedParams = {
                    ...(params as object),
                    skip:
                      params.skip ?? (options && "skip" in options ? options.skip : undefined),
                    top: params.top ?? (options && "top" in options ? options.top : undefined),
                  };

                  const restParams: any = hasBody
                    ? Object.fromEntries(
                        Object.entries(adjustedParams).filter(
                          ([key]) => key !== "body" && key !== "startTime"
                        )
                      )
                    : { ...adjustedParams, startTime: undefined };
                  const requestParameters: any = {
                    ...restParams,
                    ...(hasBody ? { generated: body } : {}),
                  };

                  const requestOptions: RequestInit = {
                    credentials: methodName === "getTempTokenDBID" ? "include" : "omit",
                    method: methodInfo.httpMethod,
                  };

                  let dbid: string | undefined = extractDbid(params);
                  let token = dbid
                    ? await authStrategy.getToken(dbid)
                    : await authStrategy.getToken("");

                  if (token) {
                    authStrategy.applyHeaders(baseHeaders, token);
                    requestOptions.headers = { ...baseHeaders };
                    if (methodName === "getTempTokenDBID") {
                      return { temporaryAuthorization: token } as ReturnType<
                        QuickbaseClient[K]
                      >;
                    }
                  }

                  async function processResponse(
                    rawResponse: any
                  ): Promise<ReturnType<QuickbaseClient[K]>> {
                    if (rawResponse instanceof Response) {
                      const contentType = rawResponse.headers
                        .get("Content-Type")
                        ?.toLowerCase();
                      if (contentType?.includes("application/json")) {
                        const jsonResponse = await rawResponse.json();
                        if (autoPaginate && !isPaginating && isPaginatable(jsonResponse)) {
                          if (debug)
                            console.log(
                              "[invokeMethod] Entering pagination with params:",
                              adjustedParams
                            );
                          return paginateRecords(
                            methodName,
                            adjustedParams,
                            methodMap,
                            baseHeaders,
                            authStrategy,
                            rateLimiter,
                            transformDates,
                            debug,
                            convertDates,
                            jsonResponse,
                            paginationLimit
                          );
                        }
                        return transformDates(jsonResponse, convertDates) as ReturnType<
                          QuickbaseClient[K]
                        >;
                      }
                      return rawResponse as ReturnType<QuickbaseClient[K]>;
                    }
                    if (rawResponse && typeof rawResponse.value === "function") {
                      const response = await rawResponse.value();
                      if (autoPaginate && !isPaginating && isPaginatable(response)) {
                        if (debug)
                          console.log(
                            "[invokeMethod] Entering pagination with params:",
                            adjustedParams
                          );
                        return paginateRecords(
                          methodName,
                          adjustedParams,
                          methodMap,
                          baseHeaders,
                          authStrategy,
                          rateLimiter,
                          transformDates,
                          debug,
                          convertDates,
                          response,
                          paginationLimit
                        );
                      }
                      return transformDates(response, convertDates) as ReturnType<
                        QuickbaseClient[K]
                      >;
                    }
                    return transformDates(rawResponse, convertDates) as ReturnType<
                      QuickbaseClient[K]
                    >;
                  }

                  async function parseErrorResponse(
                    response: Response
                  ): Promise<{ message: string; status: number }> {
                    let message = "Unknown error";
                    let status = response.status || 500;
                    try {
                      const contentType =
                        response.headers?.get("Content-Type")?.toLowerCase() ||
                        "application/json";
                      if (
                        contentType.includes("application/json") &&
                        typeof response.json === "function"
                      ) {
                        const errorBody = await response.json();
                        message = errorBody.message || "Invalid error response format";
                      } else if (typeof response.text === "function") {
                        message = (await response.text()) || message;
                      }
                    } catch (e) {
                      message = "Failed to parse error response";
                    }
                    return { message, status };
                  }

                  while (attempt < maxAttempts) {
                    let acquired = false;
                    try {
                      await rateLimiter.throttle();
                      acquired = true;
                      const postThrottleTime = Date.now();
                      if (params.startTime !== undefined) params.startTime = postThrottleTime;
                      const headers = { ...baseHeaders };
                      const finalRequest = { ...requestParameters, headers };
                      if (debug) console.log("[invokeMethod] Sending request:", finalRequest);
                      const responsePromise = methodInfo.method(finalRequest, {
                        ...requestOptions,
                        headers,
                      });
                      rateLimiter.release();
                      const response = await responsePromise;
                      if (debug) console.log("[invokeMethod] Received response:", response);
                      return await processResponse(response);
                    } catch (error: unknown) {
                      if (acquired) rateLimiter.release();
                      if (debug) console.log("[invokeMethod] Caught error:", error);
                      let status: number;
                      let message: string;
                      let response: Response | undefined;

                      if (error instanceof ResponseError && error.response) {
                        response = error.response;
                        ({ message, status } = await parseErrorResponse(response));
                      } else if (error instanceof Response) {
                        response = error;
                        ({ message, status } = await parseErrorResponse(response));
                      } else {
                        throw error;
                      }

                      if (status === 429) {
                        if (!(error instanceof ResponseError)) {
                          throw new Error("Expected ResponseError for 429 handling");
                        }
                        const delay = await rateLimiter.handle429(error, attempt + 1);
                        if (attempt + 1 === maxAttempts) {
                          throw new RateLimitError(
                            `API Error: ${message} (Status: ${status})`,
                            status,
                            response?.headers.get("Retry-After")
                              ? parseInt(response.headers.get("Retry-After")!, 10)
                              : undefined
                          );
                        }
                        await new Promise((resolve) => setTimeout(resolve, delay));
                        attempt++;
                        continue;
                      }

                      let newToken: string | null;
                      try {
                        newToken = await authStrategy.handleError(
                          status,
                          params,
                          attempt,
                          maxAttempts,
                          debug,
                          methodName
                        );
                      } catch (authError) {
                        throw authError;
                      }

                      if (newToken !== null) {
                        token = newToken;
                        authStrategy.applyHeaders(baseHeaders, token);
                        requestOptions.headers = { ...baseHeaders };
                        attempt++;
                        continue;
                      }

                      throw new Error(`API Error: ${message} (Status: ${status})`);
                    }
                  }
                  throw new Error(`API Error: Exhausted retries after ${maxAttempts} attempts`);
                }
            - name: >-
                pagination.ts
              type: >-
                file
              contents: >
                import
                {
                QuickbaseClient
                }
                from
                "./quickbaseClient";

                import
                {
                invokeMethod,
                MethodInfo
                }
                from
                "./invokeMethod";

                import
                {
                AuthorizationStrategy
                }
                from
                "../auth";

                import
                {
                RateLimiter
                }
                from
                "../rate-limiting/rateLimiter";


                /**
                 * Represents a paginated response from the Quick Base API.
                 * @template T - The type of items in the data array.
                 */
                interface
                PaginatedResponse<T>
                {
                  [key: string]: T[] | any;
                  fields?: { id: number; label: string; type: string }[];
                  metadata: {
                    totalRecords?: number;
                    numRecords?: number;
                    numFields?: number;
                    skip?: number;
                    top?: number;
                    nextPageToken?: string;
                    nextToken?: string;
                  };
                }


                /**
                 * Represents a request body that may include pagination options.
                 */
                interface
                BodyWithOptions
                {
                  body?: {
                    options?: {
                      sortBy?: Array<{ fieldId: number; order: "ASC" | "DESC" }>;
                      skip?: number;
                      top?: number;
                      nextPageToken?: string;
                      nextToken?: string;
                      [key: string]: any;
                    };
                    nextPageToken?: string;
                    nextToken?: string;
                    [key: string]: any;
                  };
                }


                /**
                 * Defines the continuation state for pagination, either skip-based or token-based.
                 */
                type
                PaginationContinuation
                =
                  | { type: "skip"; value: number }
                  | { type: "token"; value: string; key: "nextPageToken" | "nextToken" };

                /**
                 * Paginates records from a Quick Base API endpoint, handling both skip-based and token-based pagination.
                 * @template K - The method name keyof QuickbaseClient.
                 */
                export
                async
                function
                paginateRecords<K
                extends
                keyof
                QuickbaseClient>(
                  methodName: K,
                  params: Parameters<QuickbaseClient[K]>[0] & { skip?: number; top?: number },
                  methodMap: { [P in keyof QuickbaseClient]: MethodInfo<P> },
                  baseHeaders: Record<string, string>,
                  authStrategy: AuthorizationStrategy,
                  rateLimiter: RateLimiter,
                  transformDates: (obj: any, convertStringsToDates: boolean) => any,
                  debug: boolean | undefined,
                  convertDates: boolean,
                  initialResponse?: PaginatedResponse<any>,
                  paginationLimit: number | null = null
                ):
                Promise<ReturnType<QuickbaseClient[K]>>
                {
                  if (debug) console.log("[paginateRecords] Starting with params:", params);

                  const getDataKey = (response: PaginatedResponse<any>): string =>
                    Object.keys(response).find((key) => Array.isArray(response[key])) || "data";

                  const dataKey = initialResponse ? getDataKey(initialResponse) : "data";
                  let allRecords: any[] = initialResponse ? initialResponse[dataKey] : [];
                  let lastResponse: PaginatedResponse<any> | undefined = initialResponse;
                  let requestCount = 0;

                  const determinePaginationType = (
                    response: PaginatedResponse<any>
                  ): "skip" | "token" | "none" => {
                    if (
                      response.metadata.totalRecords !== undefined &&
                      response.metadata.skip !== undefined
                    ) {
                      if (debug)
                        console.log("[paginateRecords] Detected skip-based pagination");
                      return "skip";
                    }
                    if (
                      response.metadata.nextPageToken !== undefined ||
                      response.metadata.nextToken !== undefined
                    ) {
                      if (debug)
                        console.log("[paginateRecords] Detected token-based pagination");
                      return "token";
                    }
                    if (debug)
                      console.log(
                        "[paginateRecords] No clear pagination type detected, assuming single-page response"
                      );
                    return "none";
                  };

                  let paginationType: "skip" | "token" | "none" = initialResponse
                    ? determinePaginationType(initialResponse)
                    : "none";

                  let continuation: PaginationContinuation | null = initialResponse
                    ? paginationType === "skip"
                      ? {
                          type: "skip",
                          value:
                            (initialResponse.metadata.skip ?? 0) +
                            (initialResponse.metadata.numRecords || allRecords.length),
                        }
                      : paginationType === "token"
                      ? {
                          type: "token",
                          value:
                            initialResponse.metadata.nextPageToken ||
                            initialResponse.metadata.nextToken ||
                            "",
                          key:
                            initialResponse.metadata.nextPageToken !== undefined
                              ? "nextPageToken"
                              : "nextToken",
                        }
                      : null
                    : null;

                  if (debug) {
                    console.log("[paginateRecords] Initial state:", {
                      dataKey,
                      paginationType,
                      continuation,
                      hasInitialResponse: !!initialResponse,
                      totalRecordsSoFar: allRecords.length,
                      paginationLimit,
                    });
                    if (initialResponse && initialResponse[dataKey].length > 0) {
                      console.log(
                        "[paginateRecords] Initial response IDs: first:",
                        initialResponse[dataKey][0]["3"]?.value,
                        "last:",
                        initialResponse[dataKey][initialResponse[dataKey].length - 1]["3"]
                          ?.value
                      );
                    }
                  }

                  const fetchNextPage = async (
                    paginatedParams: any,
                    isInitial: boolean = false
                  ): Promise<PaginatedResponse<any>> => {
                    if (debug)
                      console.log("[paginateRecords] Fetching with params:", paginatedParams);
                    const response = await invokeMethod(
                      methodName,
                      paginatedParams,
                      methodMap,
                      baseHeaders,
                      authStrategy,
                      rateLimiter,
                      transformDates,
                      debug,
                      convertDates,
                      false, // autoPaginate handled by caller
                      0,
                      rateLimiter.maxRetries + 1,
                      !isInitial, // isPaginating: false for initial, true for subsequent
                      paginationLimit
                    );
                    requestCount++;
                    return response as PaginatedResponse<any>;
                  };

                  const getPaginatedParams = (): any => {
                    const hasBody = "body" in params && params.body !== undefined;
                    if (paginationType === "skip" && continuation?.type === "skip") {
                      const paginatedOptions = {
                        ...(hasBody && "options" in (params as BodyWithOptions).body!
                          ? (params as BodyWithOptions).body!.options
                          : {}),
                        skip: continuation.value,
                      };
                      return hasBody
                        ? {
                            ...(params as object),
                            body: {
                              ...((params as BodyWithOptions).body as object),
                              options: paginatedOptions,
                            },
                          }
                        : { ...(params as object), skip: continuation.value };
                    } else if (paginationType === "token" && continuation?.type === "token") {
                      if (continuation.value === "" && !lastResponse) {
                        return { ...(params as object) };
                      }
                      const tokenKey = continuation.key;
                      return hasBody
                        ? {
                            ...(params as object),
                            body: {
                              ...((params as BodyWithOptions).body as object),
                              [tokenKey]: continuation.value,
                            },
                          }
                        : { ...(params as object), [tokenKey]: continuation.value };
                    }
                    return { ...(params as object) };
                  };

                  if (!initialResponse) {
                    const firstParams = getPaginatedParams();
                    const firstResponse = await fetchNextPage(firstParams, true); // Initial call
                    const actualDataKey = getDataKey(firstResponse);
                    allRecords = firstResponse[actualDataKey];
                    lastResponse = firstResponse;
                    paginationType = determinePaginationType(firstResponse);
                    continuation =
                      paginationType === "skip"
                        ? {
                            type: "skip",
                            value:
                              (firstResponse.metadata.skip ?? 0) +
                              (firstResponse.metadata.numRecords || allRecords.length),
                          }
                        : paginationType === "token"
                        ? {
                            type: "token",
                            value:
                              firstResponse.metadata.nextPageToken ??
                              firstResponse.metadata.nextToken ??
                              "",
                            key:
                              firstResponse.metadata.nextPageToken !== undefined
                                ? "nextPageToken"
                                : "nextToken",
                          }
                        : null;
                  }

                  while (true) {
                    const hasMore =
                      (paginationType === "skip" &&
                        continuation?.type === "skip" &&
                        lastResponse!.metadata.totalRecords !== undefined &&
                        continuation.value < lastResponse!.metadata.totalRecords &&
                        allRecords.length < lastResponse!.metadata.totalRecords) ||
                      (paginationType === "token" &&
                        continuation?.type === "token" &&
                        continuation.value !== "");

                    if (paginationLimit !== null && allRecords.length >= paginationLimit) {
                      if (debug) {
                        console.log(
                          "[paginateRecords] Stopping: Reached pagination limit",
                          paginationLimit
                        );
                      }
                      break;
                    }

                    if (!hasMore) {
                      if (debug) {
                        console.log(
                          "[paginateRecords] Stopping:",
                          paginationType === "skip"
                            ? "All skip-based records fetched or no more data"
                            : paginationType === "token"
                            ? "Token exhausted"
                            : "No pagination required"
                        );
                      }
                      break;
                    }

                    const paginatedParams = getPaginatedParams();
                    const response = await fetchNextPage(paginatedParams);
                    const actualDataKey = getDataKey(response);

                    const remainingCapacity =
                      paginationLimit !== null ? paginationLimit - allRecords.length : Infinity;
                    const recordsToAdd = response[actualDataKey].slice(
                      0,
                      Math.min(remainingCapacity, response[actualDataKey].length)
                    );
                    allRecords = allRecords.concat(recordsToAdd);
                    lastResponse = response;

                    if (debug && response[actualDataKey].length > 0) {
                      console.log(
                        "[paginateRecords] Fetched records this iteration:",
                        recordsToAdd.length,
                        "IDs: first:",
                        recordsToAdd[0]["3"]?.value,
                        "last:",
                        recordsToAdd[recordsToAdd.length - 1]["3"]?.value,
                        "Continuation after fetch:",
                        continuation
                      );
                    }

                    if (paginationType === "skip") {
                      const newSkip =
                        continuation?.type === "skip"
                          ? continuation.value + response[actualDataKey].length
                          : (response.metadata.skip ?? 0) + response[actualDataKey].length;
                      continuation = { type: "skip", value: newSkip };
                      if (response[actualDataKey].length === 0) {
                        if (
                          debug &&
                          lastResponse!.metadata.totalRecords &&
                          newSkip < lastResponse!.metadata.totalRecords
                        ) {
                          console.warn(
                            "[paginateRecords] Warning: Empty response received but records remain",
                            { skip: newSkip, totalRecords: lastResponse!.metadata.totalRecords }
                          );
                        }
                        break;
                      }
                    } else if (paginationType === "token") {
                      const newToken =
                        response.metadata.nextPageToken ?? response.metadata.nextToken ?? "";
                      continuation = {
                        type: "token",
                        value: newToken,
                        key:
                          response.metadata.nextPageToken !== undefined
                            ? "nextPageToken"
                            : "nextToken",
                      };
                      if (continuation.value === "") {
                        break;
                      } else if (response[actualDataKey].length === 0 && newToken !== "") {
                        if (debug)
                          console.warn(
                            "[paginateRecords] Warning: Empty response with non-empty token, possible API inconsistency",
                            { token: newToken }
                          );
                      }
                    }
                  }

                  if (!lastResponse) {
                    throw new Error("[paginateRecords] No response received during pagination");
                  }

                  const finalDataKey = getDataKey(lastResponse);
                  const finalResponse: PaginatedResponse<any> = {
                    [finalDataKey]: allRecords,
                    fields: lastResponse.fields,
                    metadata: {
                      totalRecords:
                        paginationType === "skip"
                          ? lastResponse.metadata.totalRecords
                          : undefined,
                      numRecords: allRecords.length,
                      numFields: lastResponse.metadata.numFields,
                      skip: paginationType === "skip" ? 0 : undefined,
                      top: paginationType === "skip" ? undefined : undefined,
                      ...(paginationType === "token" &&
                      continuation?.type === "token" &&
                      continuation.key
                        ? { [continuation.key]: "" }
                        : {}),
                    },
                  };

                  if (debug) {
                    console.log("[paginateRecords] Final response summary:", {
                      totalRecords: finalResponse.metadata.totalRecords,
                      numRecords: finalResponse.metadata.numRecords,
                      numFields: finalResponse.metadata.numFields,
                      skip: finalResponse.metadata.skip,
                      top: finalResponse.metadata.top,
                      ...(paginationType === "token" &&
                      continuation?.type === "token" &&
                      continuation.key
                        ? { [continuation.key]: finalResponse.metadata[continuation.key] }
                        : {}),
                    });
                    console.log("[paginateRecords] Pagination stats:", {
                      totalRequests: requestCount,
                    });
                  }

                  return finalResponse as ReturnType<QuickbaseClient[K]>;
                }


                export
                function
                isPaginatable(
                  response: any
                ):
                response
                is
                PaginatedResponse<any>
                {
                  return (
                    response &&
                    typeof response === "object" &&
                    Object.keys(response).some((key) => Array.isArray(response[key])) &&
                    "metadata" in response &&
                    typeof response.metadata === "object" &&
                    (("totalRecords" in response.metadata &&
                      "numRecords" in response.metadata &&
                      "skip" in response.metadata) ||
                      "nextPageToken" in response.metadata ||
                      "nextToken" in response.metadata)
                  );
                }
            - name: >-
                quickbaseClient.ts
              type: >-
                file
              contents: >
                import
                {
                QuickbaseClient
                as
                IQuickbaseClient
                }
                from
                "../generated-unified/QuickbaseClient";

                import
                {
                Configuration,
                HTTPHeaders
                }
                from
                "../generated/runtime";

                import
                *
                as
                apis
                from
                "../generated/apis";

                import
                {
                TokenCache
                }
                from
                "../cache/TokenCache";

                import
                {
                  simplifyName,
                  getParamNames,
                  transformDates,
                  extractHttpMethod,
                }
                from
                "../utils";

                import
                {
                invokeMethod,
                MethodInfo
                }
                from
                "./invokeMethod";

                import
                {
                  TempTokenStrategy,
                  UserTokenStrategy,
                  AuthorizationStrategy,
                  SsoTokenStrategy,
                  TicketTokenStrategy,
                  CredentialProvider,
                  Credentials,
                }
                from
                "../auth";

                import
                {
                FlowThrottleBucket
                }
                from
                "../rate-limiting/FlowThrottleBucket";

                import
                {
                BurstAwareThrottleBucket
                }
                from
                "../rate-limiting/BurstAwareThrottleBucket";

                import
                {
                RateLimiter
                }
                from
                "../rate-limiting/rateLimiter";

                import
                {
                  TicketCache,
                  InMemoryCache,
                  LocalStorageTicketCache,
                }
                from
                "../cache/TicketCache";

                export
                *
                from
                "../generated/models/index";


                export
                interface
                QuickbaseClient
                extends
                IQuickbaseClient
                {
                  withPaginationDisabled<T>(callback: () => Promise<T>): Promise<T>;
                  withPaginationLimit<T>(limit: number, callback: () => Promise<T>): Promise<T>;
                }


                export
                interface
                QuickbaseConfig
                {
                  realm: string;
                  userToken?: string;
                  tempToken?: string;
                  credentials?: Credentials;
                  credentialProvider?: CredentialProvider;
                  useTempTokens?: boolean;
                  useSso?: boolean;
                  useTicketAuth?: boolean;
                  samlToken?: string;
                  debug?: boolean;
                  fetchApi?: typeof fetch;
                  convertDates?: boolean;
                  tempTokenLifespan?: number;
                  ticketLifespanHours?: number;
                  ticketRefreshThreshold?: number; // Renamed: Threshold for proactive token/ticket refresh (0 to 1)
                  throttle?: {
                    type?: "flow" | "burst-aware";
                    rate?: number;
                    burst?: number;
                    windowSeconds?: number;
                  };
                  maxRetries?: number;
                  retryDelay?: number;
                  tokenCache?: TokenCache;
                  ticketCache?: TicketCache<TicketData>;
                  baseUrl?: string;
                  autoPaginate?: boolean;
                }


                export
                type
                ThrottleOptions
                =
                {
                  type?: "flow" | "burst-aware";
                  rate?: number;
                  burst?: number;
                  windowSeconds?: number;
                };


                interface
                TicketData
                {
                  ticket: string;
                  cookies: string;
                }


                type
                MethodMap
                =
                {
                  [K in keyof QuickbaseClient]: MethodInfo<K>;
                };


                export
                function
                quickbase(config:
                QuickbaseConfig):
                QuickbaseClient
                {
                  const {
                    realm,
                    userToken,
                    tempToken,
                    credentials,
                    credentialProvider,
                    useTempTokens = false,
                    useSso = false,
                    useTicketAuth = false,
                    samlToken,
                    fetchApi,
                    debug = false,
                    convertDates = true,
                    tempTokenLifespan = 290000,
                    ticketLifespanHours = 12,
                    ticketRefreshThreshold = 0.1, // Renamed: Default to 10% of lifespan
                    throttle = { type: "flow", rate: 5, burst: 50 },
                    maxRetries = 3,
                    retryDelay = 1000,
                    tokenCache: providedTokenCache,
                    ticketCache: providedTicketCache,
                    baseUrl = "https://api.quickbase.com/v1",
                    autoPaginate = true,
                  } = config;

                  // Validate required config
                  if (!realm) {
                    throw new Error("QuickbaseConfig must include a valid 'realm'");
                  }
                  if (useTicketAuth && !credentials && !credentialProvider) {
                    throw new Error(
                      "Ticket authentication requires 'credentials' or 'credentialProvider'"
                    );
                  }
                  if (useSso && !samlToken) {
                    throw new Error("SSO authentication requires a 'samlToken'");
                  }
                  if (!useTicketAuth && !useSso && !useTempTokens && !userToken) {
                    throw new Error(
                      "At least one authentication method must be provided (userToken, useTempTokens, useSso, or useTicketAuth)"
                    );
                  }

                  const tokenCache = providedTokenCache || new TokenCache(tempTokenLifespan);
                  const ticketCache =
                    providedTicketCache ||
                    (typeof window !== "undefined" && window.localStorage
                      ? new LocalStorageTicketCache<TicketData>()
                      : new InMemoryCache<TicketData>());

                  const throttleOptions = throttle as ThrottleOptions;
                  const throttleBucket =
                    throttleOptions.type === "burst-aware"
                      ? new BurstAwareThrottleBucket({
                          maxTokens: throttleOptions.burst || 100,
                          windowSeconds: throttleOptions.windowSeconds || 10,
                        })
                      : new FlowThrottleBucket(
                          throttleOptions.rate || 5,
                          throttleOptions.burst || 50
                        );

                  const rateLimiter = new RateLimiter(throttleBucket, maxRetries, retryDelay);

                  const defaultFetch: typeof fetch =
                    globalThis.fetch || globalThis.window?.fetch?.bind(globalThis.window);
                  if (!defaultFetch && !fetchApi) {
                    throw new Error(
                      "No fetch implementation available. Please provide fetchApi in a Node.js environment without native fetch."
                    );
                  }
                  const effectiveFetch = fetchApi || defaultFetch;

                  // Set up authentication strategy
                  let authStrategy: AuthorizationStrategy;
                  if (useSso) {
                    authStrategy = new SsoTokenStrategy(
                      samlToken!,
                      realm,
                      effectiveFetch,
                      debug,
                      baseUrl
                    );
                  } else if (useTicketAuth) {
                    authStrategy = new TicketTokenStrategy(
                      credentials || { username: "", password: "", appToken: "" },
                      credentialProvider,
                      realm,
                      effectiveFetch,
                      tokenCache,
                      ticketCache,
                      debug,
                      ticketLifespanHours,
                      ticketRefreshThreshold, // Renamed: Pass ticketRefreshThreshold
                      baseUrl
                    );
                  } else if (useTempTokens) {
                    authStrategy = new TempTokenStrategy(
                      tokenCache,
                      tempToken,
                      effectiveFetch,
                      realm,
                      baseUrl
                    );
                  } else {
                    authStrategy = new UserTokenStrategy(userToken || "", baseUrl);
                  }

                  if (debug) {
                    console.log(
                      "[quickbase] Selected auth strategy:",
                      authStrategy.constructor.name
                    );
                  }

                  const baseHeaders: HTTPHeaders = {
                    "QB-Realm-Hostname": `${realm}.quickbase.com`,
                    "Content-Type": "application/json",
                  };

                  const configuration = new Configuration({
                    basePath: baseUrl,
                    headers: { ...baseHeaders },
                    fetchApi: effectiveFetch,
                    credentials: "omit",
                  });

                  const apiInstances = Object.fromEntries(
                    Object.entries(apis)
                      .filter(([name]) => name.endsWith("Api"))
                      .map(([name, ApiClass]) => [
                        name.replace("Api", "").toLowerCase(),
                        new ApiClass(configuration),
                      ])
                  );

                  function buildMethodMap(): MethodMap {
                    const methodMap: Partial<MethodMap> = {};
                    const isValidMethod = (name: string) =>
                      !name.startsWith("_") &&
                      name !== "constructor" &&
                      !["Middleware", "Pre", "Post", "Raw"].some((s) => name.includes(s));

                    for (const [apiName, api] of Object.entries(apiInstances)) {
                      Object.getOwnPropertyNames(Object.getPrototypeOf(api))
                        .filter(
                          (name) =>
                            isValidMethod(name) &&
                            typeof api[name as keyof typeof api] === "function"
                        )
                        .forEach((rawMethodName) => {
                          const simplifiedName = simplifyName(
                            rawMethodName
                          ) as keyof QuickbaseClient;
                          const rawMethodKey = `${rawMethodName}Raw` as keyof typeof api;
                          const method =
                            api[rawMethodKey] || api[rawMethodName as keyof typeof api];
                          const boundMethod = method.bind(api as any) as unknown;
                          if (typeof boundMethod === "function" && boundMethod.length <= 2) {
                            const httpMethod = extractHttpMethod(method);
                            methodMap[simplifiedName] = {
                              api,
                              method: boundMethod as any,
                              paramMap: getParamNames(method),
                              httpMethod,
                            };
                          }
                        });
                    }
                    if (debug) {
                      console.log("[buildMethodMap] Methods:", Object.keys(methodMap));
                    }
                    return methodMap as MethodMap;
                  }

                  const methodMap = buildMethodMap();

                  let currentAutoPaginate = autoPaginate;
                  let paginationLimit: number | null = null;

                  const proxyHandler: globalThis.ProxyHandler<QuickbaseClient> = {
                    get: (_: QuickbaseClient, prop: string) => {
                      if (debug) {
                        console.log(
                          "[proxy] Accessing:",
                          prop,
                          "in methodMap:",
                          prop in methodMap
                        );
                      }
                      if (prop === "withPaginationDisabled") {
                        return async <T>(callback: () => Promise<T>): Promise<T> => {
                          const originalAutoPaginate = currentAutoPaginate;
                          currentAutoPaginate = false;
                          try {
                            const result = await callback();
                            return result;
                          } finally {
                            currentAutoPaginate = originalAutoPaginate;
                          }
                        };
                      }
                      if (prop === "withPaginationLimit") {
                        return async <T>(
                          limit: number,
                          callback: () => Promise<T>
                        ): Promise<T> => {
                          const originalAutoPaginate = currentAutoPaginate;
                          const originalLimit = paginationLimit;
                          currentAutoPaginate = true;
                          paginationLimit = limit;
                          try {
                            const result = await callback();
                            return result;
                          } finally {
                            currentAutoPaginate = originalAutoPaginate;
                            paginationLimit = originalLimit;
                          }
                        };
                      }
                      if (prop in methodMap) {
                        const methodName = prop as keyof QuickbaseClient;
                        return (
                          params: Parameters<QuickbaseClient[typeof methodName]>[0] = {}
                        ) =>
                          invokeMethod(
                            methodName,
                            params,
                            methodMap,
                            baseHeaders,
                            authStrategy,
                            rateLimiter,
                            transformDates,
                            debug,
                            convertDates,
                            currentAutoPaginate,
                            0,
                            rateLimiter.maxRetries + 1,
                            false,
                            paginationLimit
                          );
                      }
                      if (debug) {
                        console.error("[proxy] Method not found:", prop);
                      }
                      throw new Error(`Method '${prop}' not found in QuickbaseClient`);
                    },
                  };

                  const proxy = new Proxy<QuickbaseClient>({} as QuickbaseClient, proxyHandler);

                  // Prevent tree-shaking by statically referencing the methods
                  proxy.withPaginationDisabled;
                  proxy.withPaginationLimit;

                  if (debug) {
                    console.log("[quickbase] Config:", {
                      realm,
                      useSso,
                      useTicketAuth,
                      useTempTokens,
                      hasUserToken: !!userToken,
                      debug,
                      tempTokenLifespan,
                      ticketLifespanHours,
                      ticketRefreshThreshold, // Renamed
                      throttle,
                      maxRetries,
                      retryDelay,
                      baseUrl,
                      autoPaginate,
                    });
                    console.log("[quickbase] Returning proxy");
                  }

                  return proxy;
                }
        - name: >-
            generated
          type: >-
            directory
          children:
            - name: >-
                .openapi-generator
              type: >-
                directory
              children:
                - name: >-
                    FILES
                  type: >-
                    file
                - name: >-
                    VERSION
                  type: >-
                    file
            - name: >-
                .openapi-generator-ignore
              type: >-
                file
            - name: >-
                apis
              type: >-
                directory
              children:
                - name: >-
                    AppsApi.ts
                  type: >-
                    file
                - name: >-
                    AuditApi.ts
                  type: >-
                    file
                - name: >-
                    AuthApi.ts
                  type: >-
                    file
                - name: >-
                    DocumentTemplatesApi.ts
                  type: >-
                    file
                - name: >-
                    FieldsApi.ts
                  type: >-
                    file
                - name: >-
                    FilesApi.ts
                  type: >-
                    file
                - name: >-
                    FormulasApi.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticsApi.ts
                  type: >-
                    file
                - name: >-
                    RecordsApi.ts
                  type: >-
                    file
                - name: >-
                    ReportsApi.ts
                  type: >-
                    file
                - name: >-
                    SolutionsApi.ts
                  type: >-
                    file
                - name: >-
                    TablesApi.ts
                  type: >-
                    file
                - name: >-
                    UserTokenApi.ts
                  type: >-
                    file
                - name: >-
                    UsersApi.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
            - name: >-
                index.ts
              type: >-
                file
            - name: >-
                models
              type: >-
                directory
              children:
                - name: >-
                    AddManagersToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddManagersToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    AddMembersToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddMembersToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    AddSubgroupsToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddSubgroupsToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    Audit200Response.ts
                  type: >-
                    file
                - name: >-
                    Audit202Response.ts
                  type: >-
                    file
                - name: >-
                    AuditRequest.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200ResponseInnerChangesInnerInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution404Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CloneUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    CloneUserTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    CopyApp200Response.ts
                  type: >-
                    file
                - name: >-
                    CopyAppRequest.ts
                  type: >-
                    file
                - name: >-
                    CopyAppRequestProperties.ts
                  type: >-
                    file
                - name: >-
                    CreateApp200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateAppRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateField200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateFieldRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateFieldRequestProperties.ts
                  type: >-
                    file
                - name: >-
                    CreateRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateRelationshipRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInnerCreatedResourcesInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInnerCreatedResourcesInnerAppsInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CreateTable200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateTableRequest.ts
                  type: >-
                    file
                - name: >-
                    DeactivateUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteApp200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteAppRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteFields200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteFieldsRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteFile200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteRecords200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteRecordsRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteTable200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersAndGroups200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersAndGroupsRequest.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    DownloadFile200Response.ts
                  type: >-
                    file
                - name: >-
                    ExchangeSsoToken200Response.ts
                  type: >-
                    file
                - name: >-
                    ExchangeSsoTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution404Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    GenerateDocument200Response.ts
                  type: >-
                    file
                - name: >-
                    GetApp200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppEvents200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppEvents200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetAppTables200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppTables200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetField200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFieldUsage200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFieldUsage200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetFields200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFields200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetFieldsUsage200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFieldsUsage200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetRelationships200Response.ts
                  type: >-
                    file
                - name: >-
                    GetReport200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTable200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTableReports200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTableReports200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    GetTempTokenDBID200Response.ts
                  type: >-
                    file
                - name: >-
                    GetUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    GetUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    Permission.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200Response.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseMetadata.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseTotals.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseWhereInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummariesRequest.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummariesRequestWhereInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticReads200Response.ts
                  type: >-
                    file
                - name: >-
                    Record.ts
                  type: >-
                    file
                - name: >-
                    RecordValue.ts
                  type: >-
                    file
                - name: >-
                    RemoveManagersFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveManagersFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RemoveMembersFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveMembersFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RemoveSubgroupsFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveSubgroupsFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RunFormula200Response.ts
                  type: >-
                    file
                - name: >-
                    RunFormulaRequest.ts
                  type: >-
                    file
                - name: >-
                    RunQuery200Response.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequest.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestGroupByInner.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestOptions.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestSortByInner.ts
                  type: >-
                    file
                - name: >-
                    RunReport200Response.ts
                  type: >-
                    file
                - name: >-
                    TransferUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    TransferUserTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    UndenyUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    UndenyUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateApp200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateAppRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateField200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateFieldRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateRelationshipRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200ResponseInnerCreatedResourcesInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200ResponseItemsInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    UpdateTable200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateTableRequest.ts
                  type: >-
                    file
                - name: >-
                    Upsert200Response.ts
                  type: >-
                    file
                - name: >-
                    Upsert207Response.ts
                  type: >-
                    file
                - name: >-
                    Upsert400Response.ts
                  type: >-
                    file
                - name: >-
                    UpsertRequest.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
            - name: >-
                runtime.ts
              type: >-
                file
        - name: >-
            generated-unified
          type: >-
            directory
          children:
            - name: >-
                QuickbaseClient.ts
              type: >-
                file
            - name: >-
                missing-types-report.json
              type: >-
                file
        - name: >-
            rate-limiting
          type: >-
            directory
          children:
            - name: >-
                BurstAwareThrottleBucket.ts
              type: >-
                file
              contents: >
                //
                src/BurstAwareThrottleBucket.ts

                import
                {
                Semaphore
                }
                from
                "../utils/Semaphore";

                import
                {
                RateThrottleBucket
                }
                from
                "./RateThrottleBucket";


                export
                class
                BurstAwareThrottleBucket
                implements
                RateThrottleBucket
                {
                  maxTokens: number;
                  windowSeconds: number;
                  requestTimestamps: number[] = [];
                  semaphore: Semaphore;

                  constructor(options: { maxTokens: number; windowSeconds: number }) {
                    this.maxTokens = options.maxTokens;
                    this.windowSeconds = options.windowSeconds;
                    this.semaphore = new Semaphore(this.maxTokens);
                  }

                  countRequestsInWindow() {
                    const now = Date.now();
                    this.requestTimestamps = this.requestTimestamps.filter(
                      (ts) => now - ts < this.windowSeconds * 1000
                    );
                    return this.requestTimestamps.length;
                  }

                  availableTokens() {
                    const windowCount = this.countRequestsInWindow();
                    return Math.max(
                      0,
                      Math.min(100 - windowCount, this.maxTokens - windowCount)
                    );
                  }

                  async acquire() {
                    while (true) {
                      const available = this.availableTokens();
                      if (available > 0 && this.semaphore.available() > 0) {
                        await this.semaphore.acquire();
                        this.requestTimestamps.push(Date.now());
                        return;
                      }
                      const now = Date.now();
                      const oldestTimestamp = this.requestTimestamps[0];
                      let waitTime = 100;
                      if (oldestTimestamp) {
                        waitTime = Math.max(
                          0,
                          this.windowSeconds * 1000 - (now - oldestTimestamp)
                        );
                      }
                      await new Promise((resolve) => setTimeout(resolve, waitTime));
                    }
                  }

                  release() {
                    this.semaphore.release();
                  }
                }
            - name: >-
                FlowThrottleBucket.ts
              type: >-
                file
              contents: >
                //
                src/FlowThrottleBucket.ts

                import
                {
                Semaphore
                }
                from
                "../utils/Semaphore";

                import
                {
                RateThrottleBucket
                }
                from
                "./RateThrottleBucket";


                export
                class
                FlowThrottleBucket
                implements
                RateThrottleBucket
                {
                  private tokens: number;
                  private maxTokens: number;
                  private refillRate: number;
                  private lastRefill: number;
                  private semaphore: Semaphore;

                  constructor(rate: number, burst: number) {
                    this.tokens = burst;
                    this.maxTokens = burst;
                    this.refillRate = rate;
                    this.lastRefill = Date.now();
                    this.semaphore = new Semaphore(burst);
                  }

                  private refill(): void {
                    const now = Date.now();
                    const elapsed = (now - this.lastRefill) / 1000;
                    const newTokens = elapsed * this.refillRate;
                    this.tokens = Math.min(this.maxTokens, this.tokens + newTokens);
                    this.lastRefill = now;
                  }

                  async acquire(): Promise<void> {
                    await this.semaphore.acquire();
                    try {
                      this.refill();
                      while (this.tokens < 1) {
                        const waitTime = ((1 - this.tokens) / this.refillRate) * 1000;
                        await new Promise((resolve) => setTimeout(resolve, waitTime));
                        this.refill();
                      }
                      this.tokens -= 1;
                    } catch (error) {
                      this.semaphore.release();
                      throw error;
                    }
                  }

                  release(): void {
                    this.semaphore.release();
                  }
                }
            - name: >-
                RateLimitError.ts
              type: >-
                file
              contents: >
                //
                src/RateLimitError.ts

                export
                class
                RateLimitError
                extends
                Error
                {
                  public readonly status: number;
                  public readonly retryAfter?: number;

                  constructor(message: string, status: number, retryAfter?: number) {
                    super(message);
                    this.name = "RateLimitError";
                    this.status = status;
                    this.retryAfter = retryAfter; // Seconds from Retry-After header, if present
                  }
                }
            - name: >-
                RateThrottleBucket.ts
              type: >-
                file
              contents: >
                //
                src/RateThrottleBucket.ts

                export
                interface
                RateThrottleBucket
                {
                  acquire(): Promise<void>;
                  release(): void;
                }
            - name: >-
                index.ts
              type: >-
                file
              contents: ''
            - name: >-
                rateLimiter.ts
              type: >-
                file
        - name: >-
            utils
          type: >-
            directory
          children:
            - name: >-
                QuickbaseUtils.ts
              type: >-
                file
              contents: >
                //
                src/utils.ts


                export
                function
                simplifyName(methodName:
                string):
                string
                {
                  // Assuming this removes 'Raw' or similar suffixes as per your original logic
                  return methodName
                    .replace(/Raw$/, "")
                    .replace(/^./, (str) => str.toLowerCase());
                }


                export
                function
                getParamNames(func:
                Function):
                string[]
                {
                  // Your existing logic to extract parameter names from a function
                  const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
                  const ARGUMENT_NAMES = /([^\s,]+)/g;
                  const fnStr = func.toString().replace(STRIP_COMMENTS, "");
                  const result = fnStr
                    .slice(fnStr.indexOf("(") + 1, fnStr.indexOf(")"))
                    .match(ARGUMENT_NAMES);
                  return result || [];
                }


                export
                function
                transformDates(obj:
                any,
                convertStringsToDates:
                boolean):
                any
                {
                  // Your existing logic to transform dates
                  if (!obj || typeof obj !== "object") return obj;
                  if (Array.isArray(obj))
                    return obj.map((item) => transformDates(item, convertStringsToDates));
                  const result: any = {};
                  for (const [key, value] of Object.entries(obj)) {
                    if (
                      typeof value === "string" &&
                      convertStringsToDates &&
                      /^\d{4}-\d{2}-\d{2}/.test(value)
                    ) {
                      result[key] = new Date(value);
                    } else if (value instanceof Date) {
                      result[key] = value;
                    } else if (typeof value === "object") {
                      result[key] = transformDates(value, convertStringsToDates);
                    } else {
                      result[key] = value;
                    }
                  }
                  return result;
                }


                export
                function
                extractHttpMethod(method:
                Function):
                string
                {
                  const source = method.toString();
                  // Match the `method: 'SOME_METHOD'` part of the `request` call
                  const match = source.match(/method:\s*['"](\w+)['"]/i);
                  return match ? match[1].toUpperCase() : "GET"; // Fallback to GET if no match
                }
            - name: >-
                Semaphore.ts
              type: >-
                file
              contents: >
                //
                src/Semaphore.ts

                export
                class
                Semaphore
                {
                  private permits: number;
                  private waiting: Array<{ resolve: () => void; reject: (err: any) => void }> =
                    [];

                  constructor(maxPermits: number) {
                    this.permits = maxPermits;
                  }

                  async acquire(): Promise<void> {
                    if (this.permits > 0) {
                      this.permits -= 1;
                      return;
                    }
                    return new Promise((resolve, reject) => {
                      this.waiting.push({ resolve, reject });
                    });
                  }

                  release(): void {
                    this.permits += 1;
                    if (this.waiting.length > 0 && this.permits > 0) {
                      const { resolve } = this.waiting.shift()!;
                      this.permits -= 1;
                      resolve();
                    }
                  }

                  available(): number {
                    return this.permits;
                  }
                }
            - name: >-
                index.ts
              type: >-
                file
              contents: >
                export
                *
                from
                "./Semaphore";

                export
                *
                from
                "./QuickbaseUtils";
    - name: >-
        test-artifacts
      type: >-
        directory
      children:
        - name: >-
            .last-run.json
          type: >-
            file
    - name: >-
        tests
      type: >-
        directory
      children:
        - name: >-
            playwright
          type: >-
            directory
          children:
            - name: >-
                qb
              type: >-
                directory
              children:
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        cacheSwitching.test.ts
                      type: >-
                        file
                    - name: >-
                        fetchTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithTempTokenConcurrency.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithUserToken.test.ts
                      type: >-
                        file
                    - name: >-
                        getTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        tempTokenPrefetch.test.ts
                      type: >-
                        file
                    - name: >-
                        tempTokenRenewal.test.ts
                      type: >-
                        file
        - name: >-
            setup.ts
          type: >-
            file
        - name: >-
            vitest
          type: >-
            directory
          children:
            - name: >-
                qb
              type: >-
                directory
              children:
                - name: >-
                    apps
                  type: >-
                    directory
                  children:
                    - name: >-
                        copyApp.test.ts
                      type: >-
                        file
                    - name: >-
                        createApp.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppEvents.test.ts
                      type: >-
                        file
                    - name: >-
                        updateApp.test.ts
                      type: >-
                        file
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        mockQuickbaseServer.ts
                      type: >-
                        file
                    - name: >-
                        retryUserToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        ssoTokenConcurrency.test.ts
                      type: >-
                        file
                    - name: >-
                        ssoTokenIntegrationWithServer.test.ts
                      type: >-
                        file
                    - name: >-
                        ticketAuth.test.ts
                      type: >-
                        file
                    - name: >-
                        ticketAuthRetry.test.ts
                      type: >-
                        file
                    - name: >-
                        userTokenConcurrency.test.ts
                      type: >-
                        file
                - name: >-
                    fields
                  type: >-
                    directory
                  children:
                    - name: >-
                        createField.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getField.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        getFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldsUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        updateField.test.ts
                      type: >-
                        file
                - name: >-
                    formulas
                  type: >-
                    directory
                  children:
                    - name: >-
                        runFormula.test.ts
                      type: >-
                        file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    quickbase-js
                  type: >-
                    directory
                  children:
                    - name: >-
                        BurstAwareThrottleBucket.test.ts
                      type: >-
                        file
                    - name: >-
                        FlowBucket.test.ts
                      type: >-
                        file
                    - name: >-
                        paginationControl.test.ts
                      type: >-
                        file
                    - name: >-
                        paginationSkip.test.ts
                      type: >-
                        file
                - name: >-
                    records
                  type: >-
                    directory
                  children:
                    - name: >-
                        deleteRecords.test.ts
                      type: >-
                        file
                    - name: >-
                        runQuery.test.ts
                      type: >-
                        file
                    - name: >-
                        upsert.test.ts
                      type: >-
                        file
                - name: >-
                    tables
                  type: >-
                    directory
                  children:
                    - name: >-
                        createRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        createTable.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteTable.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppTables.test.ts
                      type: >-
                        file
                    - name: >-
                        getRelationships.test.ts
                      type: >-
                        file
                    - name: >-
                        getTable.test.ts
                      type: >-
                        file
                    - name: >-
                        updateRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        updateTable.test.ts
                      type: >-
                        file
            - name: >-
                quickbase-ticket-curl.test.ts
              type: >-
                file
            - name: >-
                unit
              type: >-
                directory
              children:
                - name: >-
                    apps
                  type: >-
                    directory
                  children:
                    - name: >-
                        copyApp.test.ts
                      type: >-
                        file
                    - name: >-
                        createApp.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppConcurrency.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppEvents.test.ts
                      type: >-
                        file
                    - name: >-
                        updateApp.test.ts
                      type: >-
                        file
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        fetchTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        getTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        retryTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        retryTempTokenMaxRetries.test.ts
                      type: >-
                        file
                    - name: >-
                        retryUserToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        ssoTokenRefresh.test.ts
                      type: >-
                        file
                    - name: >-
                        ticketAuth.test.ts
                      type: >-
                        file
                    - name: >-
                        userTokenConcurrency.test.ts
                      type: >-
                        file
                - name: >-
                    fields
                  type: >-
                    directory
                  children:
                    - name: >-
                        createField.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getField.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        getFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldsUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        updateField.test.ts
                      type: >-
                        file
                - name: >-
                    formulas
                  type: >-
                    directory
                  children:
                    - name: >-
                        runFormula.test.ts
                      type: >-
                        file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    quickbase-js
                  type: >-
                    directory
                  children:
                    - name: >-
                        BurstAwareThrottleBucket.test.ts
                      type: >-
                        file
                    - name: >-
                        FlowBucket.test.ts
                      type: >-
                        file
                    - name: >-
                        pagination.test.ts
                      type: >-
                        file
                    - name: >-
                        quickbaseClientHttpMethods.test.ts
                      type: >-
                        file
                    - name: >-
                        rateLimit.test.ts
                      type: >-
                        file
                    - name: >-
                        tokenLifespan.test.ts
                      type: >-
                        file
                - name: >-
                    records
                  type: >-
                    directory
                  children:
                    - name: >-
                        deleteRecords.test.ts
                      type: >-
                        file
                    - name: >-
                        runQuery.test.ts
                      type: >-
                        file
                    - name: >-
                        upsert.test.ts
                      type: >-
                        file
                - name: >-
                    tables
                  type: >-
                    directory
                  children:
                    - name: >-
                        createRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        createTable.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteTable.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppTables.test.ts
                      type: >-
                        file
                    - name: >-
                        getRelationships.test.ts
                      type: >-
                        file
                    - name: >-
                        getTable.test.ts
                      type: >-
                        file
                    - name: >-
                        updateRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        updateTable.test.ts
                      type: >-
                        file
    - name: >-
        tools
      type: >-
        directory
      children:
        - name: >-
            log-gen.ts
          type: >-
            file
        - name: >-
            log-gen.yaml
          type: >-
            file
        - name: >-
            openapi-jars
          type: >-
            directory
          children:
            - name: >-
                openapi-generator-cli-7.12.0.jar
              type: >-
                file
    - name: >-
        tsconfig.build.json
      type: >-
        file
    - name: >-
        tsconfig.json
      type: >-
        file
    - name: >-
        versionrc.json
      type: >-
        file
    - name: >-
        vitest.config.ts
      type: >-
        file

project: >-
  quickbase-js
date: >-
  3/19/2025
root: >-
  /home/drew/Projects/quickbase-js
goals:
  - >-
    A
    library
    for
    interacting
    with
    the
    QuickBase
    RESTful
    API.
  - >-
    Use
    OpenAPI
    to
    generate
    types
    and
    methods
    using
    a
    proxy.
    Validate
    with
    tests.
  - >-
    Provide
    robust
    and
    intuitive
    temporary
    token
    support
    for
    browser
    environments.
  - >-
    User
    Tokens
    support
    both
    Node.js
    and
    browser
    environments.
  - >-
    Use
    case:
    JS
    frameworks
    like
    React,
    Vue,
    and
    Angular
    hosted
    in
    QuickBase
    code
    pages.
  - >-
    Enable
    a
    flexible
    or
    native
    fetch
    in
    the
    browser.
  - >-
    Enable
    a
    flexible
    fetch
    framework
    in
    Node.js.
  - >-
    #
  - >-
    No
    manual
    updating
    methods
    when
    the
    QuickBase
    API
    changes.
  - >-
    The
    proxy
    magic
    dynamically
    maps
    generated
    methods
    and
    types.
  - >-
    #
  - >-
    TokenCache
    is
    defined
    per
    quickbaseClient
    call,
    so
    each
    instance
    has
    its
    own
    isolated
    TokenCache.
  - >-
    Each
    quickbase
    client
    instance
    has
    an
    isolated
    and
    individual
    token
    cache.
pipelineOverview:
  - >-
    What
    I’m
    Trying
    to
    Do
  - >-
    My
    approach
    is
    to
    ensure
    AppsApi.ts
    is
    generated
    with
    getAppById
    so
    QuickbaseClient.ts
    can
    map
    it
    to
    client.getApp.
    Steps
    include:
  - >-
    Fix
    fix-spec.ts:
  - >-
    Add
    tags:
    ["Apps"]
    to
    /apps/*
    endpoints
    to
    group
    them
    into
    AppsApi.ts.
  - >-
    Ensure
    all
    endpoints
    and
    models
    are
    correctly
    defined
    and
    typed.
  - >-
    Debug
    regenerate-client.ts:
  - >-
    Enhance
    logging
    to
    catch
    why
    AppsApi.ts
    isn’t
    generated.
  - >-
    Test
    if
    getAppById
    appears
    in
    another
    file
    (e.g.,
    DefaultApi.ts).
  - >-
    Update
    QuickbaseClient.ts:
  - >-
    Adjust
    imports
    to
    use
    the
    correct
    API
    class
    once
    generated.
  - >-
    Test
    and
    Iterate:
  - >-
    Run
    npm
    run
    fix-spec,
    npm
    run
    regenerate,
    and
    npm
    run
    test
    to
    verify
    AppsApi.ts
    exists
    and
    test.ts
    works.
  - >-
    The
    latest
    fix-spec.ts
    with
    tags
    aims
    to
    force
    the
    generator
    to
    create
    AppsApi.ts,
    addressing
    the
    missing
    file
    issue.
  - >-
    Relevant
    Project
    Files
  - >-
    Here’s
    a
    list
    of
    files
    that
    would
    help
    understand
    and
    resolve
    this
    problem,
    along
    with
    their
    roles:
  - >-
    src/code-generation/fix-spec.ts:
  - >-
    Role:
    Modifies
    the
    original
    QuickBase
    spec
    (e.g.,
    QuickBase_RESTful_*.json)
    to
    create
    quickbase-fixed.json
    with
    required
    endpoints
    (e.g.,
    /apps/{appId}).
  - >-
    Relevance:
    Defines
    the
    spec
    fed
    to
    the
    generator;
    errors
    here
    affect
    generation.
  - >-
    src/code-generation/quickbase-fixed.json:
  - >-
    Role:
    The
    processed
    OpenAPI
    spec
    used
    by
    regenerate-client.ts
    to
    generate
    code.
  - >-
    Relevance:
    Confirms
    if
    /apps/{appId}
    is
    correctly
    structured
    with
    operationId:
    "getAppById".
  - >-
    src/code-generation/regenerate-client.ts:
  - >-
    Role:
    Runs
    OpenAPI
    Generator
    to
    produce
    src/generated/
    files
    (APIs
    and
    models)
    and
    fixes
    .ts
    extensions
    with
    ts-morph.
  - >-
    Relevance:
    Controls
    the
    generation
    process;
    logs
    reveal
    why
    AppsApi.ts
    is
    missing.
  - >-
    src/generated/apis/AppsApi.ts
    (if
    exists):
  - >-
    Role:
    Should
    contain
    getAppById
    method
    for
    /apps/{appId}
    GET.
  - >-
    Relevance:
    Missing
    file
    is
    the
    core
    issue;
    its
    absence
    breaks
    QuickbaseClient.ts.
  - >-
    src/generated/apis/DefaultApi.ts:
  - >-
    Role:
    Default
    API
    class
    for
    untagged
    operations.
  - >-
    Relevance:
    Might
    contain
    getAppById
    if
    tags
    are
    misconfigured.
  - >-
    src/QuickbaseClient.ts:
  - >-
    Role:
    Wraps
    generated
    API
    classes
    (e.g.,
    AppsApi)
    in
    a
    Proxy
    for
    ergonomic
    calls
    (e.g.,
    client.getApp).
  - >-
    Relevance:
    Fails
    to
    import
    AppsApi.ts,
    causing
    the
    runtime
    error.
  - >-
    src/test.ts:
  - >-
    Role:
    Test
    script
    calling
    client.getApp({
    appId
    }).
  - >-
    Relevance:
    Final
    validation
    point;
    shows
    if
    the
    fix
    works.
  - >-
    .env.development:
  - >-
    Role:
    Stores
    QB_REALM,
    QB_USER_TOKEN,
    QB_APP_ID
    for
    API
    authentication.
  - >-
    Relevance:
    Ensures
    the
    API
    call
    has
    valid
    credentials
    (not
    the
    current
    issue,
    but
    critical
    for
    success).
  - >-
    src/specs/QuickBase_RESTful_API_2025-03-04T06_22_39.725Z.json
    (or
    similar):
  - >-
    Role:
    Original
    QuickBase
    API
    spec
    before
    fix-spec.ts
    processing.
  - >-
    Relevance:
    Shows
    how
    /apps/{appId}
    was
    originally
    defined,
    helping
    identify
    conflicts.
  - >-
    package.json:
  - >-
    Role:
    Defines
    scripts
    (fix-spec,
    regenerate,
    test)
    and
    dependencies
    (e.g.,
    ts-node,
    openapi-generator-cli).
  - >-
    Relevance:
    Confirms
    script
    commands
    and
    versions
    align
    with
    our
    process.
  - >-
    What
    We
    Achieved
  - >-
    Goal
    Met:
    You
    can
    now
    call
    client.getApp({
    appId:
    "buwai2zpe"
    })
    and
    get
    the
    app
    details
    {
    id:
    'buwai2zpe',
    name:
    'qb-copy'
    }.
  - >-
    Fixes
    Applied:
  - >-
    Added
    tags:
    ["Apps"]
    in
    fix-spec.ts
    to
    ensure
    AppsApi.ts
    is
    generated
    with
    getAppById.
  - >-
    Updated
    QuickbaseClient.ts
    to:
  - >-
    Use
    prototype
    methods
    via
    Object.getOwnPropertyNames.
  - >-
    Bind
    methods
    to
    preserve
    context
    with
    .bind(api).
  - >-
    Handle
    getAppById’s
    direct
    JSON
    return
    instead
    of
    a
    Response
    object.
  - >-
    Result:
    The
    ergonomic
    API
    you
    wanted
    (client.getApp)
    works
    seamlessly
    with
    the
    generated
    AppsApi.ts.
  - >-
    Why
    It
    Works
    Now
  - >-
    fix-spec.ts:
  - >-
    Correctly
    defined
    /apps/{appId}
    with
    operationId:
    "getAppById"
    and
    tags:
    ["Apps"],
    ensuring
    AppsApi.ts
    generation.
  - >-
    regenerate-client.ts:
  - >-
    Successfully
    ran
    OpenAPI
    Generator
    to
    produce
    AppsApi.ts
    with
    getAppById.
  - >-
    QuickbaseClient.ts:
  - >-
    buildMethodMap
    now
    captures
    getAppById
    and
    maps
    it
    to
    getApp.
  - >-
    invokeMethod
    passes
    {
    appId:
    'buwai2zpe'
    }
    as
    requestParameters
    and
    handles
    the
    JSON
    response
    directly.
  - >-
    test.ts:
  - >-
    Calls
    client.getApp
    and
    logs
    the
    result,
    proving
    the
    end-to-end
    flow.
tree:
  name: >-
    .
  type: >-
    directory
  children:
    - name: >-
        .env
      type: >-
        file
    - name: >-
        .gitignore
      type: >-
        file
    - name: >-
        CHANGELOG.md
      type: >-
        file
    - name: >-
        LICENSE
      type: >-
        file
    - name: >-
        README.md
      type: >-
        file
    - name: >-
        build-common.js
      type: >-
        file
    - name: >-
        build-esm.js
      type: >-
        file
    - name: >-
        build-umd.js
      type: >-
        file
    - name: >-
        dist
      type: >-
        directory
      children:
        - name: >-
            esm
          type: >-
            directory
          children:
            - name: >-
                quickbase.d.ts
              type: >-
                file
            - name: >-
                quickbase.js
              type: >-
                file
            - name: >-
                quickbase.js.map
              type: >-
                file
            - name: >-
                quickbase.min.js
              type: >-
                file
            - name: >-
                quickbase.min.js.map
              type: >-
                file
        - name: >-
            umd
          type: >-
            directory
          children:
            - name: >-
                quickbase.umd.js
              type: >-
                file
            - name: >-
                quickbase.umd.js.map
              type: >-
                file
            - name: >-
                quickbase.umd.min.js
              type: >-
                file
            - name: >-
                quickbase.umd.min.js.map
              type: >-
                file
    - name: >-
        examples
      type: >-
        directory
      children:
        - name: >-
            quicbase-jsCDN.html
          type: >-
            file
        - name: >-
            react.js
          type: >-
            file
        - name: >-
            vanillajs.html
          type: >-
            file
    - name: >-
        open-api
      type: >-
        directory
      children:
        - name: >-
            fix-spec-main.ts
          type: >-
            file
        - name: >-
            generate-override-report.ts
          type: >-
            file
        - name: >-
            generate-unified-interface.ts
          type: >-
            file
        - name: >-
            regenerate-client.ts
          type: >-
            file
        - name: >-
            schema
          type: >-
            directory
          children:
            - name: >-
                enhance-general.ts
              type: >-
                file
            - name: >-
                fix-arrays.ts
              type: >-
                file
            - name: >-
                tags
              type: >-
                directory
              children:
                - name: >-
                    apps.ts
                  type: >-
                    file
                - name: >-
                    fields.ts
                  type: >-
                    file
                - name: >-
                    groups.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    records.ts
                  type: >-
                    file
                - name: >-
                    tables.ts
                  type: >-
                    file
                - name: >-
                    users.ts
                  type: >-
                    file
        - name: >-
            types
          type: >-
            directory
          children:
            - name: >-
                spec.ts
              type: >-
                file
        - name: >-
            utils
          type: >-
            directory
          children:
            - name: >-
                generateJsDoc.ts
              type: >-
                file
            - name: >-
                infer-schema.ts
              type: >-
                file
            - name: >-
                naming.ts
              type: >-
                file
    - name: >-
        openapitools.json
      type: >-
        file
    - name: >-
        package-lock.json
      type: >-
        file
    - name: >-
        package.json
      type: >-
        file
    - name: >-
        playwright.config.ts
      type: >-
        file
    - name: >-
        rollup.config.js
      type: >-
        file
    - name: >-
        src
      type: >-
        directory
      children:
        - name: >-
            RateLimitError.ts
          type: >-
            file
          contents: >
            //
            src/RateLimitError.ts

            export
            class
            RateLimitError
            extends
            Error
            {
              public readonly status: number;
              public readonly retryAfter?: number;

              constructor(message: string, status: number, retryAfter?: number) {
                super(message);
                this.name = "RateLimitError";
                this.status = status;
                this.retryAfter = retryAfter; // Seconds from Retry-After header, if present
              }
            }
        - name: >-
            ThrottleBucket.ts
          type: >-
            file
          contents: >
            //
            src/ThrottleBucket.ts

            export
            class
            ThrottleBucket
            {
              private tokens: number;
              private maxTokens: number;
              private refillRate: number; // Tokens per second
              private lastRefill: number;
              private pending: Promise<void> = Promise.resolve(); // Queue for sequential execution

              constructor(rate: number, burst: number) {
                this.tokens = burst;
                this.maxTokens = burst;
                this.refillRate = rate;
                this.lastRefill = Date.now();
              }

              private refill(): void {
                const now = Date.now();
                const elapsed = (now - this.lastRefill) / 1000; // Seconds elapsed
                const newTokens = elapsed * this.refillRate;
                this.tokens = Math.min(this.maxTokens, this.tokens + newTokens);
                this.lastRefill = now;
              }

              async acquire(): Promise<void> {
                // Chain the new acquisition onto the pending queue
                const previous = this.pending;
                this.pending = (async () => {
                  await previous; // Wait for prior calls to complete
                  this.refill();
                  if (this.tokens >= 1) {
                    this.tokens -= 1;
                    return;
                  }
                  const waitTime = ((1 - this.tokens) / this.refillRate) * 1000; // ms until next token
                  await new Promise((resolve) => setTimeout(resolve, waitTime));
                  this.refill();
                  this.tokens -= 1;
                })();
                await this.pending;
              }
            }
        - name: >-
            authorizationStrategy.ts
          type: >-
            file
          contents: >
            //
            src/authorizationStrategy.ts

            import
            {
            TokenCache
            }
            from
            "./tokenCache";


            export
            interface
            AuthorizationStrategy
            {
              getToken(dbid: string): Promise<string | undefined>;
              applyHeaders(headers: Record<string, string>, token: string): void;
              handleError(
                status: number,
                params: any,
                fetchTempToken: (dbid: string) => Promise<string>,
                attempt: number,
                maxAttempts: number,
                debug?: boolean,
                methodName?: string
              ): Promise<string | null>;
            }


            export
            class
            TempTokenStrategy
            implements
            AuthorizationStrategy
            {
              constructor(
                private tokenCache: TokenCache,
                private initialTempToken?: string
              ) {}

              async getToken(dbid: string): Promise<string | undefined> {
                return this.tokenCache.get(dbid) || this.initialTempToken;
              }

              applyHeaders(headers: Record<string, string>, token: string): void {
                headers["Authorization"] = `QB-TEMP-TOKEN ${token}`;
              }

              async handleError(
                status: number,
                params: any,
                fetchTempToken: (dbid: string) => Promise<string>,
                attempt: number,
                maxAttempts: number,
                debug?: boolean,
                methodName?: string
              ): Promise<string | null> {
                if (status !== 401 || attempt >= maxAttempts - 1) return null;
                if (debug)
                  console.log(
                    `Authorization error for ${
                      methodName || "method"
                    } (temp token), refreshing token:`
                  );
                const dbid = extractDbid(params);
                if (!dbid) {
                  if (debug)
                    console.log(
                      `No dbid available for ${
                        methodName || "method"
                      }, skipping token refresh`
                    );
                  return null;
                }
                if (debug) console.log(`Refreshing temp token for dbid: ${dbid}`);
                const newToken = await fetchTempToken(dbid);
                this.tokenCache.set(dbid, newToken);
                return newToken;
              }
            }


            export
            class
            UserTokenStrategy
            implements
            AuthorizationStrategy
            {
              constructor(private userToken: string) {}

              async getToken(_dbid: string): Promise<string> {
                return this.userToken;
              }

              applyHeaders(headers: Record<string, string>, token: string): void {
                headers["Authorization"] = `QB-USER-TOKEN ${token}`;
              }

              async handleError(
                status: number,
                _params: any,
                _fetchTempToken: (dbid: string) => Promise<string>,
                attempt: number,
                maxAttempts: number,
                debug?: boolean,
                methodName?: string
              ): Promise<string | null> {
                if (status !== 401 || attempt >= maxAttempts - 1) return null;
                if (debug)
                  console.log(
                    `Retrying ${
                      methodName || "method"
                    } with existing user token: ${this.userToken.substring(0, 10)}...`
                  );
                return this.userToken;
              }
            }


            export
            function
            extractDbid(params:
            any):
            string
            |
            undefined
            {
              return (
                params.dbid ||
                params.tableId ||
                params.appId ||
                params.body?.from ||
                params.body?.to
              );
            }
        - name: >-
            generated
          type: >-
            directory
          children:
            - name: >-
                .openapi-generator
              type: >-
                directory
              children:
                - name: >-
                    FILES
                  type: >-
                    file
                - name: >-
                    VERSION
                  type: >-
                    file
            - name: >-
                .openapi-generator-ignore
              type: >-
                file
            - name: >-
                apis
              type: >-
                directory
              children:
                - name: >-
                    AppsApi.ts
                  type: >-
                    file
                - name: >-
                    AuditApi.ts
                  type: >-
                    file
                - name: >-
                    AuthApi.ts
                  type: >-
                    file
                - name: >-
                    DocumentTemplatesApi.ts
                  type: >-
                    file
                - name: >-
                    FieldsApi.ts
                  type: >-
                    file
                - name: >-
                    FilesApi.ts
                  type: >-
                    file
                - name: >-
                    FormulasApi.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticsApi.ts
                  type: >-
                    file
                - name: >-
                    RecordsApi.ts
                  type: >-
                    file
                - name: >-
                    ReportsApi.ts
                  type: >-
                    file
                - name: >-
                    SolutionsApi.ts
                  type: >-
                    file
                - name: >-
                    TablesApi.ts
                  type: >-
                    file
                - name: >-
                    UserTokenApi.ts
                  type: >-
                    file
                - name: >-
                    UsersApi.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
            - name: >-
                index.ts
              type: >-
                file
            - name: >-
                models
              type: >-
                directory
              children:
                - name: >-
                    AddManagersToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddManagersToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    AddMembersToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddMembersToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    AddSubgroupsToGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    AddSubgroupsToGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    Audit200Response.ts
                  type: >-
                    file
                - name: >-
                    Audit202Response.ts
                  type: >-
                    file
                - name: >-
                    AuditRequest.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution200ResponseInnerChangesInnerInner.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution404Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    ChangesetSolutionFromRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CloneUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    CloneUserTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    CopyApp200Response.ts
                  type: >-
                    file
                - name: >-
                    CopyAppRequest.ts
                  type: >-
                    file
                - name: >-
                    CopyAppRequestProperties.ts
                  type: >-
                    file
                - name: >-
                    CreateApp200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateAppRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateField200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateFieldRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateFieldRequestProperties.ts
                  type: >-
                    file
                - name: >-
                    CreateRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateRelationshipRequest.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInnerCreatedResourcesInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord200ResponseInnerCreatedResourcesInnerAppsInner.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    CreateSolutionFromRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    CreateTable200Response.ts
                  type: >-
                    file
                - name: >-
                    CreateTableRequest.ts
                  type: >-
                    file
                - name: >-
                    DeactivateUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteApp200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteAppRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteFields200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteFieldsRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteFile200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteRecords200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteRecordsRequest.ts
                  type: >-
                    file
                - name: >-
                    DeleteRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteTable200Response.ts
                  type: >-
                    file
                - name: >-
                    DeleteUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersAndGroups200Response.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersAndGroupsRequest.ts
                  type: >-
                    file
                - name: >-
                    DenyUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    DownloadFile200Response.ts
                  type: >-
                    file
                - name: >-
                    ExchangeSsoToken200Response.ts
                  type: >-
                    file
                - name: >-
                    ExchangeSsoTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution404Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    ExportSolutionToRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    GenerateDocument200Response.ts
                  type: >-
                    file
                - name: >-
                    GetApp200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppEvents200Response.ts
                  type: >-
                    file
                - name: >-
                    GetAppTables200Response.ts
                  type: >-
                    file
                - name: >-
                    GetField200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFieldUsage200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFields200Response.ts
                  type: >-
                    file
                - name: >-
                    GetFieldsUsage200Response.ts
                  type: >-
                    file
                - name: >-
                    GetRelationships200Response.ts
                  type: >-
                    file
                - name: >-
                    GetReport200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTable200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTableReports200Response.ts
                  type: >-
                    file
                - name: >-
                    GetTempTokenDBID200Response.ts
                  type: >-
                    file
                - name: >-
                    GetUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    GetUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    Permission.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200Response.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseMetadata.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInnerEventTypesInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseResultsInnerTotals.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseTotals.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummaries200ResponseWhereInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummariesRequest.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticEventSummariesRequestWhereInner.ts
                  type: >-
                    file
                - name: >-
                    PlatformAnalyticReads200Response.ts
                  type: >-
                    file
                - name: >-
                    Record.ts
                  type: >-
                    file
                - name: >-
                    RecordValue.ts
                  type: >-
                    file
                - name: >-
                    RemoveManagersFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveManagersFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RemoveMembersFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveMembersFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RemoveSubgroupsFromGroup200Response.ts
                  type: >-
                    file
                - name: >-
                    RemoveSubgroupsFromGroupRequest.ts
                  type: >-
                    file
                - name: >-
                    RunFormula200Response.ts
                  type: >-
                    file
                - name: >-
                    RunFormulaRequest.ts
                  type: >-
                    file
                - name: >-
                    RunQuery200Response.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequest.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestGroupByInner.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestOptions.ts
                  type: >-
                    file
                - name: >-
                    RunQueryRequestSortByInner.ts
                  type: >-
                    file
                - name: >-
                    RunReport200Response.ts
                  type: >-
                    file
                - name: >-
                    TransferUserToken200Response.ts
                  type: >-
                    file
                - name: >-
                    TransferUserTokenRequest.ts
                  type: >-
                    file
                - name: >-
                    UndenyUsers200Response.ts
                  type: >-
                    file
                - name: >-
                    UndenyUsersRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateApp200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateAppRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateField200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateFieldRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateRelationship200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateRelationshipRequest.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution200ResponseInnerCreatedResourcesInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution400Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution401403Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolution4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord200ResponseInner.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord400Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord401403Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord404Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateSolutionToRecord4xx5xxResponse.ts
                  type: >-
                    file
                - name: >-
                    UpdateTable200Response.ts
                  type: >-
                    file
                - name: >-
                    UpdateTableRequest.ts
                  type: >-
                    file
                - name: >-
                    Upsert200Response.ts
                  type: >-
                    file
                - name: >-
                    Upsert207Response.ts
                  type: >-
                    file
                - name: >-
                    Upsert400Response.ts
                  type: >-
                    file
                - name: >-
                    UpsertRequest.ts
                  type: >-
                    file
                - name: >-
                    index.ts
                  type: >-
                    file
            - name: >-
                runtime.ts
              type: >-
                file
              contents: >
                /*
                tslint:disable
                */

                /*
                eslint-disable
                */

                /**
                 * Quick Base API
                 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
                 *
                 * The version of the OpenAPI document: 1.0.0
                 * 
                 *
                 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
                 * https://openapi-generator.tech
                 * Do not edit the class manually.
                 */


                export
                const
                BASE_PATH
                =
                "https://api.quickbase.com/v1".replace(/\/+$/,
                "");


                export
                interface
                ConfigurationParameters
                {
                    basePath?: string; // override base path
                    fetchApi?: FetchAPI; // override for fetch implementation
                    middleware?: Middleware[]; // middleware to apply before/after fetch requests
                    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings
                    username?: string; // parameter for basic security
                    password?: string; // parameter for basic security
                    apiKey?: string | Promise<string> | ((name: string) => string | Promise<string>); // parameter for apiKey security
                    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security
                    headers?: HTTPHeaders; //header params we want to use on every request
                    credentials?: RequestCredentials; //value for the credentials param we want to use on each request
                }


                export
                class
                Configuration
                {
                    constructor(private configuration: ConfigurationParameters = {}) {}

                    set config(configuration: Configuration) {
                        this.configuration = configuration;
                    }

                    get basePath(): string {
                        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
                    }

                    get fetchApi(): FetchAPI | undefined {
                        return this.configuration.fetchApi;
                    }

                    get middleware(): Middleware[] {
                        return this.configuration.middleware || [];
                    }

                    get queryParamsStringify(): (params: HTTPQuery) => string {
                        return this.configuration.queryParamsStringify || querystring;
                    }

                    get username(): string | undefined {
                        return this.configuration.username;
                    }

                    get password(): string | undefined {
                        return this.configuration.password;
                    }

                    get apiKey(): ((name: string) => string | Promise<string>) | undefined {
                        const apiKey = this.configuration.apiKey;
                        if (apiKey) {
                            return typeof apiKey === 'function' ? apiKey : () => apiKey;
                        }
                        return undefined;
                    }

                    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
                        const accessToken = this.configuration.accessToken;
                        if (accessToken) {
                            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
                        }
                        return undefined;
                    }

                    get headers(): HTTPHeaders | undefined {
                        return this.configuration.headers;
                    }

                    get credentials(): RequestCredentials | undefined {
                        return this.configuration.credentials;
                    }
                }


                export
                const
                DefaultConfig
                =
                new
                Configuration();


                /**
                 * This is the base class for all generated API classes.
                 */
                export
                class
                BaseAPI
                {

                    private static readonly jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
                    private middleware: Middleware[];

                    constructor(protected configuration = DefaultConfig) {
                        this.middleware = configuration.middleware;
                    }

                    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {
                        const next = this.clone<T>();
                        next.middleware = next.middleware.concat(...middlewares);
                        return next;
                    }

                    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
                        const middlewares = preMiddlewares.map((pre) => ({ pre }));
                        return this.withMiddleware<T>(...middlewares);
                    }

                    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
                        const middlewares = postMiddlewares.map((post) => ({ post }));
                        return this.withMiddleware<T>(...middlewares);
                    }

                    /**
                     * Check if the given MIME is a JSON MIME.
                     * JSON MIME examples:
                     *   application/json
                     *   application/json; charset=UTF8
                     *   APPLICATION/JSON
                     *   application/vnd.company+json
                     * @param mime - MIME (Multipurpose Internet Mail Extensions)
                     * @return True if the given MIME is JSON, false otherwise.
                     */
                    protected isJsonMime(mime: string | null | undefined): boolean {
                        if (!mime) {
                            return false;
                        }
                        return BaseAPI.jsonRegex.test(mime);
                    }

                    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
                        const { url, init } = await this.createFetchParams(context, initOverrides);
                        const response = await this.fetchApi(url, init);
                        if (response && (response.status >= 200 && response.status < 300)) {
                            return response;
                        }
                        throw new ResponseError(response, 'Response returned an error code');
                    }

                    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {
                        let url = this.configuration.basePath + context.path;
                        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                            // only add the querystring to the URL if there are query parameters.
                            // this is done to avoid urls ending with a "?" character which buggy webservers
                            // do not handle correctly sometimes.
                            url += '?' + this.configuration.queryParamsStringify(context.query);
                        }

                        const headers = Object.assign({}, this.configuration.headers, context.headers);
                        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

                        const initOverrideFn =
                            typeof initOverrides === "function"
                                ? initOverrides
                                : async () => initOverrides;

                        const initParams = {
                            method: context.method,
                            headers,
                            body: context.body,
                            credentials: this.configuration.credentials,
                        };

                        const overriddenInit: RequestInit = {
                            ...initParams,
                            ...(await initOverrideFn({
                                init: initParams,
                                context,
                            }))
                        };

                        let body: any;
                        if (isFormData(overriddenInit.body)
                            || (overriddenInit.body instanceof URLSearchParams)
                            || isBlob(overriddenInit.body)) {
                          body = overriddenInit.body;
                        } else if (this.isJsonMime(headers['Content-Type'])) {
                          body = JSON.stringify(overriddenInit.body);
                        } else {
                          body = overriddenInit.body;
                        }

                        const init: RequestInit = {
                            ...overriddenInit,
                            body
                        };

                        return { url, init };
                    }

                    private fetchApi = async (url: string, init: RequestInit) => {
                        let fetchParams = { url, init };
                        for (const middleware of this.middleware) {
                            if (middleware.pre) {
                                fetchParams = await middleware.pre({
                                    fetch: this.fetchApi,
                                    ...fetchParams,
                                }) || fetchParams;
                            }
                        }
                        let response: Response | undefined = undefined;
                        try {
                            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
                        } catch (e) {
                            for (const middleware of this.middleware) {
                                if (middleware.onError) {
                                    response = await middleware.onError({
                                        fetch: this.fetchApi,
                                        url: fetchParams.url,
                                        init: fetchParams.init,
                                        error: e,
                                        response: response ? response.clone() : undefined,
                                    }) || response;
                                }
                            }
                            if (response === undefined) {
                              if (e instanceof Error) {
                                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
                              } else {
                                throw e;
                              }
                            }
                        }
                        for (const middleware of this.middleware) {
                            if (middleware.post) {
                                response = await middleware.post({
                                    fetch: this.fetchApi,
                                    url: fetchParams.url,
                                    init: fetchParams.init,
                                    response: response.clone(),
                                }) || response;
                            }
                        }
                        return response;
                    }

                    /**
                     * Create a shallow clone of `this` by constructing a new instance
                     * and then shallow cloning data members.
                     */
                    private clone<T extends BaseAPI>(this: T): T {
                        const constructor = this.constructor as any;
                        const next = new constructor(this.configuration);
                        next.middleware = this.middleware.slice();
                        return next;
                    }
                };


                function
                isBlob(value:
                any):
                value
                is
                Blob
                {
                    return typeof Blob !== 'undefined' && value instanceof Blob;
                }


                function
                isFormData(value:
                any):
                value
                is
                FormData
                {
                    return typeof FormData !== "undefined" && value instanceof FormData;
                }


                export
                class
                ResponseError
                extends
                Error
                {
                    override name: "ResponseError" = "ResponseError";
                    constructor(public response: Response, msg?: string) {
                        super(msg);
                    }
                }


                export
                class
                FetchError
                extends
                Error
                {
                    override name: "FetchError" = "FetchError";
                    constructor(public cause: Error, msg?: string) {
                        super(msg);
                    }
                }


                export
                class
                RequiredError
                extends
                Error
                {
                    override name: "RequiredError" = "RequiredError";
                    constructor(public field: string, msg?: string) {
                        super(msg);
                    }
                }


                export
                const
                COLLECTION_FORMATS
                =
                {
                    csv: ",",
                    ssv: " ",
                    tsv: "\t",
                    pipes: "|",
                };


                export
                type
                FetchAPI
                =
                WindowOrWorkerGlobalScope['fetch'];


                export
                type
                Json
                =
                any;

                export
                type
                HTTPMethod
                =
                'GET'
                |
                'POST'
                |
                'PUT'
                |
                'PATCH'
                |
                'DELETE'
                |
                'OPTIONS'
                |
                'HEAD';

                export
                type
                HTTPHeaders
                =
                {
                [key:
                string]:
                string
                };

                export
                type
                HTTPQuery
                =
                {
                [key:
                string]:
                string
                |
                number
                |
                null
                |
                boolean
                |
                Array<string
                |
                number
                |
                null
                |
                boolean>
                |
                Set<string
                |
                number
                |
                null
                |
                boolean>
                |
                HTTPQuery
                };

                export
                type
                HTTPBody
                =
                Json
                |
                FormData
                |
                URLSearchParams;

                export
                type
                HTTPRequestInit
                =
                {
                headers?:
                HTTPHeaders;
                method:
                HTTPMethod;
                credentials?:
                RequestCredentials;
                body?:
                HTTPBody
                };

                export
                type
                ModelPropertyNaming
                =
                'camelCase'
                |
                'snake_case'
                |
                'PascalCase'
                |
                'original';


                export
                type
                InitOverrideFunction
                =
                (requestContext:
                {
                init:
                HTTPRequestInit,
                context:
                RequestOpts
                })
                =>
                Promise<RequestInit>


                export
                interface
                FetchParams
                {
                    url: string;
                    init: RequestInit;
                }


                export
                interface
                RequestOpts
                {
                    path: string;
                    method: HTTPMethod;
                    headers: HTTPHeaders;
                    query?: HTTPQuery;
                    body?: HTTPBody;
                }


                export
                function
                querystring(params:
                HTTPQuery,
                prefix:
                string
                =
                ''):
                string
                {
                    return Object.keys(params)
                        .map(key => querystringSingleKey(key, params[key], prefix))
                        .filter(part => part.length > 0)
                        .join('&');
                }


                function
                querystringSingleKey(key:
                string,
                value:
                string
                |
                number
                |
                null
                |
                undefined
                |
                boolean
                |
                Array<string
                |
                number
                |
                null
                |
                boolean>
                |
                Set<string
                |
                number
                |
                null
                |
                boolean>
                |
                HTTPQuery,
                keyPrefix:
                string
                =
                ''):
                string
                {
                    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
                    if (value instanceof Array) {
                        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
                            .join(`&${encodeURIComponent(fullKey)}=`);
                        return `${encodeURIComponent(fullKey)}=${multiValue}`;
                    }
                    if (value instanceof Set) {
                        const valueAsArray = Array.from(value);
                        return querystringSingleKey(key, valueAsArray, keyPrefix);
                    }
                    if (value instanceof Date) {
                        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
                    }
                    if (value instanceof Object) {
                        return querystring(value as HTTPQuery, fullKey);
                    }
                    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
                }


                export
                function
                exists(json:
                any,
                key:
                string)
                {
                    const value = json[key];
                    return value !== null && value !== undefined;
                }


                export
                function
                mapValues(data:
                any,
                fn:
                (item:
                any)
                =>
                any)
                {
                  return Object.keys(data).reduce(
                    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
                    {}
                  );
                }


                export
                function
                canConsumeForm(consumes:
                Consume[]):
                boolean
                {
                    for (const consume of consumes) {
                        if ('multipart/form-data' === consume.contentType) {
                            return true;
                        }
                    }
                    return false;
                }


                export
                interface
                Consume
                {
                    contentType: string;
                }


                export
                interface
                RequestContext
                {
                    fetch: FetchAPI;
                    url: string;
                    init: RequestInit;
                }


                export
                interface
                ResponseContext
                {
                    fetch: FetchAPI;
                    url: string;
                    init: RequestInit;
                    response: Response;
                }


                export
                interface
                ErrorContext
                {
                    fetch: FetchAPI;
                    url: string;
                    init: RequestInit;
                    error: unknown;
                    response?: Response;
                }


                export
                interface
                Middleware
                {
                    pre?(context: RequestContext): Promise<FetchParams | void>;
                    post?(context: ResponseContext): Promise<Response | void>;
                    onError?(context: ErrorContext): Promise<Response | void>;
                }


                export
                interface
                ApiResponse<T>
                {
                    raw: Response;
                    value(): Promise<T>;
                }


                export
                interface
                ResponseTransformer<T>
                {
                    (json: any): T;
                }


                export
                class
                JSONApiResponse<T>
                {
                    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}

                    async value(): Promise<T> {
                        return this.transformer(await this.raw.json());
                    }
                }


                export
                class
                VoidApiResponse
                {
                    constructor(public raw: Response) {}

                    async value(): Promise<void> {
                        return undefined;
                    }
                }


                export
                class
                BlobApiResponse
                {
                    constructor(public raw: Response) {}

                    async value(): Promise<Blob> {
                        return await this.raw.blob();
                    };
                }


                export
                class
                TextApiResponse
                {
                    constructor(public raw: Response) {}

                    async value(): Promise<string> {
                        return await this.raw.text();
                    };
                }
        - name: >-
            generated-unified
          type: >-
            directory
          children:
            - name: >-
                QuickbaseClient.ts
              type: >-
                file
            - name: >-
                missing-types-report.json
              type: >-
                file
        - name: >-
            index.ts
          type: >-
            file
        - name: >-
            invokeMethod.ts
          type: >-
            file
          contents: >
            //
            src/invokeMethod.ts


            import
            {
            AuthorizationStrategy,
            extractDbid
            }
            from
            "./authorizationStrategy";

            import
            {
            RateLimiter
            }
            from
            "./rateLimiter";

            import
            {
            RateLimitError
            }
            from
            "./RateLimitError";

            import
            {
            ResponseError
            }
            from
            "./generated/runtime";

            import
            {
            QuickbaseClient
            }
            from
            "./quickbaseClient";

            import
            {
            GetTempTokenDBID200Response
            }
            from
            "./generated/models";


            export
            type
            ApiMethod<K
            extends
            keyof
            QuickbaseClient>
            =
            (
              requestParameters: Parameters<QuickbaseClient[K]>[0],
              initOverrides?: RequestInit
            )
            =>
            Promise<ReturnType<QuickbaseClient[K]>>;


            export
            interface
            MethodInfo<K
            extends
            keyof
            QuickbaseClient>
            {
              api: any;
              method: ApiMethod<K>;
              paramMap: string[];
              httpMethod: string;
            }


            export
            async
            function
            invokeMethod<K
            extends
            keyof
            QuickbaseClient>(
              methodName: K,
              params: Parameters<QuickbaseClient[K]>[0] & {
                dbid?: string;
                tableId?: string;
                appId?: string;
              },
              methodMap: { [P in keyof QuickbaseClient]: MethodInfo<P> },
              baseHeaders: Record<string, string>,
              authStrategy: AuthorizationStrategy,
              rateLimiter: RateLimiter,
              fetchTempToken: (dbid: string) => Promise<string>,
              transformDates: (obj: any, convertStringsToDates: boolean) => any,
              debug: boolean | undefined,
              convertDates: boolean
            ):
            Promise<ReturnType<QuickbaseClient[K]>>
            {
              console.log("[invokeMethod] Starting for method:", methodName);

              const methodInfo = methodMap[methodName];
              if (!methodInfo) throw new Error(`Method ${methodName} not found`);

              const hasBody = "body" in params && params.body !== undefined;
              const body = hasBody ? params.body : undefined;
              const restParams: any = hasBody
                ? Object.fromEntries(
                    Object.entries(params).filter(([key]) => key !== "body")
                  )
                : { ...params };
              const requestParameters: any = {
                ...restParams,
                ...(hasBody ? { generated: body } : {}),
              };

              const requestOptions: RequestInit = {
                credentials: methodName === "getTempTokenDBID" ? "include" : "omit",
                method: methodInfo.httpMethod,
              };

              let dbid: string | undefined = extractDbid(params);
              console.log("[invokeMethod] Extracted dbid:", dbid);

              let token = dbid
                ? await authStrategy.getToken(dbid)
                : await authStrategy.getToken("");
              console.log("[invokeMethod] Initial token:", token);

              if (!token && dbid) {
                token = await fetchTempToken(dbid);
                authStrategy.applyHeaders(baseHeaders, token);
                requestOptions.headers = { ...baseHeaders };
                console.log("[invokeMethod] Fetched new token:", token);
              }

              if (token) {
                authStrategy.applyHeaders(baseHeaders, token);
                requestOptions.headers = { ...baseHeaders };
                console.log(
                  "[invokeMethod] Token found, headers set:",
                  requestOptions.headers
                );
                if (methodName === "getTempTokenDBID") {
                  console.log("[invokeMethod] Using cached token:", token);
                  return { temporaryAuthorization: token } as ReturnType<
                    QuickbaseClient[K]
                  >;
                }
              }

              if (debug) {
                console.log(`[${methodName}] requestParameters:`, requestParameters);
                console.log(`[${methodName}] requestOptions:`, requestOptions);
              }

              async function processResponse(
                rawResponse: any
              ): Promise<ReturnType<QuickbaseClient[K]>> {
                if (debug) console.log(`[${methodName}] rawResponse:`, rawResponse);
                if (rawResponse instanceof Response) {
                  const contentType = rawResponse.headers
                    .get("Content-Type")
                    ?.toLowerCase();
                  if (debug) console.log(`[${methodName}] contentType:`, contentType);
                  if (contentType?.includes("application/json")) {
                    const jsonResponse = await rawResponse.json();
                    return transformDates(jsonResponse, convertDates) as ReturnType<
                      QuickbaseClient[K]
                    >;
                  }
                  return rawResponse as ReturnType<QuickbaseClient[K]>;
                }
                if (rawResponse && typeof rawResponse.value === "function") {
                  const response = await rawResponse.value();
                  if (debug)
                    console.log(`[${methodName}] Resolved JSONApiResponse:`, response);
                  return transformDates(response, convertDates) as ReturnType<
                    QuickbaseClient[K]
                  >;
                }
                return transformDates(rawResponse, convertDates) as ReturnType<
                  QuickbaseClient[K]
                >;
              }

              async function parseErrorResponse(
                response: any
              ): Promise<{ message: string; status: number }> {
                let message = "Unknown error";
                let status = response.status || 500;
                try {
                  const contentType =
                    response.headers?.get("Content-Type")?.toLowerCase() ||
                    "application/json";
                  if (
                    contentType.includes("application/json") &&
                    typeof response.json === "function"
                  ) {
                    const errorBody = await response.json();
                    if (
                      errorBody &&
                      typeof errorBody === "object" &&
                      "message" in errorBody
                    ) {
                      message = errorBody.message;
                    } else {
                      message = "Invalid error response format";
                    }
                  } else if (typeof response.text === "function") {
                    message = (await response.text()) || message;
                  }
                } catch (e) {
                  if (debug) console.log(`[${methodName}] Error parsing response body:`, e);
                  message = "Failed to parse error response";
                }
                console.log(
                  "[invokeMethod] Parsed error - status:",
                  status,
                  "message:",
                  message
                );
                return { message, status };
              }

              let attempt = 0;
              const maxAttempts = rateLimiter.maxRetries + 1;

              while (attempt < maxAttempts) {
                console.log("[invokeMethod] Attempt:", attempt + 1, "of", maxAttempts);
                try {
                  await rateLimiter.throttle();
                  console.log("[invokeMethod] About to call API for method:", methodName);
                  const response = await methodInfo.method(
                    requestParameters,
                    requestOptions
                  );
                  console.log("[invokeMethod] API call completed for method:", methodName);
                  return await processResponse(response);
                } catch (error) {
                  let status: number, message: string, response: any;

                  console.log("[invokeMethod] Caught error:", error);

                  if (error instanceof ResponseError && error.response) {
                    response = error.response;
                    ({ message, status } = await parseErrorResponse(response));
                  } else if (error instanceof Response) {
                    response = error;
                    ({ message, status } = await parseErrorResponse(response));
                  } else {
                    if (debug) console.log(`[${methodName}] Unexpected error:`, error);
                    throw error;
                  }

                  console.log("[invokeMethod] Handling error with status:", status);

                  if (status === 429) {
                    const delay = await rateLimiter.handle429(error, attempt + 1);
                    if (debug) console.log(`[${methodName}] 429 delay: ${delay}ms`);
                    if (attempt + 1 === maxAttempts) {
                      throw new RateLimitError(
                        `API Error: ${message} (Status: ${status})`,
                        status,
                        response.headers.get("Retry-After")
                          ? parseInt(response.headers.get("Retry-After")!, 10)
                          : undefined
                      );
                    }
                    await new Promise((resolve) => setTimeout(resolve, delay));
                    attempt++;
                    continue;
                  }

                  const newToken = await authStrategy.handleError(
                    status,
                    params,
                    fetchTempToken,
                    attempt,
                    maxAttempts,
                    debug,
                    methodName
                  );
                  if (newToken) {
                    token = newToken;
                    authStrategy.applyHeaders(baseHeaders, token);
                    requestOptions.headers = { ...baseHeaders };
                    attempt++;
                    if (debug)
                      console.log(
                        `[${methodName}] Retrying with token: ${token.substring(0, 10)}...`
                      );
                    continue;
                  }
                  throw new Error(`API Error: ${message} (Status: ${status})`);
                }
              }
              throw new Error(`API Error: Exhausted retries after ${maxAttempts} attempts`);
            }
        - name: >-
            quickbaseClient.ts
          type: >-
            file
          contents: >
            //
            src/quickbaseClient.ts


            import
            {
            QuickbaseClient
            as
            IQuickbaseClient
            }
            from
            "./generated-unified/QuickbaseClient";

            import
            {
            Configuration,
            HTTPHeaders
            }
            from
            "./generated/runtime";

            import
            *
            as
            apis
            from
            "./generated/apis";

            import
            {
            TokenCache
            }
            from
            "./tokenCache";

            import
            {
            simplifyName
            }
            from
            "./utils";

            import
            {
            invokeMethod,
            MethodInfo
            }
            from
            "./invokeMethod";

            import
            {
              TempTokenStrategy,
              UserTokenStrategy,
              AuthorizationStrategy,
            }
            from
            "./authorizationStrategy";

            import
            {
            ThrottleBucket
            }
            from
            "./ThrottleBucket";

            import
            {
            RateLimiter
            }
            from
            "./rateLimiter";


            export
            *
            from
            "./generated/models/index";


            export
            interface
            QuickbaseClient
            extends
            IQuickbaseClient
            {}


            export
            interface
            QuickbaseConfig
            {
              realm: string;
              userToken?: string;
              tempToken?: string;
              useTempTokens?: boolean;
              debug?: boolean;
              fetchApi?: typeof fetch;
              convertDates?: boolean;
              tempTokenLifespan?: number;
              throttle?: { rate: number; burst: number };
              maxRetries?: number;
              retryDelay?: number;
              tokenCache?: TokenCache;
            }


            type
            MethodMap
            =
            {
              [K in keyof QuickbaseClient]: MethodInfo<K>;
            };


            const
            getParamNames
            =
            (fn:
            (...args:
            any[])
            =>
            any):
            string[]
            =>
              fn
                .toString()
                .slice(fn.toString().indexOf("(") + 1, fn.toString().indexOf(")"))
                .split(",")
                .map((p) => p.trim().split("=")[0]?.trim())
                .filter((p) => p && !p.match(/^\{/) && p !== "options");

            function
            transformDates(obj:
            any,
            convertStringsToDates:
            boolean
            =
            true):
            any
            {
              if (obj === null || obj === undefined) return obj;
              if (obj instanceof Date) return obj;
              if (
                convertStringsToDates &&
                typeof obj === "string" &&
                /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?/.test(
                  obj
                )
              ) {
                return new Date(obj);
              }
              if (Array.isArray(obj)) {
                return obj.map((item) => transformDates(item, convertStringsToDates));
              }
              if (typeof obj === "object") {
                return Object.fromEntries(
                  Object.entries(obj).map(([key, value]) => [
                    key,
                    transformDates(value, convertStringsToDates),
                  ])
                );
              }
              return obj;
            }


            function
            inferHttpMethod(methodSource:
            string,
            debug?:
            boolean):
            string
            {
              const methodMatches = [
                ...methodSource.matchAll(/method:\s*['"]?(\w+)['"]?/gi),
              ];
              const method =
                methodMatches.length > 0
                  ? methodMatches[methodMatches.length - 1][1].toUpperCase()
                  : "GET";
              if (debug) {
                console.log(`[inferHttpMethod] Source:`, methodSource);
                console.log(
                  `[inferHttpMethod] All matches:`,
                  methodMatches.map((m) => m[0])
                );
                console.log(`[inferHttpMethod] Extracted method:`, method);
              }
              return method;
            }


            export
            function
            quickbase(config:
            QuickbaseConfig):
            QuickbaseClient
            {
              const {
                realm,
                userToken,
                tempToken,
                useTempTokens,
                fetchApi,
                debug,
                convertDates = true,
                tempTokenLifespan = 290000,
                throttle = { rate: 10, burst: 10 },
                maxRetries = 3,
                retryDelay = 1000,
                tokenCache: providedTokenCache,
              } = config;
              const baseUrl = `https://api.quickbase.com/v1`;

              const tokenCache = providedTokenCache || new TokenCache(tempTokenLifespan);
              const throttleBucket = throttle
                ? new ThrottleBucket(throttle.rate, throttle.burst)
                : null;
              const rateLimiter = new RateLimiter(throttleBucket, maxRetries, retryDelay);

              const authStrategy: AuthorizationStrategy = useTempTokens
                ? new TempTokenStrategy(tokenCache, tempToken)
                : new UserTokenStrategy(userToken || "");

              const baseHeaders: HTTPHeaders = {
                "QB-Realm-Hostname": `${realm}.quickbase.com`,
                "Content-Type": "application/json",
              };

              const defaultFetch: typeof fetch | undefined =
                typeof globalThis.window !== "undefined"
                  ? globalThis.window.fetch.bind(globalThis.window)
                  : undefined;
              const configuration = new Configuration({
                basePath: baseUrl,
                headers: { ...baseHeaders },
                fetchApi: fetchApi || defaultFetch,
                credentials: "omit",
              });

              if (!configuration.fetchApi && typeof globalThis.window === "undefined") {
                throw new Error(
                  "fetchApi must be provided in non-browser environments (e.g., Node.js)"
                );
              }

              const apiInstances = Object.fromEntries(
                Object.entries(apis)
                  .filter(([name]) => name.endsWith("Api"))
                  .map(([name, ApiClass]) => [
                    name.replace("Api", "").toLowerCase(),
                    new ApiClass(configuration),
                  ])
              );

              function buildMethodMap(): MethodMap {
                const methodMap: Partial<MethodMap> = {};
                const isValidMethod = (name: string) =>
                  !name.startsWith("_") &&
                  name !== "constructor" &&
                  !["Middleware", "Pre", "Post", "Raw"].some((s) => name.includes(s));

                for (const [apiName, api] of Object.entries(apiInstances)) {
                  Object.getOwnPropertyNames(Object.getPrototypeOf(api))
                    .filter(
                      (name) =>
                        isValidMethod(name) &&
                        typeof api[name as keyof typeof api] === "function"
                    )
                    .forEach((rawMethodName) => {
                      const simplifiedName = simplifyName(
                        rawMethodName
                      ) as keyof QuickbaseClient;
                      const rawMethodKey = `${rawMethodName}Raw` as keyof typeof api;
                      const method =
                        api[rawMethodKey] || api[rawMethodName as keyof typeof api];
                      const boundMethod = method.bind(api as any) as unknown;
                      if (typeof boundMethod === "function" && boundMethod.length <= 2) {
                        const methodSource = method.toString();
                        methodMap[simplifiedName] = {
                          api,
                          method: boundMethod as any,
                          paramMap: getParamNames(method),
                          httpMethod: inferHttpMethod(methodSource, debug),
                        };
                      }
                    });
                }
                if (debug) {
                  console.log("[buildMethodMap] Methods:", Object.keys(methodMap));
                }
                return methodMap as MethodMap;
              }

              const methodMap = buildMethodMap();

              const fetchTempToken = async (dbid: string): Promise<string> => {
                const effectiveFetch = fetchApi || defaultFetch;
                if (!effectiveFetch) {
                  throw new Error(
                    "No fetch implementation available for fetching temp token"
                  );
                }

                const response = await effectiveFetch(
                  `https://api.quickbase.com/v1/auth/temporary/${dbid}`,
                  {
                    method: "GET",
                    headers: { ...baseHeaders },
                    credentials: "include",
                  }
                );

                if (!response.ok) {
                  const errorBody: { message?: string } = await response.json();
                  throw new Error(
                    `API Error: ${errorBody.message || "Unknown error"} (Status: ${
                      response.status
                    })`
                  );
                }

                const tokenResult = await response.json();
                console.log(`[fetchTempToken] Response:`, tokenResult);
                const token = tokenResult.temporaryAuthorization;
                if (!token) {
                  throw new Error("No temporary token returned from API");
                }
                tokenCache.set(dbid, token, tempTokenLifespan);
                if (debug) {
                  console.log(`Fetched and cached new token for dbid: ${dbid}`, token);
                }
                return token;
              };

              const proxyHandler: ProxyHandler<QuickbaseClient> = {
                get: (_, prop: string) => {
                  console.log(
                    "[proxy] Accessing:",
                    prop,
                    "in methodMap:",
                    prop in methodMap
                  );
                  if (prop in methodMap) {
                    const methodName = prop as keyof QuickbaseClient;
                    return (params: Parameters<QuickbaseClient[typeof methodName]>[0]) =>
                      invokeMethod(
                        methodName,
                        params,
                        methodMap,
                        baseHeaders,
                        authStrategy,
                        rateLimiter,
                        fetchTempToken,
                        transformDates,
                        debug,
                        convertDates
                      );
                  }
                  console.log("[proxy] Method not found:", prop);
                  return undefined;
                },
              };

              const proxy = new Proxy<QuickbaseClient>({} as QuickbaseClient, proxyHandler);

              if (debug) {
                console.log("[createClient] Config:", config);
                console.log("[createClient] Proxy created:", proxy);
                console.log(
                  "[createClient] Testing proxy:",
                  proxy.getApp ? "Works" : "Fails"
                );
              }

              return proxy;
            }
        - name: >-
            rateLimiter.ts
          type: >-
            file
          contents: >
            //
            src/rateLimiter.ts

            import
            {
            ThrottleBucket
            }
            from
            "./ThrottleBucket";

            import
            {
            ResponseError
            }
            from
            "./generated/runtime";


            export
            class
            RateLimiter
            {
              constructor(
                private throttleBucket: ThrottleBucket | null,
                public maxRetries: number = 3,
                private retryDelay: number = 1000
              ) {}

              async throttle(): Promise<void> {
                if (this.throttleBucket) {
                  await this.throttleBucket.acquire();
                }
              }

              async handle429(error: ResponseError, attempt: number): Promise<number> {
                // Remove the throw here; let invokeMethod handle exhaustion
                const retryAfter = error.response.headers.get("Retry-After");
                return retryAfter
                  ? parseInt(retryAfter, 10) * 1000
                  : this.retryDelay * Math.pow(2, attempt - 1);
              }
            }
        - name: >-
            tokenCache.ts
          type: >-
            file
          contents: >
            //
            src/tokenCache.ts

            interface
            CachedToken
            {
              token: string;
              expiresAt: number;
            }


            export
            class
            TokenCache
            {
              private cache: Map<string, CachedToken>;
              private readonly tempTokenLifespan: number;

              constructor(tempTokenLifespan: number = 4 * 60 * 1000 + 50 * 1000) {
                this.cache = new Map<string, CachedToken>();
                this.tempTokenLifespan = tempTokenLifespan;
              }

              get(dbid: string): string | undefined {
                const entry = this.cache.get(dbid);
                const now = Date.now();
                if (entry && entry.expiresAt > now) return entry.token;
                if (entry) this.cache.delete(dbid); // Clean up expired temp tokens
                return undefined;
              }

              set(dbid: string, token: string, lifespan?: number): void {
                const now = Date.now();
                this.cache.set(dbid, {
                  token,
                  expiresAt: now + (lifespan || this.tempTokenLifespan),
                });
              }

              clear(): void {
                this.cache.clear();
              }
            }
        - name: >-
            utils.ts
          type: >-
            file
          contents: >
            //
            src/utils.ts

            export
            function
            simplifyName(name:
            string):
            string
            {
              return name
                .replace(/ById$/, "")
                .replace(/Api$/, "")
                .replace(/^(\w)/, (_, c) => c.toLowerCase());
            }
    - name: >-
        test-artifacts
      type: >-
        directory
      children:
        - name: >-
            .last-run.json
          type: >-
            file
        - name: >-
            test-results.json
          type: >-
            file
    - name: >-
        test-esm.js
      type: >-
        file
    - name: >-
        test-results.json
      type: >-
        file
    - name: >-
        test-umd.js
      type: >-
        file
    - name: >-
        test.log
      type: >-
        file
    - name: >-
        test.ts
      type: >-
        file
    - name: >-
        tests
      type: >-
        directory
      children:
        - name: >-
            playwright
          type: >-
            directory
          children:
            - name: >-
                qb
              type: >-
                directory
              children:
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        cacheSwitching.test.ts
                      type: >-
                        file
                    - name: >-
                        fetchTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppWithUserToken.test.ts
                      type: >-
                        file
                    - name: >-
                        getTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        tempTokenPrefetch.test.ts
                      type: >-
                        file
                    - name: >-
                        tempTokenRenewal.test.ts
                      type: >-
                        file
        - name: >-
            setup.ts
          type: >-
            file
        - name: >-
            vitest
          type: >-
            directory
          children:
            - name: >-
                qb
              type: >-
                directory
              children:
                - name: >-
                    apps
                  type: >-
                    directory
                  children:
                    - name: >-
                        copyApp.test.ts
                      type: >-
                        file
                    - name: >-
                        createApp.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppEvents.test.ts
                      type: >-
                        file
                    - name: >-
                        updateApp.test.ts
                      type: >-
                        file
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        retryUserToken401.test.ts
                      type: >-
                        file
                - name: >-
                    fields
                  type: >-
                    directory
                  children:
                    - name: >-
                        createField.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getField.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        getFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldsUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        updateField.test.ts
                      type: >-
                        file
                - name: >-
                    formulas
                  type: >-
                    directory
                  children:
                    - name: >-
                        runFormula.test.ts
                      type: >-
                        file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    records
                  type: >-
                    directory
                  children:
                    - name: >-
                        deleteRecords.test.ts
                      type: >-
                        file
                    - name: >-
                        runQuery.test.ts
                      type: >-
                        file
                    - name: >-
                        upsert.test.ts
                      type: >-
                        file
                - name: >-
                    tables
                  type: >-
                    directory
                  children:
                    - name: >-
                        createRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        createTable.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteTable.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppTables.test.ts
                      type: >-
                        file
                    - name: >-
                        getRelationships.test.ts
                      type: >-
                        file
                    - name: >-
                        getTable.test.ts
                      type: >-
                        file
                    - name: >-
                        updateRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        updateTable.test.ts
                      type: >-
                        file
            - name: >-
                unit
              type: >-
                directory
              children:
                - name: >-
                    ThrottleBucket.test.ts
                  type: >-
                    file
                - name: >-
                    apps
                  type: >-
                    directory
                  children:
                    - name: >-
                        copyApp.test.ts
                      type: >-
                        file
                    - name: >-
                        createApp.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getApp.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppEvents.test.ts
                      type: >-
                        file
                    - name: >-
                        updateApp.test.ts
                      type: >-
                        file
                - name: >-
                    auth
                  type: >-
                    directory
                  children:
                    - name: >-
                        fetchTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        getTempToken.test.ts
                      type: >-
                        file
                    - name: >-
                        retryTempToken401.test.ts
                      type: >-
                        file
                    - name: >-
                        retryTempTokenTwo401.test.ts
                      type: >-
                        file
                    - name: >-
                        retryUserToken401.test.ts
                      type: >-
                        file
                - name: >-
                    fields
                  type: >-
                    directory
                  children:
                    - name: >-
                        createField.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getField.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        getFields.test.ts
                      type: >-
                        file
                    - name: >-
                        getFieldsUsage.test.ts
                      type: >-
                        file
                    - name: >-
                        updateField.test.ts
                      type: >-
                        file
                - name: >-
                    formulas
                  type: >-
                    directory
                  children:
                    - name: >-
                        runFormula.test.ts
                      type: >-
                        file
                - name: >-
                    index.ts
                  type: >-
                    file
                - name: >-
                    inferHttpMethod.test.ts
                  type: >-
                    file
                - name: >-
                    rateLimit.test.ts
                  type: >-
                    file
                - name: >-
                    records
                  type: >-
                    directory
                  children:
                    - name: >-
                        deleteRecords.test.ts
                      type: >-
                        file
                    - name: >-
                        runQuery.test.ts
                      type: >-
                        file
                    - name: >-
                        upsert.test.ts
                      type: >-
                        file
                - name: >-
                    tables
                  type: >-
                    directory
                  children:
                    - name: >-
                        createRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        createTable.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        deleteTable.test.ts
                      type: >-
                        file
                    - name: >-
                        getAppTables.test.ts
                      type: >-
                        file
                    - name: >-
                        getRelationships.test.ts
                      type: >-
                        file
                    - name: >-
                        getTable.test.ts
                      type: >-
                        file
                    - name: >-
                        updateRelationship.test.ts
                      type: >-
                        file
                    - name: >-
                        updateTable.test.ts
                      type: >-
                        file
                - name: >-
                    tokenLifespan.test.ts
                  type: >-
                    file
                - name: >-
                    umd.test.ts
                  type: >-
                    file
    - name: >-
        text.txt
      type: >-
        file
    - name: >-
        tools
      type: >-
        directory
      children:
        - name: >-
            log-gen.ts
          type: >-
            file
        - name: >-
            log-gen.yaml
          type: >-
            file
        - name: >-
            openapi-jars
          type: >-
            directory
          children:
            - name: >-
                openapi-generator-cli-7.12.0.jar
              type: >-
                file
    - name: >-
        tsconfig.build.json
      type: >-
        file
    - name: >-
        tsconfig.json
      type: >-
        file
    - name: >-
        versionrc.json
      type: >-
        file
    - name: >-
        vitest.config.ts
      type: >-
        file
